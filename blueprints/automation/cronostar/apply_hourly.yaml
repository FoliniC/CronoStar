/** CronoStar Card - Visual Editor */  
import { LitElement, html } from 'lit';  
import { PRESETS, DEFAULT_CONFIG } from './config.js';  
  
class CronoStarEditor extends LitElement {  
  static get properties() {  
    return {  
      hass: { type: Object },  
      _config: { type: Object },  
      _configForm: { type: Object },  
      _automationYaml: { type: String }  
    };  
  }  
  
  constructor() {  
    super();  
    this._config = { ...DEFAULT_CONFIG, preset: 'thermostat' };  
    this._configForm = { ...this._config };  
    this._automationYaml = '';  
    this._debounceTimer = null;  
    this._DEBOUNCE_MS = 250;  
  
    // Bind per ha-form callbacks (garanzia di this)  
    this._computeLabel = this._computeLabel.bind(this);  
    this._computeHelper = this._computeHelper.bind(this);  
  }  
  
  setConfig(config) {  
    try {  
      const base = config && Object.keys(config).length ? config : { ...DEFAULT_CONFIG, preset: 'thermostat' };  
      this._config = { ...base };  
      // Manteniamo i valori grezzi per l'editor (es. hour_base come 'auto' | 0 | 1), senza normalizzarli  
      this._configForm = {  
        title: base.title || '',  
        preset: base.preset || 'thermostat',  
        logging_enabled: base.logging_enabled !== false,  
        hour_base: typeof base.hour_base === 'object' ? (base.hour_base.determined ? base.hour_base.value : 'auto') : (base.hour_base ?? 'auto'),  
        pause_entity: base.pause_entity || null,  
        profiles_select_entity: base.profiles_select_entity || null,  
        apply_entity: base.apply_entity || null,  
        allow_max_value: !!base.allow_max_value  
      };  
      this._automationYaml = this._buildAutomationYaml(this._configForm);  
    } catch {  
      this._config = { ...DEFAULT_CONFIG, preset: 'thermostat' };  
      this._configForm = { ...this._config };  
      this._automationYaml = this._buildAutomationYaml(this._configForm);  
    }  
  }  
  
  get _schema() {  
    const t = (k) => this._t(k);  
    const presetOptions = Object.keys(PRESETS).map((key) => ({  
      value: key,  
      label: this._localizePreset(key)  
    }));  
    // Nota: aggiungiamo comunque label/helper nello schema come fallback,  
    // ma la visualizzazione è garantita da computeLabel/computeHelper.  
    return [  
      {  
        name: 'title',  
        selector: { text: {} },  
        label: t('fields.title.label'),  
        helper: t('fields.title.desc')  
      },  
      {  
        name: 'preset',  
        selector: { select: { options: presetOptions } },  
        label: t('fields.preset.label'),  
        helper: t('fields.preset.desc')  
      },  
      {  
        name: 'logging_enabled',  
        selector: { boolean: {} },  
        label: t('fields.logging_enabled.label'),  
        helper: t('fields.logging_enabled.desc')  
      },  
      {  
        name: 'hour_base',  
        label: t('fields.hour_base.label'),  
        helper: t('fields.hour_base.desc'),  
        selector: {  
          select: {  
            options: [  
              { value: 'auto', label: t('fields.hour_base.auto') },  
              { value: 0, label: t('fields.hour_base.zero') },  
              { value: 1, label: t('fields.hour_base.one') }  
            ]  
          }  
        }  
      },  
      {  
        name: 'pause_entity',  
        selector: { entity: { domain: 'input_boolean' } },  
        label: t('fields.pause_entity.label'),  
        helper: t('fields.pause_entity.desc')  
      },  
      {  
        name: 'profiles_select_entity',  
        selector: { entity: { domain: 'input_select' } },  
        label: t('fields.profiles_select_entity.label'),  
        helper: t('fields.profiles_select_entity.desc')  
      },  
      {  
        name: 'apply_entity',  
        selector: { entity: {} },  
        label: t('fields.apply_entity.label'),  
        helper: t('fields.apply_entity.desc')  
      },  
      {  
        name: 'allow_max_value',  
        selector: { boolean: {} },  
        label: t('fields.allow_max_value.label'),  
        helper: t('fields.allow_max_value.desc')  
      }  
    ];  
  }  
  
  render() {  
    if (!this.hass) {  
      return html`<div style="padding:16px;">Home Assistant non è pronto. Riapri l’editor tra qualche istante.</div>`;  
    }  
    const t = (k) => this._t(k);  
    const data = this._configForm || { ...DEFAULT_CONFIG };  
    const hasTarget = !!data.apply_entity;  
    const presetLabel = this._localizePreset(data.preset);  
    return html`  
      <div class="cronostar-editor" style="padding:16px; display:grid; grid-template-columns: 1fr; gap: 12px;">  
        <ha-form  
          .hass=${this.hass}  
          .data=${data}  
          .schema=${this._schema}  
          .computeLabel=${this._computeLabel}  
          .computeHelper=${this._computeHelper}  
          @value-changed=${this._valueChanged}  
        ></ha-form>  
  
        <div style="margin-top:8px; border-top: 1px solid var(--divider-color); padding-top: 12px;">  
          <div style="font-weight:600; margin-bottom:6px;">${t('wizard.automation.title')}</div>  
          ${hasTarget ? html`  
            <div style="margin-bottom:8px;">  
              ${t('wizard.automation.summary')  
                .replace('{preset}', presetLabel)  
                .replace('{entity}', String(data.apply_entity))}  
              ${data.pause_entity ? html` ${t('wizard.automation.summary_pause').replace('{pause}', String(data.pause_entity))}` : html``}  
            </div>  
            <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">  
              <mwc-button outlined @click=${this._copyAutomationYaml}>${t('wizard.buttons.copy')}</mwc-button>  
              <mwc-button outlined @click=${this._downloadAutomationYaml}>${t('wizard.buttons.download')}</mwc-button>  
              <mwc-button raised @click=${this._createAutomation}>${t('wizard.buttons.create')}</mwc-button>  
            </div>  
            <pre style="background: var(--card-background-color); border:1px solid var(--divider-color); padding:8px; overflow:auto; max-height:220px; font-size:12px; line-height:1.4;">  
${this._automationYaml}  
            </pre>  
            <div style="margin-top:8px; font-size:12px; color:var(--secondary-text-color);">  
              ${t('wizard.automation.hint')}  
            </div>  
          ` : html`  
            <ha-alert alert-type="warning">  
              ${t('wizard.automation.missing')}  
            </ha-alert>  
          `}  
        </div>  
  
        <div style="margin-top:8px; border-top: 1px solid var(--divider-color); padding-top: 12px;">  
          <div style="font-weight:600; margin-bottom:6px;">${t('blueprint.title')}</div>  
          <ol style="margin:0; padding-left: 18px;">  
            <li>${t('blueprint.step1')}</li>  
            <li>${t('blueprint.step2')}</li>  
            <li>${t('blueprint.step3')}</li>  
            <li>${t('blueprint.step4')}</li>  
          </ol>  
        </div>  
      </div>  
    `;  
  }  
  
  _computeLabel(schema) {  
    const name = schema?.name;  
    if (!name) return '';  
    const t = (k) => this._t(k);  
    const map = {  
      title: t('fields.title.label'),  
      preset: t('fields.preset.label'),  
      logging_enabled: t('fields.logging_enabled.label'),  
      hour_base: t('fields.hour_base.label'),  
      pause_entity: t('fields.pause_entity.label'),  
      profiles_select_entity: t('fields.profiles_select_entity.label'),  
      apply_entity: t('fields.apply_entity.label'),  
      allow_max_value: t('fields.allow_max_value.label')  
    };  
    return map[name] || schema.label || String(name);  
  }  
  
  _computeHelper(schema) {  
    const name = schema?.name;  
    if (!name) return undefined;  
    const t = (k) => this._t(k);  
    const map = {  
      title: t('fields.title.desc'),  
      preset: t('fields.preset.desc'),  
      logging_enabled: t('fields.logging_enabled.desc'),  
      hour_base: t('fields.hour_base.desc'),  
      pause_entity: t('fields.pause_entity.desc'),  
      profiles_select_entity: t('fields.profiles_select_entity.desc'),  
      apply_entity: t('fields.apply_entity.desc'),  
      allow_max_value: t('fields.allow_max_value.desc')  
    };  
    return map[name] || schema.helper;  
  }  
  
  _localizePreset(key) {  
    const t = (k) => this._t(k);  
    switch (key) {  
      case 'thermostat': return t('preset.thermostat');  
      case 'ev_charging': return t('preset.ev_charging');  
      case 'generic_kwh': return t('preset.generic_kwh');  
      case 'generic_temperature': return t('preset.generic_temperature');  
      case 'generic_switch': return t('preset.generic_switch');  
      default: return key;  
    }  
  }  
  
  _t(key) {  
    const lang = (this.hass?.language || 'en').toLowerCase().startsWith('it') ? 'it' : 'en';  
    const dict = {  
      it: {  
        preset: {  
          thermostat: 'Termostato',  
          ev_charging: 'Ricarica EV',  
          generic_kwh: 'kWh generico',  
          generic_temperature: 'Temperatura generica',  
          generic_switch: 'Interruttore generico'  
        },  
        fields: {  
          title: { label: 'Titolo', desc: 'Titolo mostrato nella testata della card.' },  
          preset: { label: 'Preset', desc: 'Imposta il profilo e l’asse Y del grafico. Cambiandolo, min/max e unità si aggiornano.' },  
          logging_enabled: { label: 'Abilita logging', desc: 'Mostra log estesi in console per debug.' },  
          hour_base: {  
            label: 'Base oraria (hour_base)',  
            desc: 'Definisce la numerazione delle ore usata dagli input_number. “Auto” tenta il rilevamento.',  
            auto: 'Auto (rilevamento)',  
            zero: '0-based (00-23)',  
            one: '1-based (01-24)'  
          },  
          profiles_select_entity: {  
            label: 'Selettore profili (input_select)',  
            desc: 'Input_select che contiene i nomi dei profili. Selezionando un profilo, i 24 valori orari si caricano/salvano su quel profilo.'  
          },  
          pause_entity: {  
            label: 'Entità pausa (input_boolean)',  
            desc: 'Quando è ON sospende l’automazione oraria. Puoi attivarla/disattivarla dalla card.'  
          },  
          allow_max_value: {  
            label: 'Consenti valore massimo',  
            desc: 'Abilita un valore “massimo” speciale nel grafico (ancora/limite). Lascia disabilitato se non necessario.'  
          },  
          apply_entity: {  
            label: 'Entità di destinazione',  
            desc: 'Entità su cui applicare i valori pianificati (climate/number/switch). Abilitando questo campo, puoi generare l’automazione oraria e verificare la sincronizzazione.'  
          }  
        },  
        wizard: {  
          automation: {  
            title: 'Automazione oraria',  
            summary: 'Applicazione ogni ora del profilo {preset} su {entity}.',  
            summary_pause: '(condizionata da {pause} = off)',  
            hint: 'Puoi importare il YAML nelle Automazioni (YAML) o usare il Blueprint “CronoStar - Applica profilo ogni ora”.',  
            missing: 'Specifica l’Entità di destinazione (apply_entity) per generare automaticamente l’automazione oraria.'  
          },  
          buttons: { copy: 'Copia YAML', download: 'Scarica YAML', create: 'Crea automazione' },  
          toast: { copied: 'YAML copiato negli appunti.', copy_error: 'Impossibile copiare negli appunti.', download_ok: 'File YAML scaricato.', download_error: 'Errore nel download del file YAML.' },  
          create: { ok: 'Automazione creata.', err: 'Errore nella creazione dell’automazione. Usa il YAML o il Blueprint.' }  
        },  
        blueprint: {  
          title: 'Come usare il Blueprint',  
          step1: 'Salva il file blueprint in config/blueprints/automation/cronostar/apply_hourly.yaml (o importa da URL se pubblicato).',  
          step2: 'Vai in Impostazioni → Automazioni → Blueprint e apri “CronoStar - Applica profilo ogni ora”.',  
          step3: 'Crea una nuova automazione dal blueprint, inserendo apply_entity, preset_type e (opzionale) pause_entity.',  
          step4: 'Salva. L’automazione eseguirà allo scoccare di ogni ora.'  
        }  
      },  
      en: {  
        preset: {  
          thermostat: 'Thermostat',  
          ev_charging: 'EV charging',  
          generic_kwh: 'Generic kWh',  
          generic_temperature: 'Generic temperature',  
          generic_switch: 'Generic switch'  
        },  
        fields: {  
          title: { label: 'Title', desc: 'Title shown in the card header.' },  
          preset: { label: 'Preset', desc: 'Sets the profile and Y axis of the chart. Changing it updates min/max and units.' },  
          logging_enabled: { label: 'Enable logging', desc: 'Show extended console logs for debugging.' },  
          hour_base: {  
            label: 'Hour base (hour_base)',  
            desc: 'Defines the hour numbering used by input_numbers. “Auto” tries to detect it.',  
            auto: 'Auto (detection)',  
            zero: '0-based (00-23)',  
            one: '1-based (01-24)'  
          },  
          profiles_select_entity: {  
            label: 'Profiles selector (input_select)',  
            desc: 'Input_select listing profile names. Selecting a profile loads/saves the 24 hourly values for that profile.'  
          },  
          pause_entity: {  
            label: 'Pause entity (input_boolean)',  
            desc: 'When ON, suspends the hourly automation. You can toggle it from the card.'  
          },  
          allow_max_value: {  
            label: 'Allow max value',  
            desc: 'Enables a special “maximum” value in the chart (anchor/limit). Leave disabled if not needed.'  
          },  
          apply_entity: {  
            label: 'Target entity',  
            desc: 'Entity to apply scheduled values to (climate/number/switch). When set, you can generate the hourly automation and sync check.'  
          }  
        },  
        wizard: {  
          automation: {  
            title: 'Hourly automation',  
            summary: 'Apply the {preset} profile every hour to {entity}.',  
            summary_pause: '(conditioned by {pause} = off)',  
            hint: 'You can import the YAML into Automations (YAML) or use the “CronoStar - Apply profile hourly” blueprint.',  
            missing: 'Specify Target entity (apply_entity) to auto-generate the hourly automation.'  
          },  
          buttons: { copy: 'Copy YAML', download: 'Download YAML', create: 'Create automation' },  
          toast: { copied: 'YAML copied to clipboard.', copy_error: 'Unable to copy to clipboard.', download_ok: 'YAML file downloaded.', download_error: 'Error downloading YAML file.' },  
          create: { ok: 'Automation created.', err: 'Error creating automation. Use YAML or the Blueprint instead.' }  
        },  
        blueprint: {  
          title: 'How to use the Blueprint',  
          step1: 'Save the blueprint file to config/blueprints/automation/cronostar/apply_hourly.yaml (or import by URL if published).',  
          step2: 'Go to Settings → Automations → Blueprints and open “CronoStar - Apply profile hourly”.',  
          step3: 'Create a new automation from the blueprint, entering apply_entity, preset_type and optional pause_entity.',  
          step4: 'Save. The automation will run at every hour.'  
        }  
      }  
    };  
    const parts = key.split('.');  
    let cur = dict[lang];  
    for (const p of parts) {  
      cur = cur?.[p];  
      if (cur === undefined) break;  
    }  
    return typeof cur === 'string' ? cur : key;  
  }  
  
  _valueChanged(ev) {  
    ev.stopPropagation();  
    const newData = ev.detail?.value || {};  
    // Aggiorna lo stato del form senza normalizzazione  
    this._configForm = { ...this._configForm, ...newData };  
  
    // Aggiorna YAML automazione derivato dalla configurazione  
    this._automationYaml = this._buildAutomationYaml(this._configForm);  
  
    // Debounce dell’evento config-changed per non far perdere il focus durante la digitazione del titolo  
    clearTimeout(this._debounceTimer);  
    this._debounceTimer = setTimeout(() => {  
      const out = { ...this._config, ...this._configForm };  
      this._config = out;  
      this.dispatchEvent(new CustomEvent('config-changed', { detail: { config: out } }));  
    }, this._DEBOUNCE_MS);  
  }  
  
  _buildAutomationYaml(form) {  
    const preset = form.preset || 'thermostat';  
    const presetLabel = this._localizePreset(preset);  
    const applyEntity = form.apply_entity || '';  
    const pauseEntity = form.pause_entity || '';  
    const idSuffix = applyEntity ? applyEntity.replace('.', '_') : 'none';  
    const hasPause = !!pauseEntity;  
  
    const lines = [];  
    lines.push('automation:');  
    lines.push(`  - alias: "CronoStar - Applica profilo ogni ora (${presetLabel})"`);  
    lines.push(`    id: cronostar_apply_hourly_${preset}_${idSuffix}`);  
    lines.push('    mode: restart');  
    lines.push('    triggers:');  
    lines.push('      - trigger: time_pattern');  
    lines.push('        minutes: "0"');  
    if (hasPause) {  
      lines.push('    conditions:');  
      lines.push('      - condition: template');  
      lines.push(`        value: "{{ states('${pauseEntity}') != 'on' }}"`);  
    } else {  
      lines.push('    conditions: []');  
    }  
    lines.push('    actions:');  
    lines.push('      - action: cronostar.apply_now');  
    lines.push('        data:');  
    lines.push(`          entity_id: ${applyEntity || 'REPLACE_ME'}`);  
    lines.push(`          preset_type: ${preset}`);  
    return lines.join('\n');  
  }  
  
  async _copyAutomationYaml() {  
    const t = (k) => this._t(k);  
    try {  
      await navigator.clipboard.writeText(this._automationYaml);  
      this._showToast(t('wizard.toast.copied'));  
    } catch (e) {  
      this._showToast(t('wizard.toast.copy_error'));  
    }  
  }  
  
  _downloadAutomationYaml() {  
    const t = (k) => this._t(k);  
    try {  
      const filename = `cronostar_apply_hourly_${(this._configForm.preset || 'thermostat')}_${(this._configForm.apply_entity || 'entity').replace('.', '_')}.yaml`;  
      const blob = new Blob([this._automationYaml], { type: 'text/yaml' });  
      const url = URL.createObjectURL(blob);  
      const a = document.createElement('a');  
      a.href = url;  
      a.download = filename;  
      a.click();  
      setTimeout(() => URL.revokeObjectURL(url), 1000);  
      this._showToast(t('wizard.toast.download_ok'));  
    } catch (e) {  
      this._showToast(t('wizard.toast.download_error'));  
    }  
  }  
  
  async _createAutomation() {  
    const t = (k) => this._t(k);  
    try {  
      const form = this._configForm || {};  
      const applyEntity = form.apply_entity;  
      const preset = form.preset || 'thermostat';  
      if (!applyEntity) {  
        this._showToast(t('wizard.automation.missing'));  
        return;  
      }  
      const alias = `CronoStar - ${this._localizePreset(preset)} (${applyEntity})`;  
      const id = `cronostar_apply_hourly_${preset}_${applyEntity.replace('.', '_')}`;  
      const description = 'Generated by CronoStar Editor';  
  
      // Nuova sintassi (Home Assistant >= 2024.4): triggers, conditions, actions  
      const payload = {  
        type: 'automation/config/create',  
        alias,  
        id,  
        description,  
        mode: 'restart',  
        triggers: [  
          { trigger: 'time_pattern', minutes: '0' }  
        ],  
        conditions: form.pause_entity ? [  
          { condition: 'template', value: `{{ states('${form.pause_entity}') != 'on' }}` }  
        ] : [],  
        actions: [  
          { action: 'cronostar.apply_now', data: { entity_id: applyEntity, preset_type: preset } }  
        ]  
      };  
  
      if (!this.hass || typeof this.hass.callWS !== 'function') {  
        throw new Error('WebSocket API non disponibile');  
      }  
  
      await this.hass.callWS(payload);  
      this._showToast(t('wizard.create.ok'));  
    } catch (e) {  
      this._showToast(this._t('wizard.create.err'));  
    }  
  }  
  
  _showToast(message) {  
    try {  
      if (this.hass) {  
        this.hass.callService('persistent_notification', 'create', {  
          title: 'CronoStar',  
          message,  
          notification_id: `cronostar_editor_${Date.now()}`  
        });  
      } else {  
        // fallback  
        // eslint-disable-next-line no-alert  
        alert(message);  
      }  
    } catch {}  
  }  
}  
  
/** Robust, race-safe registration to avoid DOMException on duplicate resource loads */  
(function registerEditor() {  
  const TAG = 'cronostar_card-editor';  
  const FLAG = '__CRONOSTAR_EDITOR_REGISTERED__';  
  try {  
    if (customElements.get(TAG)) return;  
    if (window[FLAG]) return;  
    window[FLAG] = true;  
    const tryRegister = () => {  
      if (customElements.get(TAG)) return;  
      try {  
        customElements.define(TAG, CronoStarEditor);  
      } catch (e) {  
        // Swallow duplicate define errors caused by race/duplicate resources  
      }  
    };  
    Promise.resolve().then(tryRegister);  
    setTimeout(tryRegister, 0);  
  } catch (e) {  
    // Ignore if CustomElementRegistry not available  
  }  
})();  
  
export { CronoStarEditor };  