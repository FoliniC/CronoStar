# Task Name: CronoStar Card Files (Expanded - Full Project)
# Description: All files for the Home Assistant CronoStar Card component, including recursively found files, generated from the complete project structure.
# User Comment: All files for the Home Assistant CronoStar Card component, including recursively found files, generated from the complete project structure.
# Generated On: 2025-12-25 19:22:12.446261
# Configuration File: config_cronostar_card_expanded.yaml
# Base Directory: C:\Programs\Gemini\CronoStar.new
# Files Processed: 54
# Files Skipped: 1

# --- File: configuration.yaml ---
# Real size: 327 bytes, Used: 327 bytes
# Minimal Home Assistant configuration for CronoStar

default_config:

automation: !include_dir_merge_list automations
homeassistant:
  packages: !include_dir_named packages


lovelace:
  mode: yaml
  resources:
    #- url: /local/cronostar_card/cronostar-card.js
     # type: module

# Enable the CronoStar backend
cronostar:


# --- File: cronostar/profiles/cronostar_termostato_appartamento_data.json ---
# Real size: 3661 bytes, Used: 3661 bytes
{
    "meta":  {
                 "entity_prefix":  "cronostar_termostato_appartamento_",
                 "preset_type":  "thermostat",
                 "created_at":  "2025-12-18T18:55:31.303213",
    "updated_at": "2025-12-24T19:06:25.961282",
                 "preset":  "thermostat",
                 "hour_base":  {
                                   "value":  0,
                                   "determined":  false
                               },
                 "logging_enabled":  true,
                 "pause_entity":  "input_boolean.cronostar_termostato_appartamento_paused",
                 "profiles_select_entity":  "input_select.cronostar_termostato_appartamento_profiles",
    "apply_entity": "climate.climatizzazione_appartamento",
                 "allow_max_value":  false,
                 "missing_yaml_style":  "named",
                 "title":  "CronoStar Thermostat",
                 "y_axis_label":  "Temperature",
                 "unit_of_measurement":  "Â°C",
                 "min_value":  15,
                 "max_value":  30,
                 "step_value":  0.5,
                 "is_switch_preset":  false,
                 "type":  "custom:cronostar-card",
    "global_prefix": "cronostar_termostato_appartamento_",
    "target_entity": "climate.climatizzazione_appartamento"
             },
    "profiles":  {
                     "Comfort":  {
                                     "schedule":  [
                                                      {
                                                          "time":  "00:00",
                                                          "value":  15
                                                      },
                                                      {
                                                          "time":  "23:59",
                                                          "value":  15
                                                      }
                                                  ],
      "updated_at": "2025-12-22T19:24:53.923370"
                                 },
                     "Default":  {
                                     "schedule":  [
                                                      {
                                                          "time":  "00:00",
                                                          "value":  27
                                                      },
                                                      {
                                                          "time":  "02:50",
          "value": 27
                                                      },
                                                      {
          "time": "02:51",
          "value": 15
                                                      },
                                                      {
          "time": "08:51",
                                                          "value":  15
                                                      },
                                                      {
          "time": "08:52",
          "value": 25
                                                      },
                                                      {
                                                          "time":  "23:59",
          "value": 25
                                                      }
                                                  ],
      "updated_at": "2025-12-24T19:06:25.961318"
                                 }
                 },
  "saved_at": 1766599585.961359,
  "saved_at_iso": "2025-12-24T18:06:25.961359Z",
    "version":  2
}

# --- File: cronostar/profiles/cronostar_switch_presa_balcone_data.json ---
# Real size: 4489 bytes, Used: 4489 bytes
{
    "meta":  {
                 "global_prefix":  "cronostar_switch_presa_balcone_",
                 "preset_type":  "generic_switch",
                 "created_at":  "2025-12-21T01:35:46.499569",
    "updated_at": "2025-12-22T18:38:12.227630",
                 "preset":  "generic_switch",
                 "hour_base":  {
                                   "value":  0,
                                   "determined":  false
                               },
                 "logging_enabled":  true,
                 "pause_entity":  null,
                 "profiles_select_entity":  null,
                 "allow_max_value":  false,
                 "missing_yaml_style":  "named",
                 "title":  "Presa balcone",
                 "y_axis_label":  "State",
                 "unit_of_measurement":  "",
                 "min_value":  "0",
                 "max_value":  1,
                 "step_value":  1,
                 "is_switch_preset":  true,
                 "type":  "custom:cronostar-card",
    "target_entity": "switch.wifi_breaker_switch_luci_natale",
    "apply_entity": "switch.wifi_breaker_switch_luci_natale"
             },
    "profiles":  {
                     "Comfort":  {
                                     "schedule":  [
                                                      {
                                                          "time":  "00:00",
                                                          "value":  0
                                                      },
                                                      {
                                                          "time":  "06:45",
                                                          "value":  0
                                                      },
                                                      {
                                                          "time":  "06:46",
                                                          "value":  1
                                                      },
                                                      {
                                                          "time":  "08:05",
                                                          "value":  1
                                                      },
                                                      {
                                                          "time":  "08:06",
                                                          "value":  0
                                                      },
                                                      {
                                                          "time":  "16:42",
                                                          "value":  0
                                                      },
                                                      {
                                                          "time":  "16:43",
                                                          "value":  1
                                                      },
                                                      {
          "time": "23:59",
                                                          "value":  1
        }
      ],
      "updated_at": "2025-12-22T18:38:12.227659"
                                                      },
    "Default": {
      "schedule": [
                                                      {
          "time": "00:00",
                                                          "value":  0
                                                      },
                                                      {
          "time": "06:45",
                                                          "value":  0
        },
        {
          "time": "06:46",
          "value": 1
        },
        {
          "time": "08:05",
          "value": 1
        },
        {
          "time": "08:06",
          "value": 0
        },
        {
          "time": "16:42",
          "value": 0
        },
        {
          "time": "16:43",
          "value": 1
        },
        {
          "time": "23:59",
          "value": 1
                                                      }
                                                  ],
      "updated_at": "2025-12-21T21:12:17.516343"
                                 }
                 },
  "saved_at": 1766425092.2276945,
  "saved_at_iso": "2025-12-22T17:38:12.227695Z",
    "version":  2
}

# --- File: cronostar_card/eslint.config.js ---
# Real size: 425 bytes, Used: 425 bytes

import globals from "globals";
import js from "@eslint/js";

export default [
  js.configs.recommended,
  {
    languageOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        globals: {
            ...globals.browser,
            ...globals.node,
        }
    },
    rules: {
        "no-console": "off",
        "no-unused-vars": ["warn", { "args": "none", "caughtErrors": "none" }],
    }
  }
];


# --- File: cronostar_card/package.json ---
# Real size: 1357 bytes, Used: 1357 bytes
{
  "name": "cronostar-card",
  "version": "5.1.0",
  "description": "Visual hourly schedule editor for Home Assistant",
  "main": "cronostar_card/cronostar-card.js",
  "type": "module",
  "scripts": {
    "build": "rollup -c ",
    "watch": "rollup -c -w",
    "dev": "rollup -c -w",
    "lint:fix": "eslint src/ --fix"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/FoliniC/cronostar_card.git"
  },
  "keywords": [
    "home-assistant",
    "homeassistant",
    "hacs",
    "lovelace",
    "custom-card",
    "temperature",
    "scheduler",
    "thermostat"
  ],
  "author": "Your Name",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/FoliniC/cronostar_card/issues"
  },
  "homepage": "https://github.com/FoliniC/cronostar_card#readme",
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/preset-env": "^7.24.7",
    "@eslint/js": "^9.38.0",
    "@rollup/plugin-alias": "^6.0.0",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-commonjs": "^25.0.8",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-terser": "^0.4.4",
    "chart.js": "^4.5.1",
    "chartjs-plugin-dragdata": "^2.3.1",
    "eslint": "^9.5.0",
    "globals": "^16.4.0",
    "rollup": "^4.18.0"
  },
  "dependencies": {
    "chart.js": "^4.4.0",
    "chartjs-plugin-zoom": "^2.0.1",
    "lit": "^2.8.0"
  }
}


# --- File: cronostar_card/rollup.config.js ---
# Real size: 1344 bytes, Used: 1344 bytes
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';
import alias from '@rollup/plugin-alias';
import path from 'path';
import { fileURLToPath } from 'url';

const production = !process.env.ROLLUP_WATCH;
const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default {
  input: 'src/main.js',
  output: {
    file: '../custom_components/cronostar/www/cronostar_card/cronostar-card.js',
    format: 'es',
    sourcemap: false, // Disabled to prevent source map issues
    intro: '/* CronoStar Card - Bundled for Home Assistant */'
  },
  onwarn(warning, warn) {
    // Ignora warning sourcemap
    if (warning.code === 'SOURCEMAP_ERROR') return;
    if (warning.code === 'CIRCULAR_DEPENDENCY') return;
    warn(warning);
  },
  plugins: [
    alias({
      entries: [
        { find: '@editor', replacement: path.resolve(__dirname, 'src/editor') }
      ]
    }),
    resolve({
      extensions: ['.js', '.mjs'],
      browser: true
    }),
    commonjs({ include: 'node_modules/**' }),
    production && terser({
      format: {
        comments: false,
      },
      compress: {
        drop_console: false, // Keep console.log for debugging
        drop_debugger: true,
      },
      sourceMap: false
    }),
  ].filter(Boolean),
};


# --- File: cronostar_card/src/config.js ---
# Real size: 6465 bytes, Used: 6465 bytes
/** Configuration management for CronoStar Card with Interval Support */
export const VERSION = '5.1.1';

// Interval options (minutes)
// Sparse mode: remove interval options

export const CARD_CONFIG_PRESETS = {
  thermostat: {
    title: "CronoStar Thermostat",
    y_axis_label: "Temperature",
    unit_of_measurement: 'Â°C',
    min_value: 15,
    max_value: 30,
    step_value: 0.5,
    pause_entity: "input_boolean.cronostar_temp_paused",
    profiles_select_entity: "input_select.cronostar_temp_profiles",
    target_entity: "climate.climatizzazione_appartamento",
    is_switch_preset: false,
    allow_max_value: false,
    // sparse mode: no interval
  },
  ev_charging: {
    title: "CronoStar EV Charging",
    y_axis_label: "Power",
    unit_of_measurement: 'kW',
    min_value: 0,
    max_value: 8.0,
    step_value: 0.5,
    pause_entity: "input_boolean.cronostar_ev_paused",
    profiles_select_entity: "input_select.cronostar_ev_profiles",
    target_entity: "number.your_ev_charger_power",
    is_switch_preset: false,
    allow_max_value: true,
    // sparse mode: no interval
  },
  generic_kwh: {
    title: "CronoStar Generic kWh",
    y_axis_label: "Energy",
    unit_of_measurement: 'kWh',
    min_value: 0,
    max_value: 7,
    step_value: 0.5,
    pause_entity: "input_boolean.cronostar_kwh_paused",
    profiles_select_entity: "input_select.cronostar_kwh_profiles",
    target_entity: null,
    is_switch_preset: false,
    allow_max_value: false,
    // sparse mode: no interval
  },
  generic_temperature: {
    title: "CronoStar Generic Temperature",
    y_axis_label: "Temperature",
    unit_of_measurement: 'Â°C',
    min_value: 0,
    max_value: 40,
    step_value: 0.5,
    pause_entity: "input_boolean.cronostar_gentemp_paused",
    profiles_select_entity: "input_select.cronostar_gentemp_profiles",
    target_entity: null,
    is_switch_preset: false,
    allow_max_value: false,
    // sparse mode: no interval
  },
  generic_switch: {
    title: "CronoStar Generic Switch",
    y_axis_label: "State",
    unit_of_measurement: '',
    min_value: 0,
    max_value: 1,
    step_value: 1,
    pause_entity: "input_boolean.cronostar_switch_paused",
    profiles_select_entity: "input_select.cronostar_switch_profiles",
    target_entity: "switch.your_generic_switch",
    is_switch_preset: true,
    allow_max_value: false,
    // sparse mode: no interval
  }
};

export const DEFAULT_CONFIG = {
  type: 'custom:cronostar-card',
  preset: 'thermostat',
  hour_base: "auto",
  logging_enabled: true,
  pause_entity: null,
  profiles_select_entity: null,
  target_entity: null,
  allow_max_value: false,
  missing_yaml_style: 'named'
};

export const CHART_DEFAULTS = {
  minTemperature: 0,
  maxTemperature: 50,
  suggestedMinTemperature: 15,
  suggestedMaxTemperature: 30,
  temperatureStep: 0.5,
  pointRadius: 5,
  pointHoverRadius: 8,
  pointHitRadius: 10,
  pointMaxRadius: 8,
  borderWidth: 2,
  tension: 0
};

export const TIMEOUTS = {
  entityStateWait: 3000,
  entityNumericStateWait: 4000,
  scriptCompletion: 5000,
  statePropagation: 600,
  clickSuppression: 500,
  menuSuppression: 1000,
  automationSuppression: 7000,
  editingGraceMs: 45000,
  mismatchPersistenceMs: 20000
};

export const COLORS = {
  primary: "rgba(3, 169, 244, 1)",
  primaryLight: "rgba(3, 169, 244, 0.2)",
  selected: "red",
  selectedDark: "darkred",
  anchor: "#ff5252",
  anchorDark: "#b71c1c",
  max_value: '#FFD700',
  max_value_border: '#DAA520'
};

/**
 * Normalize alias keys used in Lovelace YAML (no-underscore) to the canonical
 * underscore-based keys expected by the card/editor/backend.
 */
export function normalizeConfigAliases(cfg = {}) {
  const out = { ...cfg };
  const pairs = [
    ['global_prefix', 'globalprefix'],
    ['target_entity', 'targetentity'],
    ['target_entity', 'apply_entity'],
    ['target_entity', 'applyentity'],
    ['pause_entity', 'pauseentity'],
    ['profiles_select_entity', 'profilesselectentity'],
    ['min_value', 'minvalue'],
    ['max_value', 'maxvalue'],
    ['step_value', 'stepvalue'],
    ['unit_of_measurement', 'unitofmeasurement'],
    ['y_axis_label', 'yaxislabel'],
    ['allow_max_value', 'allowmaxvalue'],
    ['logging_enabled', 'loggingenabled'],
    ['missing_yaml_style', 'missingyamlstyle']
  ];
  for (const [canonical, alias] of pairs) {
    const a = out[alias];
    const c = out[canonical];
    if ((a !== undefined && a !== null && a !== '') && (c === undefined || c === null || c === '')) {
      out[canonical] = a;
    }
  }
  return out;
}

// Sparse mode: getPointsCount removed

// Sparse mode: getIntervalConfig removed

/**
 * Validate configuration with interval support
 * - merges defaults, preset defaults, and user config
 * - ensures alias keys are normalized before merging
 */
export function validateConfig(config) {
  const normalized = normalizeConfigAliases(config);
  
  // Explicitly remove legacy aliases from the final object to avoid confusion in logs/ui
  const aliasesToRemove = [
    'globalprefix', 'targetentity', 'apply_entity', 'applyentity',
    'pauseentity', 'profilesselectentity', 'minvalue', 'maxvalue',
    'stepvalue', 'unitofmeasurement', 'yaxislabel', 'allowmaxvalue',
    'loggingenabled', 'missingyamlstyle'
  ];
  for (const alias of aliasesToRemove) {
    delete normalized[alias];
  }

  const presetName = normalized.preset || DEFAULT_CONFIG.preset;
  const presetConfig = CARD_CONFIG_PRESETS[presetName] || CARD_CONFIG_PRESETS.thermostat;
  const mergedConfig = { ...DEFAULT_CONFIG, ...presetConfig, ...normalized };
  
  // CRITICAL: Ensure card type is always correct and stable
  mergedConfig.type = config.type || DEFAULT_CONFIG.type;
  
  if (!mergedConfig.global_prefix) {
    throw new Error("Configuration error: global_prefix is required");
  }
  mergedConfig.hour_base = normalizeHourBase(mergedConfig.hour_base);

  return mergedConfig;
}

export function normalizeHourBase(hourBase) {
  if (hourBase === 0 || hourBase === 1) {
    return { value: hourBase, determined: true };
  }
  if (typeof hourBase === 'string') {
    const norm = hourBase.trim().toLowerCase();
    if (norm === '0' || norm === 'zero' || norm === '00') {
      return { value: 0, determined: true };
    }
    if (norm === '1' || norm === 'one' || norm === '01') {
      return { value: 1, determined: true };
    }
  }
  return { value: 0, determined: false };
}

export function getStubConfig() {
  return { ...DEFAULT_CONFIG };
}



# --- File: cronostar_card/src/core/CardEventHandlers.js ---
# Real size: 26748 bytes, Used: 26748 bytes
import { CARD_CONFIG_PRESETS, validateConfig, VERSION } from '../config.js';
import { Logger } from '../utils.js';
import { getEffectivePrefix } from '../utils/prefix_utils.js';
import { buildHelpersFilename } from '../utils/filename_utils.js';

export class CardEventHandlers {
    constructor(card) {
        this.card = card;
    }

    toggleMenu(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.card.isMenuOpen = !this.card.isMenuOpen;
        Logger.log('UI', '[CronoStar] toggleMenu: isMenuOpen is now', this.card.isMenuOpen);

        if (this.card.isMenuOpen) {
            this.card.keyboardHandler.disable();
        } else {
            this.card.keyboardHandler.enable();
            const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
            if (chartContainer && !this.card.isEditorContext()) {
                chartContainer.focus();
            }
        }

        this.card.requestUpdate();
    }

    handleLanguageSelect(lang) {
        Logger.log('LANG', `[CronoStar] handleLanguageSelect: ${lang}`);
        this.card.language = lang;
        this.card.isMenuOpen = false;
        this.card.keyboardHandler.enable();
        this.card.chartManager.updateChartLabels();

        const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
        if (chartContainer && !this.card.isEditorContext()) {
            chartContainer.focus();
        }

        this.card.requestUpdate();
    }

    async handleLoggingToggle(e) {
        e.stopPropagation();
        e.preventDefault();
        const newLoggingState = e.target.checked;
        Logger.log('UI', '[CronoStar] handleLoggingToggle:', newLoggingState);
        this.card.loggingEnabled = newLoggingState;
        this.card.config = { ...this.card.config, logging_enabled: newLoggingState };
        Logger.setEnabled(newLoggingState);

        await this.card.updateComplete;

        this.card.isMenuOpen = false;
        this.card.keyboardHandler.enable();

        const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
        if (chartContainer && !this.card.isEditorContext()) {
            chartContainer.focus();
        }
    }

    async handlePresetChange(e) {
        e.stopPropagation();
        e.preventDefault();

        const newPreset = e.detail?.value || e.target?.value;
        Logger.log('UI', '[CronoStar] handlePresetChange:', newPreset);

        if (!newPreset || newPreset === this.card.selectedPreset) {
            return;
        }

        this.card.selectedPreset = newPreset;

        const presetConfig = CARD_CONFIG_PRESETS[newPreset];
        this.card.config = {
            ...this.card.config,
            preset: newPreset,
            ...presetConfig
        };
        this.card.config = validateConfig(this.card.config);

        this.card.stateManager.setData(new Array(24).fill(null));
        this.card.awaitingAutomation = false;
        this.card.outOfSyncDetails = "";
        this.card.cardLifecycle.updateReadyFlag({ quiet: true });

        if (this.card.chartManager?.isInitialized()) {
            this.card.chartManager.recreateChartOptions();
        }

        await this.card.updateComplete;

        this.card.isMenuOpen = false;
        this.card.keyboardHandler.enable();

        const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
        if (chartContainer && !this.card.isEditorContext()) {
            chartContainer.focus();
        }

        if (this.card.chartManager.isInitialized()) {
            const chart = this.card.chartManager.getChart();
            if (chart) {
                chart.options.scales.y.min = this.card.config.min_value;
                chart.options.scales.y.max = this.card.config.max_value;
                chart.update();
            }
            this.card.chartManager.updateChartLabels();
        }

        this.card.cardSync.updateAutomationSync(this.card.hass);
    }

    handleSelectAll() {
        this.card.selectionManager.selectAll();
        this.card.chartManager?.updatePointStyling(
            this.card.selectionManager.selectedPoint,
            this.card.selectionManager.selectedPoints
        );
        this.card.chartManager?.update();
        this.card.isMenuOpen = false;
        this.card.keyboardHandler.enable();

        const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
        if (chartContainer && !this.card.isEditorContext()) {
            chartContainer.focus();
        }
    }

    handleAlignLeft() {
        this.card.stateManager.alignSelectedPoints('left');
        this.card.isMenuOpen = false;
    }

    handleAlignRight() {
        this.card.stateManager.alignSelectedPoints('right');
        this.card.isMenuOpen = false;
    }

    async handleApplyNow() {
        const localize = (key, search, replace) =>
            this.card.localizationManager.localize(this.card.language, key, search, replace);

        Logger.log('APPLY', `[CronoStar] "Apply Now" triggered.`);

        if (this.card.isMenuOpen) {
            this.card.isMenuOpen = false;
            this.card.keyboardHandler.enable();
        }

        if (!this.card.hass) {
            Logger.error('APPLY', '[CronoStar] Home Assistant not available');
            this.showNotification(localize('ui.apply_now_error') + ' (HA not connected)', 'error');
            return;
        }
        if (!this.card.cronostarReady) {
            Logger.warn('APPLY', '[CronoStar] Backend startup not completed yet, deferring apply.');
            this.showNotification(localize('ui.waiting_profile_restore'), 'error');
            return;
        }
        const targetEntity = this.card.config.target_entity;
        if (!targetEntity) {
            Logger.error('APPLY', '[CronoStar] `target_entity` is not configured in the card.');
            this.showNotification(localize('ui.apply_now_error') + ': target_entity not set', 'error');
            return;
        }

        try {
            const effectivePrefix = getEffectivePrefix(this.card.config);

            // Build sparse schedule payload for persistence
            const rawData = this.card.stateManager.getData() || [];
            const scheduleData = rawData
                .map((p) => ({
                    minutes: this.card.stateManager.timeToMinutes(p.time),
                    time: String(p.time),
                    value: Number(p.value)
                }))
                .filter((pt) => Number.isFinite(pt.value) && /^\d{2}:\d{2}$/.test(pt.time))
                .sort((a, b) => a.minutes - b.minutes)
                .map(({ time, value }) => ({ time, value }));

            const profileName = this.card.selectedProfile || this.card.profileManager.lastLoadedProfile || 'Comfort';

            // Persist profile explicitly like the wizard
            const safeMeta = (() => {
                const src = (this.card.config && typeof this.card.config === 'object') ? this.card.config : {};
                const { entity_prefix, ...rest } = src;
                if (!rest.global_prefix && effectivePrefix) rest.global_prefix = effectivePrefix;
                // Ensure scheduler can apply immediately by persisting the canonical target entity in profile meta
                if (!rest.target_entity && targetEntity) rest.target_entity = targetEntity;
                return rest;
            })();

            await this.card.hass.callService('cronostar', 'save_profile', {
                profile_name: profileName,
                preset_type: this.card.selectedPreset,
                schedule: scheduleData,
                global_prefix: effectivePrefix,
                meta: safeMeta,
            });

            this.card.hasUnsavedChanges = false;

            Logger.log('APPLY', `[CronoStar] Calling service 'cronostar.apply_now' for entity '${targetEntity}' with prefix '${effectivePrefix}'`);
            try {
                const first = scheduleData?.[0];
                const last = scheduleData?.[scheduleData.length - 1];
                Logger.log(
                    'APPLY',
                    `[CronoStar] apply_now payload: profile_name='${profileName}' preset_type='${this.card.selectedPreset}' global_prefix='${effectivePrefix}' schedule_len=${scheduleData?.length || 0} first=${first ? JSON.stringify(first) : 'null'} last=${last ? JSON.stringify(last) : 'null'} target_entity='${targetEntity}'`
                );
            } catch (e) {
                Logger.warn('APPLY', '[CronoStar] Failed to log apply_now payload:', e);
            }

            await this.card.hass.callService("cronostar", "apply_now", {
                target_entity: targetEntity,
                preset_type: this.card.selectedPreset,
                allow_max_value: this.card.config.allow_max_value,
                // IMPORTANT: backend save_profile requires global_prefix.
                // Use the same effective prefix used elsewhere (and ensure trailing underscore via getEffectivePrefix).
                global_prefix: effectivePrefix,
                // Provide optional persistence params so backend can save after apply
                profile_name: profileName,
                schedule: scheduleData,
                // Let backend persist enough config for later scheduler apply.
                // (safe: profile_service only uses meta when provided)
                meta: {
                    target_entity: targetEntity,
                },
            });

            const currentHour = new Date().getHours().toString().padStart(2, '0');
            this.showNotification(
                localize('ui.apply_now_success', { '{hour}': currentHour }),
                'success'
            );

            this.card.cardSync.scheduleAutomationOverlaySuppression();
            setTimeout(() => {
                try {
                    this.card.cardSync.updateAutomationSync(this.card.hass);
                    this.card.requestUpdate();
                } catch (e) { Logger.warn('APPLY', '[CronoStar] Error in setTimeout:', e); }
            }, 1000);
        } catch (err) {
            Logger.error('APPLY', '[CronoStar] Error during "Apply Now":', err);
            this.showNotification(`${localize('ui.apply_now_error')}: ${err.message}`, 'error');
        }

        const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
        if (chartContainer && !this.card.isEditorContext()) {
            chartContainer.focus();
        }

        this.card.requestUpdate();
    }

    // --- NEW: Add/Delete profile handlers ---
    async handleAddProfile() {
        const localize = (key, search, replace) =>
            this.card.localizationManager.localize(this.card.language, key, search, replace);

        try {
            if (!this.card.hass) {
                this.showNotification(localize('notify.add_profile_error', { '{error}': 'HA not connected' }), 'error');
                return;
            }

            const name = (typeof window !== 'undefined')
                ? window.prompt(localize('prompt.add_profile_name'))
                : null;
            const profileName = (name || '').trim();
            if (!profileName) {
                return; // user cancelled
            }

            // Optional: avoid duplicates client-side
            if (Array.isArray(this.card.profileOptions) && this.card.profileOptions.includes(profileName)) {
                this.showNotification(localize('notify.add_profile_error', { '{error}': 'Profile already exists' }), 'error');
                return;
            }

            await this.card.hass.callService('cronostar', 'add_profile', {
                profile_name: profileName,
                preset_type: this.card.selectedPreset,
                global_prefix: this.card.config.global_prefix
            });

            // Update UI
            try {
                // Update local options list immediately (backend will also refresh the input_select)
                if (!Array.isArray(this.card.profileOptions)) this.card.profileOptions = [];
                if (!this.card.profileOptions.includes(profileName)) {
                    this.card.profileOptions = [...this.card.profileOptions, profileName];
                }

                // Set selected profile and load it
                this.card.selectedProfile = profileName;
                await this.card.profileManager.loadProfile(profileName);

                // If we have an input_select entity, set the option there too
                if (this.card.config.profiles_select_entity) {
                    this.card.hass.callService('input_select', 'select_option', {
                        entity_id: this.card.config.profiles_select_entity,
                        option: profileName
                    }).catch(() => { /* ignore */ });
                }
            } catch (e) {
                Logger.warn('PROFILE', 'Post-create UI update failed:', e);
            }

            this.showNotification(localize('notify.add_profile_success', { '{profile}': profileName }), 'success');

        } catch (err) {
            Logger.error('PROFILE', '[CronoStar] Error adding profile:', err);
            const msg = err?.message || String(err);
            this.showNotification(this.card.localizationManager.localize(this.card.language, 'notify.add_profile_error', { '{error}': msg }), 'error');
        } finally {
            // Close menu, focus chart
            this.card.isMenuOpen = false;
            this.card.keyboardHandler.enable();
            const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
            if (chartContainer && !this.card.isEditorContext()) {
                chartContainer.focus();
            }
            this.card.requestUpdate();
        }
    }

    async handleDeleteProfile() {
        const localize = (key, search, replace) =>
            this.card.localizationManager.localize(this.card.language, key, search, replace);

        try {
            if (!this.card.hass) {
                this.showNotification(localize('notify.delete_profile_error', { '{error}': 'HA not connected' }), 'error');
                return;
            }

            const current = this.card.selectedProfile;
            if (!current) {
                this.showNotification(localize('notify.delete_profile_error', { '{error}': 'No profile selected' }), 'error');
                return;
            }

            const confirmed = (typeof window !== 'undefined')
                ? window.confirm(localize('prompt.delete_profile_confirm', { '{profile}': current }))
                : true;

            if (!confirmed) return;

            await this.card.hass.callService('cronostar', 'delete_profile', {
                profile_name: current,
                preset_type: this.card.selectedPreset,
                global_prefix: this.card.config.global_prefix
            });

            // Update options and selection
            try {
                const options = Array.isArray(this.card.profileOptions) ? [...this.card.profileOptions] : [];
                const idx = options.indexOf(current);
                if (idx >= 0) {
                    options.splice(idx, 1);
                    this.card.profileOptions = options;
                }

                // Pick next profile (first in list) or clear
                const next = options.length ? options[0] : '';
                this.card.selectedProfile = next;

                if (next) {
                    await this.card.profileManager.loadProfile(next);
                    if (this.card.config.profiles_select_entity) {
                        this.card.hass.callService('input_select', 'select_option', {
                            entity_id: this.card.config.profiles_select_entity,
                            option: next
                        }).catch(() => { /* ignore */ });
                    }
                } else {
                    // No profiles left: reset schedule to defaults
                    this.card.stateManager._initializeScheduleData();
                    if (this.card.chartManager?.isInitialized()) {
                        this.card.chartManager.updateData(this.card.stateManager.getData());
                    }
                }
            } catch (e) {
                Logger.warn('PROFILE', 'Post-delete UI update failed:', e);
            }

            this.showNotification(localize('notify.delete_profile_success', { '{profile}': current }), 'success');

        } catch (err) {
            Logger.error('PROFILE', '[CronoStar] Error deleting profile:', err);
            const msg = err?.message || String(err);
            this.showNotification(this.card.localizationManager.localize(this.card.language, 'notify.delete_profile_error', { '{error}': msg }), 'error');
        } finally {
            // Close menu, focus chart
            this.card.isMenuOpen = false;
            this.card.keyboardHandler.enable();
            const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
            if (chartContainer && !this.card.isEditorContext()) {
                chartContainer.focus();
            }
            this.card.requestUpdate();
        }
    }

    handleHelp() {
        const title = this.card.localizationManager.localize(this.card.language, 'help.title');
        const text = this.card.localizationManager.localize(this.card.language, 'help.text');
        // Current Configuration Info
        const cardId = this.card.cardId || 'Not registered';
        const preset = this.card.config?.preset || 'thermostat';
        const prefix = getEffectivePrefix(this.card.config);
        const targetEntity = this.card.config?.target_entity || 'Not configured';
        const profileEntity = this.card.config?.profiles_select_entity || 'Not configured';
        const pauseEntity = this.card.config?.pause_entity || 'Not configured';
        const currentProfile = this.card.selectedProfile || 'No profile selected';
        
        // Entity States (from registration)
        const states = this.card.entityStates || {};
        const stTarget = states.target ? ` (${states.target})` : '';
        const stHelper = states.current_helper ? ` (${states.current_helper})` : '';
        const stSelector = states.selector ? ` (${states.selector})` : '';
        const stPause = states.pause ? ` (${states.pause})` : '';

        // Expected entities
        const prefixBase = prefix.replace(/_+$/, '');
        const currentEntity = `input_number.${prefix}current`;
        const packageFile = buildHelpersFilename(prefix);
        const packagePath = `config/packages/${packageFile}`;
        // Interval info
        const interval = this.card.config?.interval_minutes || 60;
        const numPoints = Math.floor(1440 / interval);
        const configInfo = this.card.language === 'it'
            ? `=== Configurazione Attuale ===
Card ID: ${cardId}
Versione: ${VERSION}
Preset: ${preset}
Profilo Attivo: ${currentProfile}
Prefisso: ${prefix}

=== EntitÃ  ===
EntitÃ  Destinazione: ${targetEntity}${stTarget}
EntitÃ  Valore Corrente: ${currentEntity}${stHelper}
Selettore Profili: ${profileEntity}${stSelector}
EntitÃ  Pausa: ${pauseEntity}${stPause}

=== Configurazione ===
File Package: /config/packages/${packageFile}
Intervallo: ${interval} minuti
Punti Schedule: ${numPoints}

=== Istruzioni ===
${text}

=== File di Configurazione ===
Il sistema utilizza:
1. Package: /${packagePath}   Contiene tutte le entitÃ  helper necessarie
2. Profili: /config/cronostar/profiles/${prefixBase}_data.json   Contiene tutti i profili salvati per questo preset
3. Automazione: Da creare tramite l'editor (Step 4)   o manualmente in automations/

=== Prossimi Passi ===
1. Se non l'hai fatto, crea il package usando l'editor (Step 2)
2. Copia il contenuto in /${packagePath}
3. Riavvia Home Assistant
4. Crea l'automazione usando l'editor (Step 4)
5. Salva la configurazione della card`
            : `=== Current Configuration ===
Card ID: ${cardId}
Version: ${VERSION}
Preset: ${preset}
Active Profile: ${currentProfile}
Prefix: ${prefix}

=== Entities ===
Target Entity: ${targetEntity}${stTarget}
Current Value Entity: ${currentEntity}${stHelper}
Profiles Selector: ${profileEntity}${stSelector}
Pause Entity: ${pauseEntity}${stPause}

=== Configuration ===
Package File: /config/packages/${packageFile}
Interval: ${interval} minutes
Schedule Points: ${numPoints}

=== Instructions ===
${text}

=== Configuration Files ===
The system uses:
1. Package: /${packagePath}   Contains all required helper entities
2. Profiles: /config/cronostar/profiles/${prefixBase}_data.json   Contains all saved profiles for this preset
3. Automation: To be created via editor (Step 4)   or manually in automations/

=== Next Steps ===
1. If not done, create package using editor (Step 2)
2. Copy content to /${packagePath}
3. Restart Home Assistant
4. Create automation using editor (Step 4)
5. Save card configuration`;

        // Create custom dialog overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
    `;
        const dialog = document.createElement('div');
        dialog.style.cssText = `
      background: var(--card-background-color, white);
      border-radius: 8px;
      padding: 24px;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    `;
        const headerDiv = document.createElement('div');
        headerDiv.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    `;
        const titleEl = document.createElement('h2');
        titleEl.textContent = title;
        titleEl.style.cssText = `
      margin: 0;
      color: var(--primary-text-color);
    `;
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'âœ•';
        closeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--primary-text-color);
      padding: 0;
      width: 32px;
      height: 32px;
    `;
        closeBtn.onclick = () => overlay.remove();
        const textarea = document.createElement('textarea');
        textarea.value = configInfo;
        textarea.readOnly = true;
        textarea.style.cssText = `
      width: 100%;
      min-height: 400px;
      font-family: monospace;
      font-size: 12px;
      padding: 12px;
      border: 1px solid var(--divider-color);
      border-radius: 4px;
      background: var(--code-editor-background-color, #1e1e1e);
      color: var(--code-editor-color, #d4d4d4);
      resize: vertical;
      box-sizing: border-box;
    `;
        const copyBtn = document.createElement('button');
        copyBtn.textContent = this.card.language === 'it' ? 'ðŸ“‹ Copia negli appunti' : 'ðŸ“‹ Copy to clipboard';
        copyBtn.style.cssText = `
      margin-top: 12px;
      padding: 8px 16px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    `;
        copyBtn.onclick = async () => {
            try {
                await navigator.clipboard.writeText(configInfo);
                copyBtn.textContent = this.card.language === 'it' ? 'âœ… Copiato!' : 'âœ… Copied!';
                setTimeout(() => {
                    copyBtn.textContent = this.card.language === 'it' ? 'ðŸ“‹ Copia negli appunti' : 'ðŸ“‹ Copy to clipboard';
                }, 2000);
            } catch (e) {
                Logger.warn('HELP', 'Failed to copy to clipboard:', e);
            }
        };
        headerDiv.appendChild(titleEl);
        headerDiv.appendChild(closeBtn);
        dialog.appendChild(headerDiv);
        dialog.appendChild(textarea);
        dialog.appendChild(copyBtn);
        overlay.appendChild(dialog);
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        });
        document.body.appendChild(overlay);
        // Select text for easy copying
        textarea.select();
    } // Missing closing brace added here
    async togglePause(e) {
        try {
            const checked = e?.target?.checked === true;
            const entityId = this.card.config?.pause_entity;
            if (!entityId || !this.card.hass) return;
            await this.card.hass.callService('input_boolean', checked ? 'turn_on' : 'turn_off', { entity_id: entityId });
            this.card.isPaused = checked;
            this.card.requestUpdate();
        } catch (err) {
            Logger.warn('UI', '[CronoStar] togglePause error:', err);
        }
    }

    showNotification(message, type = 'success') {
        if (!this.card.hass) {
            console.warn('[CronoStar] Cannot show notification: hass not available');
            return;
        }
        const notificationId = `cronostar_notification_${Date.now()}`;
        try {
            this.card.hass.callService("persistent_notification", "create", {
                title: type === 'success' ? "âœ… CronoStar" : "âŒ CronoStar",
                message: message,
                notification_id: notificationId
            });
            const dismissDelay = type === 'success' ? 5000 : 10000;
            setTimeout(() => {
                if (this.card.hass) {
                    this.card.hass.callService("persistent_notification", "dismiss", {
                        notification_id: notificationId
                    }).catch(() => { });
                }
            }, dismissDelay);
        } catch (err) {
            console.error('[CronoStar] Error showing notification:', err);
        }
    }

    handleCardClick(e) {
        if (this.card.isEditorContext()) {
            return;
        }
        if (this.card.isMenuOpen && !e.target.closest('.menu-content') && !e.target.closest('.menu-button')) {
            this.card.isMenuOpen = false;
            this.card.keyboardHandler.enable();

            const chartContainer = this.card.shadowRoot?.querySelector(".chart-container");
            if (chartContainer && !this.card.isEditorContext()) {
                chartContainer.focus();
            }

            this.card.requestUpdate();
        }
    }
}  


# --- File: cronostar_card/src/core/CardLifecycle.js ---
# Real size: 15740 bytes, Used: 15740 bytes
import { Logger } from '../utils.js';
import { validateConfig, VERSION } from '../config.js';

export class CardLifecycle {
  constructor(card) {
    this.card = card;
    this.hasRegistered = false;

    // When HA changes view/cards, the element may remain connected but become hidden.
    // We use IntersectionObserver to detect re-visibility and force a safe chart rebuild.
    this._visibilityObserver = null;
    this._lastVisible = null;

    // spam guards
    this.loggedProfileSelectEntityMissing = false;
    this.loggedPauseEntityMissing = false;

    if (typeof window !== 'undefined') {
      if (!window.cronostarpausewarned) window.cronostarpausewarned = new Set();
    }
  }

  setConfig(config) {
    Logger.log('CONFIG', 'CronoStar setConfig config received:', config);

    try {
      this.card.config = validateConfig(config);
      Logger.log('CONFIG', 'CronoStar setConfig validated config:', this.card.config);

      this.card.loggingEnabled = this.card.config.logging_enabled !== false;
      Logger.setEnabled(this.card.loggingEnabled);
      Logger.log('LOG', 'CronoStar Logging enabled:', this.card.loggingEnabled);

      this.card.selectedPreset = this.card.config.preset;

      const hourBaseConfig = this.card.config.hour_base;
      if (typeof hourBaseConfig === 'object') {
        this.card.hourBase = hourBaseConfig.value;
        this.card.hourBaseDetermined = hourBaseConfig.determined;
      } else {
        this.card.hourBase = 0;
        this.card.hourBaseDetermined = true;
      }

      // Sparse mode: no interval-based resizing or grid sanitization
    } catch (e) {
      Logger.error('CONFIG', 'CronoStar Error in setConfig:', e);
      this.card.eventHandlers?.showNotification?.(
        this.card.localizationManager?.localize?.(this.card.language, 'error.configerror', e.message) ||
        `Config error: ${e.message}`,
        'error',
      );
    }
  }

  updated(changed) {
    if (changed.has('config')) {
      try {
        if (this.card.chartManager?.isInitialized()) {
          this.card.chartManager.recreateChartOptions();

          const chart = this.card.chartManager.getChart?.();
          if (chart && chart.options?.scales?.y) {
            chart.options.scales.y.min = this.card.config.min_value;
            chart.options.scales.y.max = this.card.config.max_value;
            chart.update();
          }
          this.card.chartManager.updateChartLabels?.();
        }
      } catch (e) {
        Logger.warn('UPDATE', 'CronoStar updated(config) chart refresh failed:', e);
      }
    }
  }

  setHass(hass) {
    if (!hass) {
      Logger.warn('HASS', 'CronoStar Received null hass object');
      return;
    }

    try {
      // Store hass safely for getters and internal usage
      this._hass = hass;
      // IMPORTANT: do NOT assign this.card.hass = hass here, to avoid recursion with CronoStarCard.set hass.
      // Use the passed-in hass for all reads/writes instead.
      const card = this.card;

      if (!card.languageInitialized && hass.language) {
        card.language = hass.language;
        card.languageInitialized = true;
        Logger.log('LANG', 'CronoStar Language initialized to:', card.language);
      }

      if (this.isEditorContext()) return;

      // mark ready when backend service exists
      if (!card.cronostarReady) {
        // Support both apply_now (snake) and legacy applynow (no underscore)
        if (hass.services?.cronostar?.apply_now || hass.services?.cronostar?.applynow) {
          Logger.log('LOAD', 'CronoStar Backend service found, considering it ready.');
          card.cronostarReady = true;
          card.requestUpdate();
        }
      }

      // Register the card with backend as soon as the service is available
      if (!this.hasRegistered && hass.services?.cronostar && (hass.services.cronostar.register_card || hass.services.cronostar.registercard)) {
        this.registerCard(hass).catch((e) => {
          Logger.warn('LOAD', 'CronoStar register_card call failed:', e);
        });
      }

      // pause entity check (spam-free)
      if (card.config?.pause_entity) {
        const pauseId = card.config.pause_entity;
        const pauseStateObj = hass.states[pauseId];
        if (pauseStateObj) {
          card.isPaused = pauseStateObj.state === 'on';
          this.loggedPauseEntityMissing = false;
        } else {
          let alreadyWarnedGlobally = false;
          if (typeof window !== 'undefined' && window.cronostarpausewarned instanceof Set) {
            alreadyWarnedGlobally = window.cronostarpausewarned.has(pauseId);
          }
          if (!this.loggedPauseEntityMissing && !alreadyWarnedGlobally) {
            Logger.warn('HASS', 'CronoStar Pause entity not found:', pauseId);
            if (typeof window !== 'undefined' && window.cronostarpausewarned instanceof Set) {
              window.cronostarpausewarned.add(pauseId);
            }
            this.loggedPauseEntityMissing = true;
          }
        }
      }

      // profiles select entity read
      if (card.config?.profiles_select_entity) {
        const selId = card.config.profiles_select_entity;
        const selObj = hass.states[selId];
        if (selObj) {
          this.loggedProfileSelectEntityMissing = false;
          const newProfile = selObj.state;
          const newOptions = selObj.attributes?.options;

          if (JSON.stringify(card.profileOptions) !== JSON.stringify(newOptions)) {
            card.profileOptions = newOptions;
            Logger.log('HASS', 'CronoStar Profile options updated:', newOptions?.length, 'profiles');
          }

          if (newProfile && newProfile !== card.selectedProfile) {
            card.selectedProfile = newProfile;
            Logger.log('HASS', 'CronoStar Selected profile updated:', newProfile);

            if (!card.hasUnsavedChanges) {
              card.profileManager?.loadProfile?.(newProfile).catch((e) => {
                Logger.warn('LOAD', 'Profile load failed:', e);
              });
            }
          }
        } else if (!this.loggedProfileSelectEntityMissing) {
          Logger.warn('HASS', 'CronoStar Profile select entity not found:', selId);
          this.loggedProfileSelectEntityMissing = true;
        }
      }

      // periodic sync check
      card.cardSync?.updateAutomationSync?.(hass);
      if (!card.syncCheckTimer) {
        card.syncCheckTimer = setInterval(() => {
          if (!card._cardConnected) return;
          card.cardSync?.updateAutomationSync?.(hass);

          // Redraw chart to update current time indicator
          if (card.chartManager?.isInitialized()) {
            card.chartManager.update('none');
          }
        }, 5000);
      }
    } catch (err) {
      Logger.error('HASS', 'CronoStar Error in setHass:', err);
    }
  }

  connectedCallback() {
    try {
      this.card._cardConnected = true;
      Logger.log('LIFECYCLE', 'CronoStar connectedCallback - element added to DOM');

      // If the element is re-attached after being hidden/removed, Chart.js may be stuck with a 0x0 canvas.
      // Use ONLY the canvas size check as requested. Defer until render completes.
      try {
        if (!this.isEditorContext()) {
          const doCanvasCheck = () => {
            try {
              const canvas = this.card.shadowRoot?.getElementById('myChart');
              if (!canvas) {
                // Canvas not yet rendered; retry shortly
                setTimeout(doCanvasCheck, 100);
                return;
              }
              const rect = canvas.getBoundingClientRect();
              const w = Math.round(rect?.width || 0);
              const h = Math.round(rect?.height || 0);
              Logger.log('LIFECYCLE', `CronoStar canvas check: ${w}x${h}`);
              const chartReady = !!(this.card.chartManager?.isInitialized?.() && this.card.chartManager?.getChart?.());
              if (w === 0 || h === 0 || !chartReady) {
                Logger.log('LIFECYCLE', `CronoStar chart not ready (size=${w}x${h}, ready=${chartReady}); rebuilding`);
                this.reinitializeCard();
              } else {
                // Chart exists and canvas has size: trigger a safe update
                try { this.card.chartManager?.update?.('none'); } catch { }
              }
            } catch (err) {
              Logger.warn('LIFECYCLE', 'Canvas check error:', err);
            }
          };

          // After the next render cycle
          try { this.card.updateComplete?.then(() => setTimeout(doCanvasCheck, 0)); } catch { }
          // Also schedule via RAF as a fallback
          requestAnimationFrame(() => setTimeout(doCanvasCheck, 0));
        }
      } catch (e) {
        Logger.warn('LIFECYCLE', 'Canvas size check failed:', e);
      }

      if (this.card.initialized) {
        Logger.log('LIFECYCLE', 'CronoStar Reconnected - scheduling reinitialization');
        requestAnimationFrame(() => this.reinitializeCard());
      }
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in connectedCallback:', e);
    }
  }

  disconnectedCallback() {
    try {
      this.card._cardConnected = false;

      Logger.log('LIFECYCLE', 'CronoStar disconnectedCallback - element removed from DOM');

      // No visibility observers used (canvas size check only)

      if (this.card.syncCheckTimer) {
        clearInterval(this.card.syncCheckTimer);
        this.card.syncCheckTimer = null;
      }
      this.cleanupCard();
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in disconnectedCallback:', e);
    }
  }

  cleanupCard() {
    try {
      Logger.log('LIFECYCLE', 'CronoStar Cleaning up card resources');

      const canvas = this.card.shadowRoot?.getElementById('myChart');
      if (canvas) this.card.pointerHandler?.detachListeners?.(canvas);

      const chartContainer = this.card.shadowRoot?.querySelector('.chart-container');
      if (chartContainer) this.card.keyboardHandler?.detachListeners?.(chartContainer);

      this.card.chartManager?.destroy?.();
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in cleanupCard:', e);
    }
  }

  isEditorContext() {
    try {
      const host = this.card;
      return !!(
        host.closest('hui-card-preview') ||
        host.closest('hui-card-editor') ||
        host.closest('hui-dialog-edit-card') ||
        host.closest('ha-dialog') ||
        host.closest('hui-edit-view') ||
        host.closest('hui-edit-card')
      );
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in isEditorContext:', e);
      return false;
    }
  }

  /**
   * First update hook: initialize chart and handlers once after render
   */
  firstUpdated() {
    try {
      Logger.log('LIFECYCLE', 'CronoStar firstUpdated called');

      const canvas = this.card.shadowRoot?.getElementById('myChart');
      if (canvas && typeof this.card.chartManager?.initChart === 'function') {
        this.card.chartManager.initChart(canvas);
      }

      const container = this.card.shadowRoot?.querySelector('.chart-container');
      if (container) {
        this.card.keyboardHandler?.attachListeners?.(container);
      }
      if (canvas) {
        this.card.pointerHandler?.attachListeners?.(canvas);
      }

      this.card.cardSync?.updateAutomationSync?.(this.card.hass);
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in firstUpdated:', e);
    }
  }

  /**
   * Reinitialize the card safely after reconnection.
   * Recreates chart, reattaches keyboard/pointer listeners and refreshes UI.
   */
  reinitializeCard() {
    try {
      Logger.log('LIFECYCLE', 'CronoStar reinitializeCard starting');

      // Recreate chart
      const canvas = this.card.shadowRoot?.getElementById('myChart');
      if (canvas) {
        try { this.card.chartManager?.destroy?.(); } catch { }
        if (typeof this.card.chartManager?.initChart === 'function') {
          this.card.chartManager.initChart(canvas);
        }
      }

      // Reattach keyboard listeners to chart-container
      const container = this.card.shadowRoot?.querySelector('.chart-container');
      if (container) {
        try { this.card.keyboardHandler?.detachListeners?.(container); } catch { }
        this.card.keyboardHandler?.attachListeners?.(container);
      }

      // Reattach pointer listeners to canvas
      if (canvas) {
        try { this.card.pointerHandler?.detachListeners?.(canvas); } catch { }
        this.card.pointerHandler?.attachListeners?.(canvas);
      }

      // Refresh UI
      this.card.requestUpdate();
      Logger.log('LIFECYCLE', 'CronoStar reinitializeCard done');
    } catch (e) {
      Logger.error('LIFECYCLE', 'CronoStar Error in reinitializeCard:', e);
    }
  }

  /**
   * Register the card with the backend and apply any initialization data returned.
   */
  async registerCard(hass) {
    try {
      const cfg = this.card.config || {};
      const serviceData = {
        card_id: 'cronostar-card',
        version: VERSION,
        preset: cfg.preset || 'thermostat',
        global_prefix: cfg.global_prefix,
        selected_profile: this.card.selectedProfile
      };

      const result = await hass.callWS({
        type: 'call_service',
        domain: 'cronostar',
        service: 'register_card',
        service_data: serviceData,
        return_response: true,
      });

      const response = result?.response ?? result;
      Logger.log('LOAD', 'CronoStar register_card response:', response);

      // NOTE: persisted wizard/card config is now stored in profile meta and not returned here.

      // Initialize schedule from profile data, if provided
      const profileData = response?.profile_data;
      const rawSchedule = profileData?.schedule;
      if (Array.isArray(rawSchedule) && rawSchedule.length > 0) {
        this.card.stateManager.setData(rawSchedule);
        if (this.card.chartManager?.isInitialized()) {
          this.card.chartManager.updateData(rawSchedule);
        }
        this.card.hasUnsavedChanges = false;
        Logger.log('LOAD', 'CronoStar initialized schedule from backend profile_data');
      } else {
        // Fallback for presets that don't return profile_data on registration (e.g., generic_switch)
        try {
          const isSwitch = !!(this.card.config?.is_switch_preset || this.card.selectedPreset?.includes('switch'));
          const hasNoData = !Array.isArray(this.card.stateManager?.scheduleData) || this.card.stateManager.scheduleData.length === 0;
          if (isSwitch && hasNoData && this.card.profileManager?.loadProfile) {
            const candidates = [
              this.card.selectedProfile,
              this.card.profileManager?.lastLoadedProfile,
              'Default',
              'Comfort'
            ].filter(Boolean);
            const name = candidates[0];
            if (name) {
              Logger.log('LOAD', `[CronoStar] Fallback load_profile for switch: '${name}'`);
              try {
                await this.card.profileManager.loadProfile(name);
              } catch (e) {
                Logger.warn('LOAD', `Fallback load_profile failed for '${name}':`, e);
              }
            }
          }
        } catch { }
      }

      // Registration succeeded: mark initial load complete and backend ready to hide overlays
      this.card.initialLoadComplete = true;
      this.card.cronostarReady = true;
      
      // Store entity states for help menu
      if (response?.entity_states) {
        this.card.entityStates = response.entity_states;
      }
      
      this.card.requestUpdate();

      this.hasRegistered = true;
    } catch (e) {
      Logger.warn('LOAD', 'CronoStar register_card failed:', e);
    }
  }
}


# --- File: cronostar_card/src/core/CardRenderer.js ---
# Real size: 10272 bytes, Used: 10272 bytes
import { html } from 'lit';
import { VERSION, CARD_CONFIG_PRESETS, TIMEOUTS } from '../config.js';
import { Logger } from '../utils.js';

export class CardRenderer {
  constructor(card) {
    this.card = card;
  }

  render() {
    const isEditor = this.card.cardLifecycle.isEditorContext();
    const localize = (key, search, replace) => this.card.localizationManager.localize(this.card.language, key, search, replace);
    const title = this.card.config?.title || localize('ui.title');

    const enRaised = this.card.language === 'en';
    const itRaised = this.card.language === 'it';

    // --- Overlay Logic ---
    const isWaitingForData = !isEditor && !this.card.initialLoadComplete;
    const showStartupOverlay = !isEditor && this.card.initialLoadComplete && !this.card.cronostarReady;
    const showMissingEntitiesDetailsOverlay = !isEditor && !this.card.cronostarReady && this.card.missingEntities.length > 0 && this.card.initialLoadComplete;
    const showAnomalousOverlay = !isEditor && this.card.missingEntities.length > 0 && this.card.initialLoadComplete;
    const showAwaitingAutomationOverlay =
      !isEditor &&
      !isWaitingForData &&
      !showStartupOverlay &&
      !showMissingEntitiesDetailsOverlay &&
      this.card.awaitingAutomation &&
      this.card.initialLoadComplete &&
      !this.card.hasUnsavedChanges &&
      !this.card.isDragging &&
      Date.now() >= this.card.overlaySuppressionUntil &&
      (!this.card.lastEditAt || (Date.now() - this.card.lastEditAt) >= TIMEOUTS.editingGraceMs);

    Logger.log('UI_RENDER', `[CronoStar] Rendering Overlays Check:
         - isWaitingForData: ${isWaitingForData} (initialLoadComplete: ${this.card.initialLoadComplete})
         - showStartupOverlay: ${showStartupOverlay} (initialLoadComplete: ${this.card.initialLoadComplete}, cronostarReady: ${this.card.cronostarReady})
         - showMissingEntitiesDetailsOverlay: ${showMissingEntitiesDetailsOverlay}
         - showAwaitingAutomationOverlay: ${showAwaitingAutomationOverlay} (awaitingAutomation: ${this.card.awaitingAutomation})
        `);

    if (showStartupOverlay && !this.card._startupOverlayState) {
      Logger.log('UI', `[CronoStar] STARTUP_OVERLAY (${this.card.selectedPreset}): State changed to ACTIVE (waiting for backend).`);
    } else if (!showStartupOverlay && this.card._startupOverlayState) {
      Logger.log('UI', `[CronoStar] STARTUP_OVERLAY (${this.card.selectedPreset}): State changed to INACTIVE (backend ready).`);
    }
    this.card._startupOverlayState = showStartupOverlay;

    return html`
      <ha-card @click=${(e) => this.card.eventHandlers.handleCardClick(e)}>
        <div class="card-header">
          <div class="name">${title} (v${VERSION})</div>
          <button class="menu-button" @click=${(e) => this.card.eventHandlers.toggleMenu(e)}>
            <svg viewBox="0 0 24 24" width="24" height="24">
              <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path>
            </svg>
          </button>
        </div>

        ${this.card.isMenuOpen ? html`
          <div class="menu-content" @click=${(e) => e.stopPropagation()}>
            <mwc-list-item @click=${() => this.card.eventHandlers.handleApplyNow()}>${localize('menu.apply_now')}</mwc-list-item>
            <mwc-list-item @click=${() => this.card.eventHandlers.handleSelectAll()}>${localize('menu.select_all')}</mwc-list-item>
            <mwc-list-item @click=${() => this.card.eventHandlers.handleAlignLeft()}>${localize('menu.align_left', 'Align Left')}</mwc-list-item>
            <mwc-list-item @click=${() => this.card.eventHandlers.handleAlignRight()}>${localize('menu.align_right', 'Align Right')}</mwc-list-item>
            <!-- Use card wrappers to avoid runtime "not a function" if bundler caches an old eventHandlers -->
            <mwc-list-item @click=${() => this.card.handleAddProfile()}>${localize('menu.add_profile')}</mwc-list-item>
            <mwc-list-item .disabled=${!this.card.selectedProfile} @click=${() => this.card.handleDeleteProfile()}>${localize('menu.delete_profile')}</mwc-list-item>
            <mwc-list-item @click=${() => this.card.eventHandlers.handleHelp()}>${localize('menu.help')}</mwc-list-item>
            <div class="menu-item-with-switch" @click=${(e) => e.stopPropagation()}>
              <span>${localize('menu.enable_logging')}</span>
              <ha-switch
                .checked=${this.card.loggingEnabled}
                @change=${(e) => this.card.eventHandlers.handleLoggingToggle(e)}
              ></ha-switch>
            </div>
            <div class="menu-item-with-select">
              <ha-select
                label="${localize('menu.select_preset')}"
                .value=${this.card.selectedPreset}
                @selected=${(e) => this.card.eventHandlers.handlePresetChange(e)}
                @opened=${() => {
          this.card.keyboardHandler.disable();
          this.card.suppressClickUntil = Date.now() + TIMEOUTS.menuSuppression;
        }}
                @closed=${() => {
          this.card.keyboardHandler.enable();
          this.card.suppressClickUntil = Date.now() + TIMEOUTS.clickSuppression;
        }}
              >
                ${Object.keys(CARD_CONFIG_PRESETS).map(
          (presetKey) => html`<mwc-list-item .value=${presetKey}>${localize(`preset.${presetKey}`)}</mwc-list-item>`
        )}
              </ha-select>
            </div>
            <div class="language-menu">
              <mwc-list-item>${localize('menu.language')}</mwc-list-item>
              <mwc-button
                ?raised=${enRaised}
                style="${enRaised ? 'border: 2px solid var(--primary-color, #03a9f4);' : ''}"
                @click=${() => this.card.eventHandlers.handleLanguageSelect('en')}
              >EN</mwc-button>
              <mwc-button
                ?raised=${itRaised}
                style="${itRaised ? 'border: 2px solid var(--primary-color, #03a9f4);' : ''}"
                @click=${() => this.card.eventHandlers.handleLanguageSelect('it')}
              >IT</mwc-button>
            </div>
          </div>
        ` : ''}

        <div class="card-content">
          <div class="chart-container" tabindex="${isEditor ? '-1' : '0'}">
            ${isWaitingForData
        ? html`<div class="loading-overlay"><div>${localize('ui.loading')}</div></div>`
        : (!isEditor && this.card.initialLoadComplete && this.card.missingEntities.length > 0)
          ? html`<div class="loading-overlay anomalous-operation-overlay">
                        <div>
                            <div>${localize('ui.create_missing_entities_message')}</div>
                        </div>
                        </div>`
          : showStartupOverlay
            ? html`<div class="loading-overlay startup-overlay">
                            <div>
                            <div>${localize('ui.waiting_ha_start')}</div>
                            <div>${localize('ui.waiting_profile_restore')}</div>
                            </div>
                        </div>`
            : ''}

            ${showAwaitingAutomationOverlay && !showAnomalousOverlay
        ? html`<div class="loading-overlay awaiting-automation-overlay" style="pointer-events:none;">
                  <div>${this.card.cardSync.getAwaitingAutomationText()}</div>
                  ${this.card.outOfSyncDetails ? html`<div class="details">${this.card.outOfSyncDetails}</div>` : ''}
                </div>`
        : ''}

            <canvas id="myChart"></canvas>

            ${showAnomalousOverlay
        ? html`<div class="anomalous-watermark">${localize('ui.anomalous_operation_watermark')}</div>`
        : showStartupOverlay
          ? html`<div class="startup-watermark">${localize('ui.startup_watermark')}</div>`
          : showAwaitingAutomationOverlay
            ? html`<div class="anomalous-watermark" style="pointer-events:none;">Automation pending</div>`
            : ''}

            <div id="selection-rect" class="selection-rect"></div>
            <div id="drag-value-display" class="drag-value-display"></div>
            <div id="hover-value-display" class="drag-value-display" style="display:none"></div>
          </div>

          <div class="controls">
            ${this.card.config?.pause_entity ? html`
              <div class="control-group">
                <ha-switch
                  .checked=${this.card.isPaused}
                  @change=${(e) => this.card.eventHandlers.togglePause(e)}
                ></ha-switch>
                <span>${localize('ui.pause')}</span>
              </div>
            ` : ''}

            ${this.card.config?.profiles_select_entity ? html`
              <div class="control-group">
                <ha-select
                  label="${localize('ui.profile')}"
                  .value=${this.card.selectedProfile}
                  @selected=${(e) => this.card.profileManager.handleProfileSelection(e)}
                  @opened=${() => {
          this.card.keyboardHandler.disable();
          this.card.suppressClickUntil = Date.now() + 1000;
        }}
                  @closed=${() => {
          this.card.keyboardHandler.enable();
          const container = this.card.shadowRoot.querySelector(".chart-container");
          if (container && !isEditor) {
            container.focus();
          }
          this.card.suppressClickUntil = Date.now() + 500;
        }}
                >
                  ${this.card.profileOptions && this.card.profileOptions.length > 0
          ? this.card.profileOptions.map(
            (option) => html`<mwc-list-item .value=${option}>${option}</mwc-list-item>`
          )
          : html`<mwc-list-item disabled>No profiles found</mwc-list-item>`
        }
                </ha-select>
              </div>
            ` : ''}

            ${this.card.hasUnsavedChanges ? html`
              <div class="control-group">
                <span class="unsaved-indicator">â— ${localize('ui.unsaved_changes')}</span>
                <mwc-button outlined @click=${() => this.card.profileManager.resetChanges()}>
                  ${localize('ui.reset')}
                </mwc-button>
              </div>
            ` : ''}
          </div>
        </div>
      </ha-card>
    `;
  }
}  


# --- File: cronostar_card/src/core/CardSync.js ---
# Real size: 7251 bytes, Used: 7251 bytes
import { TIMEOUTS } from '../config.js';
import { Logger } from '../utils.js';
import { getEffectivePrefix } from '../utils/prefix_utils.js';

export class CardSync {
    constructor(card) {
        this.card = card;
    }

    computeNextHourBoundaryPlus(msAfter = 5000) {
        const d = new Date();
        d.setSeconds(0, 0);
        d.setMinutes(0);
        d.setHours(d.getHours() + 1);
        return d.getTime() + (msAfter || 0);
    }

    scheduleAutomationOverlaySuppression(ms = TIMEOUTS.automationSuppression) {
        const untilNextHour = this.computeNextHourBoundaryPlus(5000);
        const simpleCooldown = Date.now() + (ms || 7000);
        this.card.overlaySuppressionUntil = Math.max(untilNextHour, simpleCooldown);
        this.card.lastEditAt = Date.now();
        this.card.awaitingAutomation = false;
        this.card.outOfSyncDetails = "";
        Logger.log('SYNC', `[CronoStar] Suppressing automation overlay until ${new Date(this.card.overlaySuppressionUntil).toLocaleTimeString()} (cooldown=${ms || 7000}ms)`);
        this.card.requestUpdate();
    }

    getAwaitingAutomationText() {
        const hour = new Date().getHours().toString().padStart(2, '0');
        if (this.card.language === 'it') {
            return `In attesa che l'automazione applichi i valori del profilo (ora ${hour}:00).`;
        }
        return `Waiting for automation to apply the scheduled values (hour ${hour}:00).`;
    }

    getScheduledValue(hass) {
        try {
            // Get value from internal memory
            const hourIdx = this.card.stateManager?.getCurrentIndex() || 0;
            const data = this.card.stateManager?.getData();
            if (!data || data.length === 0) return null;
            
            // Handle different intervals
            // If we have more than 24 points, we need to pick the correct index
            // getCurrentIndex handles this logic (time -> index)
            const val = data[hourIdx];
            return (val !== null && val !== undefined) ? Number(val) : null;
        } catch {
            return null;
        }
    }

    getTargetEntityAppliedValue(hass) {
        try {
            const entityId = this.card.config?.target_entity;
            if (!entityId) return null;
            const st = hass.states[entityId];
            if (!st) return null;
            const domain = entityId.split('.')[0];
            if (domain === 'climate') {
                const attrs = st.attributes || {};
                if (attrs.temperature !== undefined && attrs.temperature !== null) {
                    const v = Number(attrs.temperature);
                    return Number.isFinite(v) ? v : null;
                }
                if (attrs.target_temperature !== undefined && attrs.target_temperature !== null) {
                    const v = Number(attrs.target_temperature);
                    return Number.isFinite(v) ? v : null;
                }
                if (attrs.target_temp_low !== undefined && attrs.target_temp_low !== null) {
                    const v = Number(attrs.target_temp_low);
                    return Number.isFinite(v) ? v : null;
                }
                return null;
            } else if (domain === 'number') {
                const v = Number(st.state);
                return Number.isFinite(v) ? v : null;
            } else if (domain === 'switch') {
                return st.state === 'on' ? 1 : 0;
            }
            return null;
        } catch {
            return null;
        }
    }

    updateAutomationSync(hass) {
        if (this.card.isEditorContext()) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }
        if (!hass || !this.card.config?.target_entity) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }
        // Removed cronostarReady check related to entities
        
        if (this.card.isPaused) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }
        if (this.card.hasUnsavedChanges || this.card.isDragging) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }
        if (Date.now() < this.card.overlaySuppressionUntil) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }
        if (this.card.lastEditAt && (Date.now() - this.card.lastEditAt) < TIMEOUTS.editingGraceMs) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }

        // Only check for sync if the user has actually edited/interacted with the card in this session
        if (!this.card.lastEditAt) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }

        const scheduled = this.getScheduledValue(hass);
        const applied = this.getTargetEntityAppliedValue(hass);

        if (scheduled === null || applied === null) {
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
            return;
        }

        const isSwitchPreset = this.card.config?.is_switch_preset === true;
        const tolerance = isSwitchPreset ? 0.5 : Math.max(0.05, (this.card.config?.step_value || 0.5) / 2);
        const wasAwaiting = this.card.awaitingAutomation;
        const diff = Math.abs(Number(scheduled) - Number(applied));
        const mismatchNow = diff > tolerance;

        if (!mismatchNow) {
            this.card.mismatchSince = 0;
            this.card.awaitingAutomation = false;
            this.card.outOfSyncDetails = "";
        } else {
            if (!this.card.mismatchSince) {
                this.card.mismatchSince = Date.now();
                this.card.awaitingAutomation = false;
                this.card.outOfSyncDetails = "";
            } else {
                const persisted = Date.now() - this.card.mismatchSince;
                this.card.awaitingAutomation = persisted >= TIMEOUTS.mismatchPersistenceMs;

                if (this.card.awaitingAutomation) {
                    const hourIdx = this.card.stateManager?.getCurrentIndex() || 0;
                    const hourLabel = this.card.stateManager?.getPointLabel(hourIdx) || 'Now';
                    const details = this.card.language === 'it'
                        ? `Programma ${hourLabel}: ${scheduled} â‰  EntitÃ  (${this.card.config.target_entity}) ${applied}`
                        : `Schedule ${hourLabel}: ${scheduled} â‰  Entity (${this.card.config.target_entity}) ${applied}`;
                    
                    this.card.outOfSyncDetails = details;

                    if (!wasAwaiting) {
                        Logger.log('SYNC', `[CronoStar] Awaiting automation started (persisted ${persisted}ms): scheduled=${scheduled}, applied=${applied}`);
                    }
                } else {
                    this.card.outOfSyncDetails = "";
                }
            }
        }

        this.card.requestUpdate();
    }
}


# --- File: cronostar_card/src/core/CronoStar.js ---
# Real size: 6473 bytes, Used: 6473 bytes
// core/CronoStar.js - FIXED VERSION
import { LitElement } from 'lit';
import { cardStyles } from '../styles.js';
import { VERSION } from '../config.js';

import { StateManager } from '../managers/state_manager.js';
import { ProfileManager } from '../managers/profile_manager.js';
import { SelectionManager } from '../managers/selection_manager.js';
import { ChartManager } from '../managers/chart_manager.js';
import { KeyboardHandler } from '../handlers/keyboard_handler.js';
import { PointerHandler } from '../handlers/pointer_handler.js';
import { Logger } from '../utils.js';
import { LocalizationManager } from '../managers/localization_manager.js';

import { CardLifecycle } from './CardLifecycle.js';
import { CardRenderer } from './CardRenderer.js';
import { CardEventHandlers } from './CardEventHandlers.js';
import { CardSync } from './CardSync.js';

import '../editor/CronoStarEditor.js';

export class CronoStarCard extends LitElement {

  static get properties() {
    return {
      hass: { type: Object },
      config: { type: Object },
      isPaused: { type: Boolean },
      selectedProfile: { type: String },
      profileOptions: { type: Array },
      hasUnsavedChanges: { type: Boolean },
      isMenuOpen: { type: Boolean },
      language: { type: String },
      loggingEnabled: { type: Boolean },
      selectedPreset: { type: String },
      missingEntities: { type: Array },
      initialLoadComplete: { type: Boolean },
      cronostarReady: { type: Boolean },
      awaitingAutomation: { type: Boolean },
      outOfSyncDetails: { type: String },
      isDragging: { type: Boolean },
      selectedPoints: { type: Array },
    };
  }

  static get styles() {
    return cardStyles;
  }

  static getCardType() {
    return 'custom:cronostar-card';
  }

  static getConfigElement() {
    return document.createElement('cronostar-card-editor');
  }

  static getStubConfig() {
    return {
      type: 'custom:cronostar-card',
      preset: 'thermostat',
      hour_base: 'auto',
      logging_enabled: true,
    };
  }

  getCardSize() {
    return 6;
  }

  constructor() {
    super();
    this.config = null;
    this.hourBase = 0;
    this.hourBaseDetermined = false;
    this.isPaused = false;
    this.selectedProfile = '';
    this.profileOptions = [];
    this.hasUnsavedChanges = false;
    this.suppressClickUntil = 0;
    this.isMenuOpen = false;
    this.language = 'en';
    this.loggingEnabled = true;
    this.selectedPreset = 'thermostat';
    this.missingEntities = [];
    this.initialLoadComplete = false;
    this.wasLongPress = false;
    this.cronostarReady = false;
    this.isDragging = false;
    this.awaitingAutomation = false;
    this.outOfSyncDetails = '';
    this._initialized = false;
    this._languageInitialized = false;
    this._cardConnected = false;
    this._unsubProfilesLoaded = null;
    this._readyCheckTimer = null;
    this._syncCheckTimer = null;
    this._lastReadyFlagNotMetLogAt = 0;
    this._lastMissingCount = -1;
    this._readyCheckIntervalMs = 5000;
    this._readyCheckTicks = 0;
    this._readyCheckMaxMs = 60000;
    this.overlaySuppressionUntil = 0;
    this.lastEditAt = 0;
    this.mismatchSince = 0;
    this._startupOverlayState = false;
    this.selectedPoints = [];

    try {
        this.localizationManager = new LocalizationManager(this);
        this.stateManager = new StateManager(this);
        this.profileManager = new ProfileManager(this);        
        this.selectionManager = new SelectionManager(this);        
        this.chartManager = new ChartManager(this);
        this.keyboardHandler = new KeyboardHandler(this);
        this.pointerHandler = new PointerHandler(this);

        this.cardLifecycle = new CardLifecycle(this);
        Logger.log('INIT', `[CronoStar] CardLifecycle initialized successfully (v${VERSION})`);        
        this.cardRenderer = new CardRenderer(this);
        this.eventHandlers = new CardEventHandlers(this);
        this.cardSync = new CardSync(this);

        Logger.setEnabled(true);
        Logger.log('INIT', `[CronoStar] Card constructor completed (v${VERSION})`);
    } catch (e) {
        Logger.error('INIT', '[CronoStar] Error initializing Managers:', e);
        if (!this.cardLifecycle) this.cardLifecycle = new CardLifecycle(this); 
    }
  }

  setConfig(config) {
    try {
      // Semantic check to avoid redundant updates
      if (this.config) {
        const cleanOld = { ...this.config };
        const cleanNew = { ...config };
        if (JSON.stringify(cleanOld) === JSON.stringify(cleanNew)) {
          return;
        }
      }

      if (!this.cardLifecycle) {
        Logger.error('CONFIG', '[CronoStar] setConfig called but cardLifecycle is not initialized!');
        return;
      }
      this.cardLifecycle.setConfig(config);
    } catch (e) {
      Logger.error('CONFIG', '[CronoStar] Error in CronoStarCard.setConfig:', e);
      this.config = config;
      if (this.eventHandlers) {
        this.eventHandlers.showNotification(
          this.localizationManager ? this.localizationManager.localize(this.language, 'error.config_error') : 'Config Error' + `: ${e.message}`,
          'error',
        );
      }
    }
  }

  updated(changed) {
    super.updated(changed);
    if (this.cardLifecycle) {
      this.cardLifecycle.updated(changed);
    }
  }

  // Ã¢â€ " FIX: Setter now only delegates to CardLifecycle
  set hass(hass) {
    if (this.cardLifecycle) {
      this.cardLifecycle.setHass(hass);
    }
  }

  // Ã¢â€ " FIX: Getter reads from CardLifecycle's internal storage
  get hass() {
    return this.cardLifecycle?._hass;
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.cardLifecycle) {
      this.cardLifecycle.connectedCallback();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.cardLifecycle) {
      this.cardLifecycle.disconnectedCallback();
    }
  }

  firstUpdated() {
    super.firstUpdated();
    if (this.cardLifecycle) {
      this.cardLifecycle.firstUpdated();
    }
  }

  render() {
    return this.cardRenderer ? this.cardRenderer.render() : null;
  }

  isEditorContext() {
    return this.cardLifecycle?.isEditorContext() ?? false;
  }

  // Wrappers for menu handlers
  handleAddProfile() {
    try {
      return this.eventHandlers?.handleAddProfile?.();
    } catch {}
  }

  handleDeleteProfile() {
    try {
      return this.eventHandlers?.handleDeleteProfile?.();
    } catch {}
  }
}


# --- File: cronostar_card/src/core/cronostar_define_guard.js ---
# Real size: 5063 bytes, Used: 5063 bytes
// Guard ultra-aggressivo per HA 2025.12
(function() {
  'use strict';

  const CARD_NAME = 'cronostar-card';
  const EDITOR_NAME = 'cronostar-card-editor';

  // Intercetta costruttore CustomElementRegistry
  try {
    const OriginalRegistry = window.CustomElementRegistry;
    
    if (OriginalRegistry) {
      window.CustomElementRegistry = function(...args) {
        console.log('CRONOSTAR: Nuovo CustomElementRegistry creato!');
        const instance = new OriginalRegistry(...args);
        
        // Patcha immediatamente questa istanza
        patchRegistryInstance(instance, 'new-instance');
        
        // Auto-registra i nostri elementi dopo un breve delay
        setTimeout(() => {
          if (window.CronoStarCard && window.CronoStarEditor) {
            try {
              if (!instance.get(CARD_NAME)) {
                instance.define(CARD_NAME, window.CronoStarCard);
                console.log('CRONOSTAR: Auto-registrato card in nuovo registry');
              }
              if (!instance.get(EDITOR_NAME)) {
                instance.define(EDITOR_NAME, window.CronoStarEditor);
                console.log('CRONOSTAR: Auto-registrato editor in nuovo registry');
              }
            } catch (e) {
              console.warn('CRONOSTAR: Errore auto-registrazione:', e);
            }
          }
        }, 0);
        
        return instance;
      };
      
      // Mantieni proprietÃ  originali
      Object.setPrototypeOf(window.CustomElementRegistry, OriginalRegistry);
      Object.setPrototypeOf(window.CustomElementRegistry.prototype, OriginalRegistry.prototype);
      
      console.log('CRONOSTAR: CustomElementRegistry constructor intercepted');
    }
  } catch (e) {
    console.warn('CRONOSTAR: Impossibile intercettare CustomElementRegistry:', e);
  }

  function patchRegistryInstance(registry, name) {
    if (!registry || registry.__cronostar_patched__) return;

    const originalGet = registry.get;
    const originalDefine = registry.define;

    // Get con fallback multipli
    registry.get = function(elementName) {
      try {
        const result = originalGet.call(this, elementName);
        if (result) return result;
      } catch (e) {
        // Non trovato
      }

      // Fallback ai nostri elementi
      if (elementName === CARD_NAME && window.CronoStarCard) {
        return window.CronoStarCard;
      }
      if (elementName === EDITOR_NAME && window.CronoStarEditor) {
        return window.CronoStarEditor;
      }

      // Fallback a registry globale
      if (window.customElements && window.customElements !== this) {
        try {
          return window.customElements.get(elementName);
        } catch (e) {
          // Ignore
        }
      }

      return undefined;
    };

    // Define con auto-registro
    registry.define = function(elementName, constructor, options) {
      try {
        const existing = this.get(elementName);
        if (existing === constructor) {
          return; // GiÃ  registrato con stesso constructor
        }
        if (existing) {
          console.warn(`CRONOSTAR: ${elementName} giÃ  definito in ${name}`);
          return;
        }

        return originalDefine.call(this, elementName, constructor, options);
      } catch (e) {
        const err = String(e);
        if (err.includes('already been used') || err.includes('already defined')) {
          return; // Ignora errori duplicati
        }
        throw e;
      }
    };

    Object.defineProperty(registry, '__cronostar_patched__', {
      value: true,
      configurable: false
    });

    console.log(`CRONOSTAR: Registry patchato: ${name}`);
  }

  // Patcha registry globale
  if (window.customElements) {
    patchRegistryInstance(window.customElements, 'global');
  }

  // Patcha prototype
  if (window.CustomElementRegistry?.prototype) {
    patchRegistryInstance(window.CustomElementRegistry.prototype, 'prototype');
  }

  // Scansione continua per nuovi registry
  let scanCount = 0;
  const scanInterval = setInterval(() => {
    // Scansiona proprietÃ  globali
    for (const prop of Object.getOwnPropertyNames(window)) {
      try {
        const obj = window[prop];
        if (obj && typeof obj === 'object' && 
            typeof obj.define === 'function' && 
            typeof obj.get === 'function' &&
            !obj.__cronostar_patched__) {
          patchRegistryInstance(obj, `global.${prop}`);
        }
      } catch (e) {
        // Skip
      }
    }

    // Scansiona shadow roots
    document.querySelectorAll('*').forEach((el) => {
      try {
        if (el.shadowRoot?.customElements && !el.shadowRoot.customElements.__cronostar_patched__) {
          patchRegistryInstance(el.shadowRoot.customElements, `shadow-${el.tagName}`);
        }
      } catch (e) {
        // Skip
      }
    });

    scanCount++;
    if (scanCount >= 30) {
      clearInterval(scanInterval);
      console.log('CRONOSTAR: Scansione registry completata');
    }
  }, 500);

  console.log('CRONOSTAR: Guard ultra-aggressivo inizializzato');
})();


# --- File: cronostar_card/src/editor/CronoStarEditor.js ---
# Real size: 26483 bytes, Used: 26483 bytes
// editor/CronoStarEditor.js
import { LitElement, html, css } from 'lit';
import { CARD_CONFIG_PRESETS, DEFAULT_CONFIG, COLORS, validateConfig } from '../config.js';
import { normalizePrefix, getEffectivePrefix, isValidPrefix } from '../utils/prefix_utils.js';
import { buildHelpersFilename, buildAutomationFilename } from '../utils/filename_utils.js';
import { EditorI18n } from './EditorI18n.js';
import { EditorWizard } from './EditorWizard.js';
import { Step0Dashboard } from './steps/Step0Dashboard.js';
import { Step1Preset } from './steps/Step1Preset.js';
import { Step2Entities } from './steps/Step2Entities.js';
import { Step3Options } from './steps/Step3Options.js';
import { Step4Automation } from './steps/Step4Automation.js';
import { Step5Summary } from './steps/Step5Summary.js';
import {
  copyToClipboard,
  downloadFile,
  handleCreateHelpersYaml,
  handleCreateAutomationYaml,
  handleCreateAndReloadAutomation,
  runDeepChecks,
  handleInitializeData,
  handleSaveAll
} from './services/service_handlers.js';
import { buildAutomationYaml, buildInputNumbersYaml } from './yaml/yaml_generators.js';

export class CronoStarEditor extends LitElement {
  static get properties() {
    return {
      hass: { type: Object },
      _config: { type: Object },
      _step: { type: Number },
      _selectedPreset: { type: String },
      _automationYaml: { type: String },
      _showAutomationPreview: { type: Boolean },
      _helpersYaml: { type: String },
      _showHelpersPreview: { type: Boolean },
      _language: { type: String },
      _quickCheck: { type: Object },
      _deepReport: { type: Object },
      _deepCheckRanForStep1: { type: Boolean },
      _deepCheckRanForStep5: { type: Boolean },
      _deepCheckSubscribed: { type: Boolean },
      _calculatedHelpersFilename: { type: String },
      _calculatedAutomationFilename: { type: String },
      _creatingAutomation: { type: Boolean },
      _deepCheckInProgress: { type: Boolean },
      _showStepError: { type: Boolean },
      // NUOVO: ProprietÃ  reattive per Step 0 Dashboard
      _dashboardProfilesData: { type: Object },
      _dashboardLoading: { type: Boolean },
      _dashboardSelectedPreset: { type: String },
      _dashboardSelectedProfile: { type: String },
      _dashboardShowDetailModal: { type: Boolean },
      _dashboardDetailData: { type: Object }
    };
  }

  static get styles() {
    return css`
      .editor-container { 
        padding: 24px;
        background: linear-gradient(135deg, 
          #1a1f2e 0%,
          #252b3d 100%
        );
        border-radius: 12px;
        color: #e8eaf0;
      }
      
      .wizard-steps { 
        display: flex; 
        justify-content: space-between; 
        margin-bottom: 32px;
        padding: 20px;
        background: linear-gradient(135deg, 
          rgba(42, 48, 66, 0.95) 0%,
          rgba(32, 38, 56, 0.95) 100%
        );
        backdrop-filter: blur(10px);
        border-radius: 16px;
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
      
      .step-badge {
        width: 52px; 
        height: 52px; 
        border-radius: 50%;
        background: linear-gradient(145deg, 
          #3a4158,
          #2a3042
        );
        color: #a0a8c0; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        font-weight: 700;
        font-size: 1.3rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 
          0 8px 20px rgba(0, 0, 0, 0.5),
          inset 0 -2px 4px rgba(0, 0, 0, 0.4),
          inset 0 2px 4px rgba(255, 255, 255, 0.1);
        position: relative;
        border: 2px solid rgba(255, 255, 255, 0.05);
      }
      
      .step-badge::before {
        content: '';
        position: absolute;
        top: 3px;
        left: 3px;
        right: 3px;
        height: 45%;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent);
        border-radius: 50%;
        pointer-events: none;
      }
      
      .step-badge:hover {
        transform: translateY(-3px) scale(1.08);
        box-shadow: 
          0 12px 28px rgba(0, 0, 0, 0.6),
          inset 0 -2px 4px rgba(0, 0, 0, 0.4),
          inset 0 2px 4px rgba(255, 255, 255, 0.15);
        color: #cbd3e8;
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .step-badge:active {
        transform: translateY(0px) scale(0.96);
        box-shadow: 
          0 4px 12px rgba(0, 0, 0, 0.5),
          inset 0 2px 6px rgba(0, 0, 0, 0.5);
      }
      
      .step-badge.active { 
        background: linear-gradient(145deg, 
          #0ea5e9,
          #0284c7
        );
        color: #ffffff;
        box-shadow: 
          0 12px 32px rgba(14, 165, 233, 0.5),
          0 0 40px rgba(14, 165, 233, 0.3),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.2);
        animation: pulse 2.5s ease-in-out infinite;
      }
      
      @keyframes pulse {
        0%, 100% { 
          box-shadow: 
            0 12px 32px rgba(14, 165, 233, 0.5),
            0 0 40px rgba(14, 165, 233, 0.3),
            inset 0 -2px 4px rgba(0, 0, 0, 0.3),
            inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }
        50% { 
          box-shadow: 
            0 12px 40px rgba(14, 165, 233, 0.7),
            0 0 60px rgba(14, 165, 233, 0.5),
            inset 0 -2px 4px rgba(0, 0, 0, 0.3),
            inset 0 2px 4px rgba(255, 255, 255, 0.4);
        }
      }
      
      .step-content { 
        min-height: 300px;
        padding: 28px;
        background: linear-gradient(135deg, 
          rgba(42, 48, 66, 0.9) 0%,
          rgba(32, 38, 56, 0.9) 100%
        );
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      
      .wizard-actions { 
        display: flex; 
        justify-content: space-between; 
        margin-top: 24px;
        padding: 20px;
        background: linear-gradient(135deg, 
          rgba(42, 48, 66, 0.95) 0%,
          rgba(32, 38, 56, 0.95) 100%
        );
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      
      mwc-button {
        --mdc-theme-primary: #0ea5e9;
        position: relative;
        overflow: visible;
      }
      
      mwc-button[raised] {
        background: linear-gradient(145deg, 
          #0ea5e9,
          #0284c7
        ) !important;
        box-shadow: 
          0 8px 20px rgba(14, 165, 233, 0.4),
          0 0 30px rgba(14, 165, 233, 0.2),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(255, 255, 255, 0.2) !important;
        border: 2px solid rgba(255, 255, 255, 0.1) !important;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        color: #ffffff !important;
      }
      
      mwc-button[raised]::before {
        content: '';
        position: absolute;
        top: 2px;
        left: 8px;
        right: 8px;
        height: 40%;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.25), transparent);
        border-radius: 4px;
        pointer-events: none;
      }
      
      mwc-button[raised]:hover {
        transform: translateY(-3px);
        box-shadow: 
          0 12px 28px rgba(14, 165, 233, 0.5),
          0 0 40px rgba(14, 165, 233, 0.3),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(255, 255, 255, 0.3) !important;
        border-color: rgba(255, 255, 255, 0.2) !important;
      }
      
      mwc-button[raised]:active {
        transform: translateY(0px);
        box-shadow: 
          0 4px 12px rgba(14, 165, 233, 0.4),
          inset 0 2px 6px rgba(0, 0, 0, 0.4) !important;
      }
      
      mwc-button[outlined] {
        border: 2px solid #0ea5e9 !important;
        background: linear-gradient(145deg, 
          rgba(48, 55, 75, 0.95),
          rgba(38, 44, 62, 0.95)
        ) !important;
        color: #60d5ff !important;
        box-shadow: 
          0 6px 16px rgba(0, 0, 0, 0.3),
          inset 0 1px 2px rgba(255, 255, 255, 0.1) !important;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
      }
      
      mwc-button[outlined]:hover {
        transform: translateY(-3px);
        box-shadow: 
          0 8px 20px rgba(0, 0, 0, 0.4),
          0 0 30px rgba(14, 165, 233, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.15) !important;
        background: linear-gradient(145deg, 
          rgba(58, 65, 85, 0.95),
          rgba(48, 54, 72, 0.95)
        ) !important;
        border-color: #60d5ff !important;
      }
      
      mwc-button[outlined]:active {
        transform: translateY(0px);
        box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
      }
      
      .field-group { 
        margin-bottom: 24px;
        padding: 20px;
        background: linear-gradient(145deg, 
          rgba(48, 55, 75, 0.7),
          rgba(38, 44, 62, 0.7)
        );
        border-radius: 12px;
        box-shadow: 
          0 6px 20px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.08);
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }
      
      .field-group:hover {
        box-shadow: 
          0 8px 24px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .field-label { 
        display: block; 
        font-weight: 600; 
        margin-bottom: 10px;
        color: #ffffff;
        font-size: 1.05rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      
      .field-description { 
        font-size: 0.9em; 
        color: #a0a8c0; 
        margin-bottom: 14px;
        line-height: 1.6;
      }
      
      .hint { 
        font-size: 0.85em; 
        color: #8891a8; 
        margin-top: 10px;
        padding: 10px 14px;
        background: rgba(14, 165, 233, 0.08);
        border-radius: 8px;
        border-left: 3px solid #0ea5e9;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
      }
      
      .success-box { 
        background: linear-gradient(145deg,
          rgba(34, 197, 94, 0.15),
          rgba(22, 163, 74, 0.12)
        );
        padding: 18px; 
        border-radius: 12px; 
        border-left: 4px solid #22c55e;
        box-shadow: 
          0 6px 20px rgba(34, 197, 94, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        margin: 20px 0;
        color: #bbf7d0;
      }
      
      .info-box { 
        background: linear-gradient(145deg,
          rgba(14, 165, 233, 0.15),
          rgba(2, 132, 199, 0.12)
        );
        padding: 18px; 
        border-radius: 12px; 
        border-left: 4px solid #0ea5e9;
        box-shadow: 
          0 6px 20px rgba(14, 165, 233, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        margin: 20px 0;
        color: #bae6fd;
      }
      
      .warning-box {
        background: linear-gradient(145deg,
          rgba(251, 146, 60, 0.15),
          rgba(249, 115, 22, 0.12)
        );
        padding: 18px;
        border-radius: 12px;
        border-left: 4px solid #fb923c;
        box-shadow: 
          0 6px 20px rgba(251, 146, 60, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        margin: 20px 0;
        color: #fed7aa;
      }
      
      ha-textfield, ha-select {
        width: 100%;
        --mdc-theme-primary: #0ea5e9;
        --mdc-text-field-fill-color: rgba(38, 44, 62, 0.6);
        --mdc-text-field-ink-color: #e8eaf0;
        --mdc-text-field-label-ink-color: #a0a8c0;
        --mdc-text-field-outlined-idle-border-color: rgba(255, 255, 255, 0.12);
        --mdc-text-field-outlined-hover-border-color: rgba(14, 165, 233, 0.5);
      }
      
      ha-switch {
        --mdc-theme-secondary: #0ea5e9;
        --switch-checked-button-color: #0ea5e9;
        --switch-checked-track-color: rgba(14, 165, 233, 0.5);
      }
      
      .action-buttons {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        margin-top: 14px;
      }
      
      textarea { 
        width: 100%; 
        font-family: 'Courier New', monospace; 
        min-height: 200px;
        padding: 14px;
        border: 2px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        background: rgba(28, 33, 48, 0.8);
        color: #e8eaf0;
        transition: all 0.3s ease;
        box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      
      textarea:focus {
        outline: none;
        border-color: #0ea5e9;
        box-shadow: 
          0 0 0 4px rgba(14, 165, 233, 0.2),
          inset 0 2px 6px rgba(0, 0, 0, 0.3);
        background: rgba(28, 33, 48, 0.95);
      }
      
      .step-header {
        font-size: 1.6rem;
        font-weight: 700;
        margin-bottom: 18px;
        color: #ffffff;
        background: linear-gradient(135deg, #0ea5e9, #60d5ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }
      
      .step-description {
        font-size: 1rem;
        color: #cbd3e8;
        margin-bottom: 28px;
        line-height: 1.7;
      }

      /* Grid for Presets */
      .preset-cards {
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        gap: 12px !important;
        margin-top: 16px !important;
        width: 100% !important;
      }

      .preset-card {
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        padding: 16px !important;
        background: #3c3c3c !important;
        border-radius: 8px !important;
        border: 1px solid #555 !important;
        color: #ffffff !important;
        cursor: pointer !important;
        min-height: 110px !important;
        transition: all 0.2s ease !important;
        width: 100% !important;
        box-sizing: border-box !important;
      }

      .preset-card:hover {
        background: #4a4a4a !important;
      }

      .preset-card.selected {
        border: 2px solid #00b0ff !important;
        box-shadow: 0 0 10px rgba(0, 176, 255, 0.4) !important;
      }

      .preset-icon { font-size: 2.2rem !important; margin-bottom: 4px !important; }
      .preset-title { font-weight: 600 !important; font-size: 1rem !important; }
      .preset-description { font-size: 0.8rem !important; color: #b0b0b0 !important; }
    `;
  }

  constructor() {
    super();
    this._step = 0;
    this._config = { ...DEFAULT_CONFIG };
    this._language = 'en';
    this.i18n = new EditorI18n('en');
    this.wizard = new EditorWizard(this);

    // NUOVO: Inizializza proprietÃ  dashboard
    this._dashboardProfilesData = null;
    this._dashboardLoading = false;
    this._dashboardSelectedPreset = null;
    this._dashboardSelectedProfile = null;
    this._dashboardShowDetailModal = false;
    this._dashboardDetailData = null;

    // Debounce config-changed to avoid constant card recreations while typing
    this._debouncedDispatch = this._debounce(() => {
      this.dispatchEvent(new CustomEvent('config-changed', { detail: { config: this._config } }));
    }, 500);

    // Bind methods
    this._renderTextInput = this._renderTextInput.bind(this);
    this._renderButton = this._renderButton.bind(this);

    // Expose ALL service handlers to children steps
    this.serviceHandlers = {
      copyToClipboard,
      downloadFile,
      handleCreateHelpersYaml,
      handleCreateAutomationYaml,
      handleCreateAndReloadAutomation,
      runDeepChecks,
      handleInitializeData,
      handleSaveAll
    };
  }

  connectedCallback() {
    super.connectedCallback();
    this._deepCheckRanForStep1 = false;
    this._deepCheckRanForStep5 = false;
    this._deepCheckSubscribed = false;
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._unsubscribeDeep) {
      try { this._unsubscribeDeep(); } catch { }
      this._unsubscribeDeep = null;
    }
    this._deepCheckSubscribed = false;
  }

  async _ensureDeepCheckSubscription() {
    if (this.hass?.connection && !this._deepCheckSubscribed) {
      try {
        this._unsubscribeDeep = await this.hass.connection.subscribeEvents((ev) => {
          const data = ev?.event?.data ?? ev?.data ?? ev;
          if (data) {
            this._deepReport = data;
            this.requestUpdate();
          }
        }, 'cronostar_setup_report');
        this._deepCheckSubscribed = true;
      } catch (e) {
        console.warn('Failed to subscribe to deep check reports:', e);
      }
    }
  }

  updated(changedProps) {
    super.updated?.(changedProps);
    if (changedProps.has('hass')) {
      this._ensureDeepCheckSubscription();
      if (this.hass && this._step === 1 && !this._deepCheckRanForStep1) {
        this._deepCheckRanForStep1 = true;
        this._runDeepChecks();
      }
      if (this.hass && this._step === 5 && !this._deepCheckRanForStep5) {
        this._deepCheckRanForStep5 = true;
        this._runDeepChecks();
      }
    }
    if (changedProps.has('_step')) {
      if (this._step === 1 && this.hass && !this._deepCheckRanForStep1) {
        this._deepCheckRanForStep1 = true;
        this._runDeepChecks();
      }
      if (this._step === 5 && this.hass && !this._deepCheckRanForStep5) {
        this._deepCheckRanForStep5 = true;
        this._runDeepChecks();
      }
      if (this._step !== 1) this._deepCheckRanForStep1 = false;
      if (this._step !== 5) this._deepCheckRanForStep5 = false;
    }
  }

  setConfig(config) {
    try {
      this._config = validateConfig(config);
    } catch (e) {
      console.warn("Config validation warning:", e);
      this._config = { ...DEFAULT_CONFIG, ...config };
    }

    if (this._config.preset) this._selectedPreset = this._config.preset;

    if (this.hass && this.hass.language) {
      this._language = this.hass.language.split('-')[0];
      this.i18n = new EditorI18n(this._language);
    }

    this._syncConfigAliases();
    this._updateAutomationYaml();
    this._updateHelpersYaml();
  }

  _isElDefined(tag) {
    return customElements.get(tag) !== undefined;
  }

  _syncConfigAliases() {
    const p = normalizePrefix(this._config.global_prefix);
    this._calculatedHelpersFilename = buildHelpersFilename(p);
    this._calculatedAutomationFilename = buildAutomationFilename(p);
  }

  _updateAutomationYaml() {
    this._automationYaml = buildAutomationYaml(this._config, 'list');
  }

  _updateHelpersYaml() {
    this._helpersYaml = buildInputNumbersYaml(this._config, false);
  }

  _dispatchConfigChanged(immediate = false) {
    if (immediate) {
      if (this._debounceTimer) clearTimeout(this._debounceTimer);
      this.dispatchEvent(new CustomEvent('config-changed', { detail: { config: this._config } }));
    } else {
      this._debouncedDispatch();
    }
  }

  _debounce(func, wait) {
    return (...args) => {
      clearTimeout(this._debounceTimer);
      this._debounceTimer = setTimeout(() => func.apply(this, args), wait);
    };
  }

  _persistCardConfigNow() {
    // Config persistence is unified into save_profile (meta).
    return Promise.resolve();
  }

  showToast(message) {
    const event = new CustomEvent('hass-notification', {
      detail: { message, duration: 3000 },
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(event);
  }

  // Implementation of _runDeepChecks called by Wizard
  async _runDeepChecks() {
    if (!this.hass) return;
    this._deepCheckInProgress = true;
    this.requestUpdate();

    try {
      await runDeepChecks(this.hass, this._config, this._language);
      // The actual report will arrive via the 'cronostar_setup_report' event subscription.
    } catch (e) {
      console.warn("Deep check failed:", e);
    } finally {
      this._deepCheckInProgress = false;
      this.requestUpdate();
    }
  }

  _renderWizardSteps() {
    const steps = [0, 1, 2, 3, 4, 5];
    return html`
      <div class="wizard-steps">
        ${steps.map(s => html`
          <div 
            class="step-badge ${this._step === s ? 'active' : ''}" 
            @click=${() => { 
              if (s <= this._step) {
                this._step = s; 
                this.requestUpdate();
              }
            }}
          >
            ${s === 0 ? 'ðŸ ' : s}
          </div>
        `)}
      </div>
    `;
  }

  _renderStepContent() {
    switch (this._step) {
      case 0: return new Step0Dashboard(this).render();
      case 1: return new Step1Preset(this).render();
      case 2: return new Step2Entities(this).render();
      case 3: return new Step3Options(this).render();
      case 4: return new Step4Automation(this).render();
      case 5: return new Step5Summary(this).render();
      default: return html`<div>Unknown Step</div>`;
    }
  }

  _handleLocalUpdate(key, value) {
    const newConfig = { ...this._config, [key]: value };
    newConfig.type = this._config.type || DEFAULT_CONFIG.type;
    if ('entity_prefix' in newConfig) delete newConfig.entity_prefix;
    this._config = newConfig;
    
    this._syncConfigAliases();
    this._updateAutomationYaml();
    this._updateHelpersYaml();
    this.requestUpdate();
  }

  _renderTextInput(key, value, placeholder = '') {
    return html`
      <ha-textfield
        .label=${placeholder}
        .value=${value || ''}
        @input=${(e) => this._handleLocalUpdate(key, e.target.value)}
        @change=${() => this._dispatchConfigChanged(true)}
        style="width: 100%;"
      ></ha-textfield>
    `;
  }

  renderTextInput(key, value, placeholder) {
    return this._renderTextInput(key, value, placeholder);
  }

  // Public wrapper for renderButton
  renderButton(label, click, disabled = false, outlined = false) {
    return this._renderButton({ label, click, disabled, outlined });
  }

  _renderButton({ label, click, disabled = false, outlined = false }) {
    if (outlined) {
      return html`<mwc-button outlined ?disabled=${disabled} @click=${click}>${label}</mwc-button>`;
    }
    return html`<mwc-button raised ?disabled=${disabled} @click=${click}>${label}</mwc-button>`;
  }

  _updateConfig(key, value) {
    const newConfig = { ...this._config, [key]: value };
    
    // Explicitly enforce stable type to avoid reconstruction
    newConfig.type = this._config.type || DEFAULT_CONFIG.type;

    // Hard-remove deprecated keys
    if ('entity_prefix' in newConfig) delete newConfig.entity_prefix;
    
    if (key === 'preset') {
      const presetConfig = CARD_CONFIG_PRESETS[value];
      if (presetConfig) {
        Object.assign(newConfig, presetConfig);
        this._selectedPreset = value;
      }
    }

    this._config = newConfig;
    this._syncConfigAliases();
    this._updateAutomationYaml();
    this._updateHelpersYaml();
    this._dispatchConfigChanged();
  }

  _handleNextClick() {
    if (this._canGoNext()) {
      this._showStepError = false;
      this._dispatchConfigChanged(true);
      this.wizard._nextStep();
    } else {
      this._showStepError = true;
      this.requestUpdate();
    }
  }

  async _handleFinishClick(options = {}) {
    const force = options.force === true;

    if ((this._step === 5 || force) && this.hass) {
      try {
        const result = await handleSaveAll(this.hass, this._config, this._deepReport, this._language);
        this.showToast(result.message);

        if (force) {
          const closeEvent = new CustomEvent('closed', { bubbles: true, composed: true });
          this.dispatchEvent(closeEvent);
        }

      } catch (e) {
        this.showToast(`âœ— ${e.message}`);
      }
    }

    this._persistCardConfigNow();
    if (this.wizard && typeof this.wizard._finish === 'function') this.wizard._finish();
  }

  _canGoNext() {
    if (this._step === 0) return true;
    if (this._step === 1) {
      const p = normalizePrefix(this._config.global_prefix);
      return isValidPrefix(p) && !!this._config.target_entity;
    }
    return true;
  }

  _renderWizardActions() {
    if (this._step === 0) {
      return html``;
    }

    if (this._step === 1) {
      const valid = this._canGoNext();
      if (!valid) {
        return html`
               <div class="wizard-actions">
                  <mwc-button outlined @click=${() => { this._step = 0; this.requestUpdate(); }}>
                    ${this.i18n._t('actions.back')}
                  </mwc-button>
                  <div style="flex:1"></div>
                  <div class="hint" style="color: var(--error-color);">
                    ${this.i18n._t('ui.minimal_config_needed')}
                  </div>
               </div>`;
      }
      return html`
        <div class="wizard-actions">
          <mwc-button outlined @click=${() => { this._step = 0; this.requestUpdate(); }}>
            ${this.i18n._t('actions.back')}
          </mwc-button>
        </div>
      `;
    }

    return html`
      <div class="wizard-actions">
        <div>
          ${this._step > 1 ? html`<mwc-button outlined @click=${() => { this._dispatchConfigChanged(true); this.wizard._prevStep(); }}>${this.i18n._t('actions.back')}</mwc-button>` : html``}
        </div>
        <div>
          ${this._step === 5
        ? html`<mwc-button raised @click=${() => this._handleFinishClick()}>${this.i18n._t('actions.save')}</mwc-button>`
        : html`<mwc-button raised @click=${() => this._handleNextClick()}>${this.i18n._t('actions.next')}</mwc-button>`}
        </div>
      </div>
    `;
  }

  render() {
    return html`
      <div class="editor-container">
        ${this._renderWizardSteps()}
        ${this._renderStepContent()}
        ${this._renderWizardActions()}
      </div>
    `;
  }
}

customElements.define('cronostar-card-editor', CronoStarEditor);

# --- File: cronostar_card/src/editor/EditorI18n.js ---
# Real size: 14006 bytes, Used: 14006 bytes
/**
 * EditorI18n.js - Complete Internationalization for CronoStar Editor
 * Supports: English (en) and Italian (it)
 */

export const I18N = {
  en: {
    step2_msgs: {
      prefix_ok: 'Prefix looks valid.'
    },
    steps: {
      tipo: 'Setup',
      entita: 'Advanced',
      opzioni: 'Options',
      automazione: 'Automation',
      fine: 'Finish'
    },
    headers: {
      step0: 'Dashboard',  // NUOVO
      step1: 'Basic Configuration',
      step2: 'Advanced Configuration',
      step3: 'Display Options',
      step4: 'Automation Setup',
      step5: 'Summary & Verification'
    },
    descriptions: {
      step0: 'Choose an action: configure a new preset or analyze existing profiles.',  // NUOVO
      step1: 'Configure the essential elements: target entity and identification prefix.',
      step2: 'Optional: configure additional entities (pause, profiles) and generate the configuration package.',
      step3: 'Customize the card appearance and value ranges.',
      step4: 'Generate the automation that applies scheduled values every hour.',
      step5: 'Review your configuration and verify the setup.'
    },
    presetNames: {
      thermostat: 'Thermostat',
      ev_charging: 'EV Charging',
      generic_kwh: 'Generic kWh',
      generic_temperature: 'Generic Temperature',
      generic_switch: 'Switch'
    },
    fields: {
      // Aliases for legacy keys without underscores
      titlelabel: 'Card Title',
      yaxislabel: 'Y-Axis Label',
      unitlabel: 'Unit of Measurement',
      minlabel: 'Minimum Value',
      maxlabel: 'Maximum Value',
      steplabel: 'Step',
      allowmaxlabel: 'Allow "Max" Value',
      intervallabel: 'Time Interval',
      logginglabel: 'Enable Debug Logging',
      target_entity_label: 'Target Entity',
      target_entity_desc: 'The entity where scheduled values will be applied (climate, number, or switch).',
      package_label: 'Configuration Package',
      package_desc: 'Copy this â€œConfiguration Packageâ€ into {path}. If you continue in the wizard, CronoStar will try to create/update the file automatically (when supported by the backend).',
      enable_pause_label: 'Enable Pause (input_boolean)',
      enable_pause_desc: 'Add a pause switch to temporarily disable the automation',
      enable_profiles_label: 'Enable Multiple Profiles (input_select)',
      enable_profiles_desc: 'Add a profile selector to switch between different schedules',
      // entity_prefix removed (breaking change): use global_prefix
      title_label: 'Card Title',
      y_axis_label: 'Y-Axis Label',
      unit_label: 'Unit of Measurement',
      min_label: 'Minimum Value',
      min_desc: 'Minimum allowed value in the chart.',
      max_label: 'Maximum Value',
      max_desc: 'Maximum allowed value in the chart.',
      step_label: 'Step',
      step_desc: 'Increment for value adjustments.',
      interval_label: 'Time Interval',
      interval_desc: 'Select the time resolution. Lower values create more points but require more entities.',
      hour_base_label: 'Hour Numbering',
      hour_base_desc: 'Hour numbering format (0-23 or 1-24). "Auto" detects automatically.',
      logging_label: 'Enable Debug Logging',
      logging_desc: 'Shows detailed logs in browser console for troubleshooting.',
      allow_max_label: 'Allow "Max" Value',
      allow_max_desc: 'Enables a symbolic "Max" value, useful for dynamic solar charging logic.'
    },
    checks: {
      title: 'Configuration Check',
      deep_hint: 'Deep checks analyze configuration.yaml and includes to locate helpers and automations.',
      expected_alias_label: 'Expected alias',
      expected_auto_id_label: 'Expected automation ID'
    },
    what_to_do_next: {
      title: 'Next Steps:'
      // Nota: rimosso explicit save configuration step
    },
    actions: {
      back: 'Back',
      next: 'Next',
      save: 'Save',
      save_and_create: 'Save & Create Files',
      advanced_config: 'Advanced Configuration',
      copy_yaml: 'Copy YAML',
      download_file: 'Download File',
      create_automation_and_reload: 'Create Automation & Reload',
      show_preview: 'Show Preview',
      run_deep_checks: 'Run Deep Checks'
    },
    ui: {
      automatic_entities_desc: 'CronoStar will create the required helper entities automatically when supported.',
      loading_deep_check_results: 'Loading deep check resultsâ€¦',
      card_config_complete: 'Card configuration complete',
      card_config_ready: 'Card configuration ready',
      minimal_config_complete: 'Minimal configuration complete',
      minimal_config_needed: 'Minimal configuration needed',
      minimal_config_help: 'Set target entity and identification prefix to proceed.',
      minimal_config_info: 'This will create {entity} and the package file {package}.',
      identification_prefix: 'Identification Prefix',
      // Provide missing legacy key to avoid console warnings
      prefix_description: 'Used to identify all CronoStar entities.',
      prefix_description_simple: 'Used to identify all CronoStar entities.',
      prefix_hint: 'Must be lowercase letters/numbers/underscores and end with underscore (_).',
      final_mod_title: 'Final Configuration Review',
      final_mod_text: 'The wizard has prepared the parameters below. When you click "Save", they will be applied to your Lovelace card and the integration will attempt to automatically create the required YAML package and automation files.',
      fix_step_to_proceed: 'Please fix fields to proceed.',
      service_check_setup_not_available: 'Deep checks service is not available',
      automatic_entities_title: 'Automatic Entities',
      automations_path_not_determined: 'Automations path not determined. Run Deep Checks first.',
      inline_automation_use_ui: 'Inline automations must be edited via the UI.',
      cronostar_automation_yaml: 'CronoStar Automation YAML',
      copy: 'Copy',
      yaml_copied_go_to_automations: 'YAML copied. Go to Settings â†’ Automations to paste it.',
      switch_off: 'Off',
      switch_on: 'On',
      automation_created_successfully: 'Automation created and reloaded successfully.',
      checks_triggered: 'Checks triggered successfully.'
    }
    ,
    // Root-level fallbacks for legacy keys
    finalmodtitle: 'Final Configuration Review',
    finalmodtext: 'The wizard has prepared the parameters below. When you click "Save", they will be applied to your Lovelace card and the integration will attempt to automatically create the required YAML package and automation files.'
  },

  it: {
    step2_msgs: {
      prefix_ok: 'Prefisso valido.'
    },
    steps: {
      tipo: 'Setup',
      entita: 'Avanzate',
      opzioni: 'Opzioni',
      automazione: 'Automazione',
      fine: 'Fine'
    },
    headers: {
      step0: 'Dashboard',  // NUOVO
      step1: 'Configurazione Base',
      step2: 'Configurazione Avanzata',
      step3: 'Opzioni Visualizzazione',
      step4: 'Setup Automazione',
      step5: 'Riepilogo e Verifica'
    },
    descriptions: {
      step0: 'Scegli un\'azione: configurare un nuovo preset o analizzare i profili esistenti.',  // NUOVO
      step1: 'Configura gli elementi essenziali: entitÃ  di destinazione e prefisso identificativo.',
      step2: 'Opzionale: configura entitÃ  aggiuntive (pausa, profili) e genera il package di configurazione.',
      step3: 'Personalizza l\'aspetto della card e gli intervalli di valori.',
      step4: 'Genera l\'automazione che applica i valori programmati ogni ora.',
      step5: 'Rivedi la tua configurazione e verifica il setup.'
    },
    presetNames: {
      thermostat: 'Termostato',
      ev_charging: 'Ricarica EV',
      generic_kwh: 'kWh Generici',
      generic_temperature: 'Temperatura Generica',
      generic_switch: 'Interruttore'
    },
    fields: {
      // Alias per chiavi legacy senza underscore
      titlelabel: 'Titolo Card',
      yaxislabel: 'Etichetta Asse Y',
      unitlabel: 'UnitÃ  di Misura',
      minlabel: 'Valore Minimo',
      maxlabel: 'Valore Massimo',
      steplabel: 'Passo',
      allowmaxlabel: 'Consenti Valore "Max"',
      intervallabel: 'Intervallo Temporale',
      logginglabel: 'Abilita Logging Debug',
      target_entity_label: 'EntitÃ  di Destinazione',
      target_entity_desc: 'L\'entitÃ  su cui verranno applicati i valori programmati (climate, number o switch).',
      package_label: 'Package di Configurazione',
      package_desc: 'Copia questo â€œConfiguration Packageâ€ in {path}. Se prosegui nel wizard, CronoStar proverÃ  a creare/aggiornare automaticamente il file (quando il backend lo supporta).',
      enable_pause_label: 'Abilita Pausa (input_boolean)',
      enable_pause_desc: 'Aggiungi un interruttore pausa per disabilitare temporaneamente l\'automazione',
      enable_profiles_label: 'Abilita Profili Multipli (input_select)',
      enable_profiles_desc: 'Aggiungi un selettore profili per passare tra diversi programmi',
      // entity_prefix rimosso (breaking change): usa global_prefix
      title_label: 'Titolo Card',
      y_axis_label: 'Etichetta Asse Y',
      unit_label: 'UnitÃ  di Misura',
      min_label: 'Valore Minimo',
      max_label: 'Valore Massimo',
      step_label: 'Passo',
      interval_label: 'Intervallo Temporale',
      interval_desc: 'Valori piÃ¹ bassi creano piÃ¹ punti ma richiedono piÃ¹ entitÃ .',
      hour_base_label: 'Numerazione Ore',
      hour_base_desc: 'Formato numerazione ore (0-23 o 1-24). "Auto" rileva automaticamente.',
      logging_label: 'Abilita Logging Debug',
      logging_desc: 'Mostra log dettagliati nella console.',
      allow_max_label: 'Consenti Valore "Max"',
      allow_max_desc: 'Abilita un valore simbolico "Max".'
    },
    checks: {
      title: 'Verifica Configurazione',
      deep_hint: 'Le verifiche approfondite analizzano configuration.yaml e gli include per localizzare helpers e automazioni.',
      expected_alias_label: 'Alias atteso',
      expected_auto_id_label: 'ID automazione atteso'
    },
    what_to_do_next: {
      title: 'Prossimi Passi:'
      // Rimosso il punto "Salva la configurazione della card" come da richiesta
    },
    actions: {
      back: 'Indietro',
      next: 'Avanti',
      save: 'Salva',
      save_and_create: 'Salva & crea file',
      advanced_config: 'Configurazione Avanzata',
      copy_yaml: 'Copia YAML',
      download_file: 'Scarica File',
      create_automation_and_reload: 'Crea Automazione e Ricarica',
      show_preview: 'Mostra Anteprima',
      run_deep_checks: 'Esegui Verifiche Approfondite'
    },
    ui: {
      automatic_entities_desc: 'CronoStar creerÃ  automaticamente le entitÃ  helper necessarie quando supportato.',
      loading_deep_check_results: 'Caricamento risultati verifiche approfonditeâ€¦',
      card_config_complete: 'Configurazione card completa',
      card_config_ready: 'Card pronta con la configurazione',
      minimal_config_complete: 'Configurazione minima completa',
      minimal_config_needed: 'Configurazione minima necessaria',
      minimal_config_help: 'Imposta entitÃ  di destinazione e prefisso identificativo per procedere.',
      minimal_config_info: 'Questo creerÃ  {entity} e il file package {package}.',
      identification_prefix: 'Prefisso Identificativo',
      // Chiave legacy per evitare warning in console
      prefix_description: 'Usato per identificare tutte le entitÃ  CronoStar.',
      prefix_description_simple: 'Usato per identificare tutte le entitÃ  CronoStar.',
      prefix_hint: 'Deve terminare con underscore (_).',
      final_mod_title: 'Riepilogo finale configurazione',
      final_mod_text: 'Il wizard ha preparato i parametri seguenti. Cliccando su "Salva", verranno applicati alla card Lovelace e l\'integrazione tenterÃ  di creare automaticamente il file package YAML e l\'automazione necessaria.',
      fix_step_to_proceed: 'Correggi i campi per proseguire.',
      service_check_setup_not_available: 'Servizio di verifiche approfondite non disponibile',
      automatic_entities_title: 'EntitÃ  automatiche',
      automations_path_not_determined: 'Percorso automazioni non determinato. Esegui prima le Verifiche Approfondite.',
      inline_automation_use_ui: 'Le automazioni inline vanno modificate dalla UI.',
      cronostar_automation_yaml: 'YAML Automazione CronoStar',
      copy: 'Copia',
      yaml_copied_go_to_automations: 'YAML copiato. Vai in Impostazioni â†’ Automazioni per incollarlo.',
      switch_off: 'Spento',
      switch_on: 'Acceso',
      automation_created_successfully: 'Automazione creata e ricaricata con successo.',
      checks_triggered: 'Verifiche avviate con successo.'
    }
    ,
    // Chiavi legacy a livello radice
    finalmodtitle: 'Riepilogo finale configurazione',
    finalmodtext: 'Il wizard ha preparato i parametri seguenti. Cliccando su "Salva", verranno applicati alla card Lovelace e l\'integrazione tenterÃ  di creare automaticamente il file package YAML e l\'automazione necessaria.'
  }
};

export class EditorI18n {
  constructor(editor) {
    this.editor = editor;
  }
  _t(path, replacements = {}) {
    const lang = this.editor._lang || 'en';
    const parts = path.split('.');
    let obj = I18N[lang] || I18N.en;
    for (const part of parts) {
      obj = obj?.[part];
    }
    if (obj === undefined) {
      let fallback = I18N.en;
      for (const part of parts) fallback = fallback?.[part];
      obj = fallback;
    }
    if (obj === undefined) {
      console.warn(`[EditorI18n] Missing translation: ${path}`);
      return path;
    }
    if (typeof obj === 'string' && Object.keys(replacements).length > 0) {
      let result = obj;
      for (const [key, value] of Object.entries(replacements)) {
        result = result.replace(key, value);
      }
      return result;
    }
    return obj;
  }
  _getPresetName() {
    const preset = this.editor._selectedPreset || 'thermostat';
    return this._t(`presetNames.${preset}`);
  }
  _localizePreset(key) {
    return this._t(`presetNames.${key}`);
  }
}


# --- File: cronostar_card/src/editor/EditorWizard.js ---
# Real size: 1726 bytes, Used: 1726 bytes
export class EditorWizard {
  constructor(editor) {
    this.editor = editor;
  }

  _nextStep() {
    console.log(`[CronoStar Wizard] _nextStep called. Current step: ${this.editor._step}`);
    if (this.editor._step < 5) {
      this.editor._step++;
      if (typeof this.editor.scrollToTop === 'function') this.editor.scrollToTop();
      console.log(`[CronoStar Wizard] Moving to step: ${this.editor._step}`);
      
      if (this.editor._step === 2) {
          console.log(`[CronoStar Wizard] Checking deep check status... ran=${this.editor._deepCheckRanForStep2}`);
          if (!this.editor._deepCheckRanForStep2) {
            console.log('[CronoStar Wizard] Triggering _runDeepChecks for Step 2');
            this.editor._deepCheckRanForStep2 = true;
            this.editor._runDeepChecks();
          }
      }
      this.editor.requestUpdate();
    }
  }

  _prevStep() {
    if (this.editor._step > 1) {
      this.editor._step--;
      if (typeof this.editor.scrollToTop === 'function') this.editor.scrollToTop();
      if (this.editor._step !== 2) {
        this.editor._deepCheckRanForStep2 = false;
      }
      this.editor.requestUpdate();
    }
  }

  _finish() {
      // Force immediate persist before closing
      if (this.editor._persistCardConfigNow) {
        this.editor._persistCardConfigNow()
          .then(() => {
            console.log('[Wizard] Config persisted on finish');
            this.editor._dispatchConfigChanged(true);
          })
          .catch(err => {
            console.error('[Wizard] Persist on finish failed:', err);
            this.editor._dispatchConfigChanged(true);
          });
      } else {
        this.editor._dispatchConfigChanged(true);
      }
    }
}


# --- File: cronostar_card/src/editor/services/service_handlers.js ---
# Real size: 10069 bytes, Used: 10069 bytes
/**
 * Service call handlers for CronoStar Editor
 */
import { getEffectivePrefix, getAliasWithPrefix } from '../../utils/prefix_utils.js';
import { buildHelpersFilename, buildAutomationFilename } from '../../utils/filename_utils.js';
import { escapeHtml } from '../../utils/editor_utils.js';
import { buildAutomationYaml, buildInputNumbersYaml } from '../yaml/yaml_generators.js';
import { I18N } from '../EditorI18n.js';
import { Logger } from '../../utils.js';

function localize(lang, key, search, replace) {
  const parts = key.split('.');
  let obj = I18N[lang] || I18N.en;
  for (const p of parts) obj = obj?.[p];
  let value = typeof obj === 'string' ? obj : key;
  if (search && typeof search === 'object') Object.keys(search).forEach((needle) => { value = value.replace(needle, search[needle]); });
  if (replace && typeof replace === 'object') Object.keys(replace).forEach((needle) => { value = value.replace(needle, replace[needle]); });
  return value;
}

export async function copyToClipboard(text, successMessage, errorMessage) {
  try { await navigator.clipboard.writeText(text); return { success: true, message: successMessage }; }
  catch (e) { console.warn('Clipboard write failed:', e); return { success: false, message: errorMessage }; }
}

export function downloadFile(filename, content, successMessage, errorMessage) {
  try {
    const blob = new Blob([content], { type: 'text/yaml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    return { success: true, message: successMessage };
  } catch (e) { console.error('File download failed:', e); return { success: false, message: errorMessage }; }
}

export async function createYamlFile(hass, filePath, content, append = false) {
  if (!hass?.services?.cronostar?.create_yaml_file) throw new Error('Service cronostar.create_yaml_file not available');
  await hass.callService('cronostar', 'create_yaml_file', { file_path: filePath, content, append });
}

/**
 * Helpers YAML file creation
 */
export async function handleCreateHelpersYaml(hass, config, deepReport, language) {
  // Force deep check to determine include paths if possible
  try { await runDeepChecks(hass, config, language); } catch { }
  const effectivePrefix = getEffectivePrefix(config);
  const filename = buildHelpersFilename(effectivePrefix);
  // Always generate a proper package file with headers and place it under 'packages'
  const content = buildInputNumbersYaml(config, true);
  const fullPath = `packages/${filename}`;
  await createYamlFile(hass, fullPath, content, false);
  return { success: true, message: `âœ“ File created: ${fullPath}` };
}

function minutesToTime(minutes) {
  const h = Math.floor(minutes / 60) % 24;
  const m = Math.floor(minutes % 60);
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

/**
 * Automation YAML file creation
 */
export async function handleCreateAutomationYaml(hass, config, deepReport, language) {
  // Force deep check to determine include paths if possible
  try { await runDeepChecks(hass, config, language); } catch { }
  const effectivePrefix = getEffectivePrefix(config);
  const filename = buildAutomationFilename(effectivePrefix);
  const autoSource = deepReport?.automation?.source || 'unknown';
  const autoDir = deepReport?.automation?.full_path;
  if (!autoSource || !autoDir || autoSource === 'none') throw new Error(localize(language, 'ui.automations_path_not_determined'));
  const style = autoSource === 'inline' ? 'inline' : 'list';
  const content = buildAutomationYaml(config, style);
  if (autoSource === 'include_dir_list') {
    const fullPath = `${autoDir}/${filename}`;
    await createYamlFile(hass, fullPath, content);
    return { success: true, message: `âœ“ File created: ${fullPath}` };
  } else if (autoSource === 'include_file') {
    await createYamlFile(hass, autoDir, `\n# ==== CronoStar Automation ====`, true);
    return { success: true, message: `âœ“ Appended to: ${autoDir}` };
  } else if (autoSource === 'inline') {
    throw new Error(localize(language, 'ui.inline_automation_use_ui'));
  }
  throw new Error('Unknown automation source');
}

/**
 * Create and reload automation
 */
export async function handleCreateAndReloadAutomation(hass, config, deepReport, language) {
  // Ensure deep checks run before attempting creation
  try { await runDeepChecks(hass, config, language); } catch { }
  const hasCreateFile = !!hass?.services?.cronostar?.create_yaml_file;
  const deepOk = !!deepReport?.automation?.source;
  if (hasCreateFile && deepOk) {
    await handleCreateAutomationYaml(hass, config, deepReport, language);
    try { await hass.callService('automation', 'reload', {}); } catch (e) { console.warn('automation.reload failed:', e); }
    return { success: true, message: localize(language, 'ui.automation_created_successfully') };
  }
  const style = deepReport?.automation?.source === 'inline' ? 'inline' : 'list';
  const yaml = buildAutomationYaml(config, style);
  // Do not open a new window; just copy YAML to clipboard and inform the user
  try { await navigator.clipboard.writeText(yaml); } catch (e) { console.warn('Clipboard write failed:', e); }
  return { success: true, message: localize(language, 'ui.yaml_copied_go_to_automations') };
}

/**
 * Deep checks service call (exported for editor)
 */
export async function runDeepChecks(hass, config, language) {
  if (!hass?.services?.cronostar?.check_setup) {
    throw new Error(localize(language, 'ui.service_check_setup_not_available'));
  }
  const effectivePrefix = getEffectivePrefix(config);
  const alias = getAliasWithPrefix(effectivePrefix, language);
  await hass.callService('cronostar', 'check_setup', {
    prefix: effectivePrefix,
    hour_base: config.hour_base === '1' || config.hour_base === 1 ? 1 : 0,
    alias: alias,
  });
  return { success: true, message: localize(language, 'ui.checks_triggered') };
}

/**
 * Initializes/Sanitizes the data JSON file with a default profile
 * Analyzes existing data and ensures validity (boundary points)
 */
export async function handleInitializeData(hass, config, language) {
  const prefix = getEffectivePrefix(config);
  const preset = config.preset || 'thermostat';
  const profileName = 'Comfort';
  const minVal = config.min_value ?? 0;

  if (!hass) throw new Error('Home Assistant not connected');

  let schedule = [];
  let isNew = false;

  // 1. Try to load existing profile
  try {
    const result = await hass.callWS({
      type: 'call_service',
      domain: 'cronostar',
      service: 'load_profile',
      service_data: {
        profile_name: profileName,
        preset_type: preset,
        global_prefix: prefix
      },
      return_response: true,
    });
    
    const resp = result?.response ?? result;
    if (resp?.schedule && Array.isArray(resp.schedule)) {
      schedule = resp.schedule;
      Logger.log('INIT', `Loaded existing profile '${profileName}' for analysis/correction`);
    } else {
      isNew = true;
    }
  } catch (e) {
    isNew = true;
    Logger.log('INIT', `Profile '${profileName}' not found, initializing fresh default`);
  }

  // 2. If new or failed to load, start with default point
  if (isNew || schedule.length === 0) {
    schedule = [{ time: '00:00', value: minVal }];
  }

  // 3. Analyze and Correct (ensure boundary points for sparse mode)
  // Ensure we have a point at 00:00
  if (!schedule.some(p => p.time === '00:00')) {
    const firstVal = schedule.length > 0 ? schedule[0].value : minVal;
    schedule.unshift({ time: '00:00', value: firstVal });
  }
  // Ensure we have a point at 23:59
  if (!schedule.some(p => p.time === '23:59')) {
    const lastVal = schedule[schedule.length - 1].value;
    schedule.push({ time: '23:59', value: lastVal });
  }
  
  // Sort by time to ensure integrity
  schedule.sort((a, b) => {
    const ta = String(a.time).split(':').map(Number);
    const tb = String(b.time).split(':').map(Number);
    return (ta[0] * 60 + ta[1]) - (tb[0] * 60 + tb[1]);
  });

  // 4. Save back with updated meta
  const safeMeta = (() => {
    const src = (config && typeof config === 'object') ? config : {};
    const { entity_prefix, ...rest } = src;
    if (!rest.global_prefix && prefix) rest.global_prefix = prefix;
    return rest;
  })();

  await hass.callService('cronostar', 'save_profile', {
    profile_name: profileName,
    preset_type: preset,
    schedule: schedule,
    global_prefix: prefix,
    meta: safeMeta,
  });

  return { 
    success: true, 
    message: isNew ? 'âœ“ Default profile initialized' : 'âœ“ Existing profile analyzed and corrected' 
  };
}

/**
 * One-click save: JSON profile + YAML package + YAML automation (+reload)
 */
export async function handleSaveAll(hass, config, deepReport, language) {
  const messages = [];
  // Force deep check at the start to try to discover paths
  try {
    const checks = await runDeepChecks(hass, config, language);
    messages.push(checks.message);
  } catch (e) {
    messages.push(`âœ— Deep Checks: ${e.message}`);
  }
  const effectivePrefix = getEffectivePrefix(config);
  const packageFilename = buildHelpersFilename(effectivePrefix);
  const automationFilename = buildAutomationFilename(effectivePrefix);

  // Analyze and correct data instead of skipping
  try {
    const init = await handleInitializeData(hass, config, language);
    messages.push(init.message);
  } catch (e) {
    messages.push(`âœ— Data Analysis: ${e.message}`);
  }

  try {
    const pkg = await handleCreateHelpersYaml(hass, config, deepReport, language);
    messages.push(pkg.message);
  } catch (e) {
    messages.push(`âœ— Package (${packageFilename}): ${e.message}`);
  }

  try {
    const auto = await handleCreateAndReloadAutomation(hass, config, deepReport, language);
    messages.push(auto.message);
  } catch (e) {
    messages.push(`âœ— Automation (${automationFilename}): ${e.message}`);
  }

  return { success: true, message: messages.join('\n') };
}


# --- File: cronostar_card/src/editor/steps/Step0Dashboard.js ---
# Real size: 19411 bytes, Used: 19411 bytes
import { html } from 'lit';

export class Step0Dashboard {
  constructor(editor) {
    this.editor = editor;
    this._chartJsLoaded = false;
  }

  async _ensureChartJs() {
    if (this._chartJsLoaded || typeof Chart !== 'undefined') {
      this._chartJsLoaded = true;
      return true;
    }

    return new Promise((resolve) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
      script.onload = () => {
        this._chartJsLoaded = true;
        console.log('[DASHBOARD] Chart.js loaded successfully');
        resolve(true);
      };
      script.onerror = () => {
        console.error('[DASHBOARD] Failed to load Chart.js');
        resolve(false);
      };
      document.head.appendChild(script);
    });
  }

  async _loadAllProfiles() {
    if (!this.editor.hass) return;
    
    this.editor._dashboardLoading = true;
    this.editor.requestUpdate();
    
    try {
      const result = await this.editor.hass.callWS({
        type: 'call_service',
        domain: 'cronostar',
        service: 'list_all_profiles',
        service_data: {},
        return_response: true
      });
      
      this.editor._dashboardProfilesData = result?.response || {};
      console.log('[DASHBOARD] Loaded profiles:', this.editor._dashboardProfilesData);
      
    } catch (e) {
      console.warn('Failed to load profiles:', e);
      this.editor._dashboardProfilesData = {};
    }
    
    this.editor._dashboardLoading = false;
    this.editor.requestUpdate();
  }

  async _loadProfileDetail(presetType, profileName, globalPrefix) {
    if (!this.editor.hass) return;
    
    try {
      const result = await this.editor.hass.callWS({
        type: 'call_service',
        domain: 'cronostar',
        service: 'load_profile',
        service_data: {
          profile_name: profileName,
          preset_type: presetType,
          global_prefix: globalPrefix
        },
        return_response: true
      });
      
      return result?.response || {};
    } catch (e) {
      console.error('Failed to load profile detail:', e);
      return { error: e.message };
    }
  }

  async _showProfileDetail(presetType, profileName, globalPrefix) {
    this.editor._dashboardSelectedPreset = presetType;
    this.editor._dashboardSelectedProfile = profileName;
    this.editor._dashboardShowDetailModal = true;
    this.editor.requestUpdate();
    
    // Carica Chart.js se necessario
    await this._ensureChartJs();

    const profileData = await this._loadProfileDetail(presetType, profileName, globalPrefix);
    this.editor._dashboardDetailData = profileData;
    
    this.editor.requestUpdate();
  }

  _closeDetailModal() {
    this.editor._dashboardShowDetailModal = false;
    this.editor._dashboardSelectedPreset = null;
    this.editor._dashboardSelectedProfile = null;
    this.editor._dashboardDetailData = null;
    this.editor.requestUpdate();
  }

  _renderProfileChart(schedule) {
    if (!schedule || !Array.isArray(schedule)) {
      return html`<div style="color: var(--error-color);">Invalid schedule data</div>`;
    }

    const chartData = schedule.map(point => ({
      time: point.time || '00:00',
      value: Number(point.value || 0)
    }));

    // Verifica se Chart.js Ã¨ disponibile
    if (typeof Chart === 'undefined') {
      return html`
        <div class="info-box">
          <p>ðŸ“Š Loading chart library...</p>
        </div>
      `;
    }

    setTimeout(() => {
      const canvas = this.editor.shadowRoot?.querySelector('#profile-detail-chart');
      if (!canvas) {
        console.warn('[DASHBOARD] Canvas element not found');
        return;
      }

      const ctx = canvas.getContext('2d');
      
      // Distruggi grafico esistente
      if (canvas._chart) {
        canvas._chart.destroy();
      }

      try {
      canvas._chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: chartData.map(p => p.time),
          datasets: [{
            label: 'Value',
            data: chartData.map(p => p.value),
              borderColor: '#0ea5e9',
              backgroundColor: 'rgba(14, 165, 233, 0.1)',
            borderWidth: 2,
            tension: 0,
            stepped: 'before',
              fill: true,
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: '#0ea5e9',
              pointBorderColor: '#ffffff',
              pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
              tooltip: {
                enabled: true,
                backgroundColor: 'rgba(42, 48, 66, 0.95)',
                titleColor: '#ffffff',
                bodyColor: '#cbd3e8',
                borderColor: '#0ea5e9',
                borderWidth: 1,
                padding: 12,
                displayColors: false
              }
          },
          scales: {
            x: { 
              display: true,
                title: {
                  display: true,
                  text: 'Time',
                  color: '#cbd3e8',
                  font: { size: 12, weight: 'bold' }
                },
                ticks: {
                  color: '#a0a8c0',
                  maxRotation: 45,
                  minRotation: 0
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.05)'
                }
            },
            y: { 
              display: true,
                title: {
                  display: true,
                  text: 'Value',
                  color: '#cbd3e8',
                  font: { size: 12, weight: 'bold' }
                },
                ticks: {
                  color: '#a0a8c0'
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.08)'
                }
            }
            },
            interaction: {
              intersect: false,
              mode: 'index'
          }
        }
      });

        console.log('[DASHBOARD] Chart created successfully');
      } catch (e) {
        console.error('[DASHBOARD] Error creating chart:', e);
      }
    }, 150);

    return html`
      <div style="position: relative; height: 300px; margin: 20px 0;">
        <canvas id="profile-detail-chart"></canvas>
      </div>
    `;
  }

  _renderDetailModal() {
    if (!this.editor._dashboardShowDetailModal || !this.editor._dashboardDetailData) return html``;

    const schedule = this.editor._dashboardDetailData.schedule || [];
    const meta = this.editor._dashboardDetailData.meta || {};
    const profileName = this.editor._dashboardSelectedProfile;
    const presetType = this.editor._dashboardSelectedPreset;

    return html`
      <div class="modal-overlay" @click=${() => this._closeDetailModal()}>
        <div class="modal-content" @click=${(e) => e.stopPropagation()}>
          <div class="modal-header">
            <h2>ðŸ“Š ${profileName}</h2>
            <button class="close-btn" @click=${() => this._closeDetailModal()}>âœ•</button>
          </div>
          
          <div class="modal-body">
            <div class="info-section">
              <h3>â„¹ï¸ Information</h3>
              <div class="info-grid">
                <div><strong>Preset Type:</strong> ${presetType}</div>
                <div><strong>Global Prefix:</strong> ${meta.global_prefix || 'N/A'}</div>
                <div><strong>Target Entity:</strong> ${meta.target_entity || 'N/A'}</div>
                <div><strong>Schedule Points:</strong> ${schedule.length}</div>
                <div><strong>Updated:</strong> ${this.editor._dashboardDetailData.updated_at || 'N/A'}</div>
              </div>
            </div>

            <div class="chart-section">
              <h3>ðŸ“ˆ Schedule Graph</h3>
              ${this._renderProfileChart(schedule)}
            </div>

            <div class="schedule-section">
              <h3>ðŸ“‹ Schedule Data</h3>
              <div class="schedule-table">
                <table>
                  <thead>
                    <tr>
                      <th>Time</th>
                      <th>Value</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${schedule.map((point, idx) => html`
                      <tr>
                        <td>${point.time}</td>
                        <td>${point.value}</td>
                      </tr>
                    `)}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  _renderProfilesList() {
    if (!this.editor._dashboardProfilesData) return html``;

    const presets = Object.keys(this.editor._dashboardProfilesData);
    
    if (presets.length === 0) {
      return html`
        <div class="info-box">
          <p>â„¹ï¸ No profiles found. Click "New Configuration" to create one.</p>
        </div>
      `;
    }

    return html`
      <div class="profiles-list">
        ${presets.map(presetType => {
          const presetData = this.editor._dashboardProfilesData[presetType];
          const profiles = presetData.profiles || [];
          const globalPrefix = presetData.global_prefix || 'N/A';

          return html`
            <div class="preset-section">
              <div class="preset-header">
                <h3>${this.editor.i18n._t(`presetNames.${presetType}`) || presetType}</h3>
                <div class="preset-actions">
                  <mwc-button 
                    outlined 
                    @click=${() => {
                      this.editor._config = {
                        ...this.editor._config,
                        preset: presetType,
                        global_prefix: globalPrefix
                      };
                      this.editor._selectedPreset = presetType;
                      this.editor._step = 1;
                      this.editor.requestUpdate();
                    }}
                  >
                    âš™ï¸ Reconfigure Preset
                  </mwc-button>
                </div>
              </div>
              
              <div class="preset-info">
                <span><strong>Prefix:</strong> ${globalPrefix}</span>
                <span><strong>Profiles:</strong> ${profiles.length}</span>
              </div>

              <div class="profiles-grid">
                ${profiles.map(profile => html`
                  <div class="profile-card">
                    <div class="profile-name">${profile.name}</div>
                    <div class="profile-info">
                      <span>ðŸ“ Points: ${profile.points || 0}</span>
                      <span>ðŸ• Updated: ${profile.updated_at || 'N/A'}</span>
                    </div>
                    <mwc-button 
                      raised
                      @click=${() => this._showProfileDetail(presetType, profile.name, globalPrefix)}
                    >
                      ðŸ“Š View Details
                    </mwc-button>
                  </div>
                `)}
              </div>
            </div>
          `;
        })}
      </div>
    `;
  }

  render() {
    return html`
      <style>
        .dashboard-container {
          padding: 20px;
        }

        .choice-buttons {
          display: flex;
          gap: 20px;
          margin-bottom: 30px;
          justify-content: center;
        }

        .choice-button {
          flex: 1;
          max-width: 300px;
          padding: 40px 20px;
          background: linear-gradient(145deg, rgba(48, 55, 75, 0.9), rgba(38, 44, 62, 0.9));
          border: 2px solid rgba(255, 255, 255, 0.1);
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-align: center;
        }

        .choice-button:hover {
          transform: translateY(-5px);
          border-color: rgba(14, 165, 233, 0.5);
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .choice-button-icon {
          font-size: 3rem;
          margin-bottom: 10px;
        }

        .choice-button-title {
          font-size: 1.3rem;
          font-weight: 700;
          color: #ffffff;
          margin-bottom: 8px;
        }

        .choice-button-desc {
          font-size: 0.9rem;
          color: #cbd3e8;
        }

        .preset-section {
          background: linear-gradient(145deg, rgba(48, 55, 75, 0.7), rgba(38, 44, 62, 0.7));
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 20px;
          border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .preset-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 15px;
          padding-bottom: 15px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preset-header h3 {
          margin: 0;
          color: #ffffff;
          font-size: 1.4rem;
        }

        .preset-info {
          display: flex;
          gap: 20px;
          margin-bottom: 15px;
          color: #cbd3e8;
          font-size: 0.9rem;
        }

        .profiles-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
          gap: 15px;
        }

        .profile-card {
          background: rgba(28, 33, 48, 0.8);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 8px;
          padding: 15px;
          transition: all 0.3s ease;
        }

        .profile-card:hover {
          transform: translateY(-3px);
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
          border-color: rgba(14, 165, 233, 0.3);
        }

        .profile-name {
          font-weight: 600;
          font-size: 1.1rem;
          color: #ffffff;
          margin-bottom: 8px;
        }

        .profile-info {
          display: flex;
          flex-direction: column;
          gap: 5px;
          margin-bottom: 12px;
          font-size: 0.85rem;
          color: #a0a8c0;
        }

        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          padding: 20px;
          animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        .modal-content {
          background: linear-gradient(135deg, rgba(42, 48, 66, 0.98), rgba(32, 38, 56, 0.98));
          border-radius: 12px;
          max-width: 900px;
          width: 100%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
          border: 1px solid rgba(255, 255, 255, 0.1);
          animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
          from {
            transform: translateY(50px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }

        .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 20px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
          background: linear-gradient(145deg, rgba(48, 55, 75, 0.5), rgba(38, 44, 62, 0.5));
        }

        .modal-header h2 {
          margin: 0;
          color: #ffffff;
        }

        .close-btn {
          background: none;
          border: none;
          font-size: 1.5rem;
          cursor: pointer;
          color: #cbd3e8;
          padding: 5px 10px;
          border-radius: 4px;
          transition: all 0.2s ease;
        }

        .close-btn:hover {
          background: rgba(255, 255, 255, 0.1);
          color: #ffffff;
        }

        .modal-body {
          padding: 20px;
        }

        .info-section, .chart-section, .schedule-section {
          margin-bottom: 25px;
        }

        .info-section h3, .chart-section h3, .schedule-section h3 {
          color: #ffffff;
          margin-bottom: 12px;
          font-size: 1.2rem;
        }

        .info-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 12px;
          color: #cbd3e8;
          font-size: 0.95rem;
          background: rgba(28, 33, 48, 0.5);
          padding: 15px;
          border-radius: 8px;
          border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .schedule-table {
          max-height: 300px;
          overflow-y: auto;
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 8px;
          background: rgba(28, 33, 48, 0.5);
        }

        .schedule-table table {
          width: 100%;
          border-collapse: collapse;
        }

        .schedule-table th {
          background: rgba(28, 33, 48, 0.9);
          color: #ffffff;
          padding: 10px;
          text-align: left;
          position: sticky;
          top: 0;
          z-index: 1;
          border-bottom: 2px solid rgba(14, 165, 233, 0.3);
        }

        .schedule-table td {
          padding: 8px 10px;
          color: #cbd3e8;
          border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .schedule-table tr:hover {
          background: rgba(14, 165, 233, 0.1);
        }

        .info-box {
          background: linear-gradient(145deg,
            rgba(14, 165, 233, 0.15),
            rgba(2, 132, 199, 0.12)
          );
          padding: 18px;
          border-radius: 12px;
          border-left: 4px solid #0ea5e9;
          box-shadow:
            0 6px 20px rgba(14, 165, 233, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          margin: 20px 0;
          color: #bae6fd;
          text-align: center;
        }
      </style>

      <div class="dashboard-container">
        <div class="step-header">${this.editor.i18n._t('headers.step0') || 'Dashboard'}</div>
        <div class="step-description">
          ${this.editor.i18n._t('descriptions.step0') || 'Choose an action: configure a new preset or analyze existing profiles.'}
        </div>

        <div class="choice-buttons">
          <div class="choice-button" @click=${() => { this.editor._step = 1; this.editor.requestUpdate(); }}>
            <div class="choice-button-icon">ðŸ†•</div>
            <div class="choice-button-title">New Configuration</div>
            <div class="choice-button-desc">Configure a new CronoStar preset</div>
          </div>

          <div class="choice-button" @click=${() => this._loadAllProfiles()}>
            <div class="choice-button-icon">ðŸ“Š</div>
            <div class="choice-button-title">Analyze Status</div>
            <div class="choice-button-desc">View existing profiles and configurations</div>
          </div>
        </div>

        ${this.editor._dashboardLoading ? html`
          <div class="info-box">
            <ha-circular-progress active></ha-circular-progress>
            <p>â³ Loading profiles...</p>
          </div>
        ` : this._renderProfilesList()}
      </div>

      ${this._renderDetailModal()}
    `;
  }
}

# --- File: cronostar_card/src/editor/steps/Step1Preset.js ---
# Real size: 5938 bytes, Used: 5938 bytes
import { html } from 'lit';
import { CARD_CONFIG_PRESETS } from '../../config.js';
import { getEffectivePrefix, isValidPrefix } from '../../utils/prefix_utils.js';

export class Step1Preset {
  constructor(editor) {
    this.editor = editor;
  }

  render() {
    // Note: use CARD_CONFIG_PRESETS for titles and keep icons local to this step.
    // EditorI18n currently doesn't provide a `presets.*` structure.
    const list = [
      { id: 'thermostat', icon: 'ðŸŒ¡ï¸', title: 'Thermostat', desc: 'Schedule hourly temperatures for heating/cooling' },
      { id: 'ev_charging', icon: 'ðŸ”Œ', title: 'EV Charging', desc: 'Schedule EV charging power' },
      { id: 'generic_kwh', icon: 'âš¡', title: 'Generic kWh', desc: 'Schedule hourly energy limits (0-7 kWh)' },
      { id: 'generic_temperature', icon: 'ðŸŒ¡ï¸', title: 'Generic Temperature', desc: 'Schedule generic temperatures (0-40Â°C)' },
      { id: 'generic_switch', icon: 'ðŸ’¡', title: 'Switch', desc: 'Schedule device on/off' },
    ];

    const currentPrefix = this.editor._config.global_prefix || getEffectivePrefix(this.editor._config);
    const prefixValid = isValidPrefix(currentPrefix);
    const applyEntity = this.editor._config.target_entity || '';
    const applyExists = !!(applyEntity && this.editor.hass?.states?.[applyEntity]);
    const minimalConfigComplete = prefixValid && !!applyEntity;

    return html`
      <div class="step-content">
        <div class="field-group" style="margin-bottom: 24px;">
          <label class="field-label">1. ${this.editor.i18n._t('fields.target_entity_label')}</label>
          <div class="field-description">${this.editor.i18n._t('fields.target_entity_desc')}</div>
          ${this.editor._isElDefined('ha-entity-picker')
        ? html`<ha-entity-picker
                .hass=${this.editor.hass}
                .value=${applyEntity}
                allow-custom-entity
                @value-changed=${(e) => this.editor._updateConfig('target_entity', e.detail.value)}
              ></ha-entity-picker>`
        : this.editor._renderTextInput('target_entity', applyEntity, 'Entity ID')}
          ${applyExists
        ? html`<div class="hint" style="color: var(--success-color);">âœ“ Entity found</div>`
        : html``}
        </div>

        <div class="field-group" style="margin-bottom: 24px;">
          <label class="field-label">${this.editor.i18n._t('ui.identification_prefix')}</label>
          <div class="field-description">
            ${this.editor.i18n._t('ui.prefix_description')}
          </div>
          ${this.editor._renderTextInput('global_prefix', currentPrefix, `input_number.${currentPrefix}...`)}
        </div>

        <div style="margin-bottom: 12px;">
            ${prefixValid
                ? html`<div style="color: #cbd3e8; font-size: 1rem; margin-bottom: 8px;">${this.editor.i18n._t('step2_msgs.prefix_ok')}</div>`
                : html`<div style="color: var(--error-color); font-size: 1rem; margin-bottom: 8px;">${this.editor.i18n._t('step2_msgs.prefix_bad')}</div>`
            }
        </div>

        <div class="preset-cards">
          ${list.map(preset => html`
            <button
              type="button"
              class="preset-card ${this.editor._selectedPreset === preset.id ? 'selected' : ''}"
              aria-pressed="${this.editor._selectedPreset === preset.id ? 'true' : 'false'}"
              @click=${() => this.selectPresetWithPrefix(preset.id)}
            >
              <div class="preset-icon" aria-hidden="true">${preset.icon}</div>
              <div class="preset-title">${preset.title}</div>
              <div class="preset-description">${preset.desc}</div>
            </button>
          `)}
        </div>

        ${minimalConfigComplete ? html`
          <div class="success-box" style="margin: 20px 0; border: 1px solid var(--success-color); padding: 16px; border-radius: 8px; background: rgba(0, 255, 0, 0.05);">
            <strong>âœ… ${this.editor.i18n._t('ui.minimal_config_complete')}</strong>
            <div style="margin-top: 8px;">
              ${this.editor.i18n._t('ui.minimal_config_info', {
          '{entity}': `input_number.${currentPrefix}current`,
          '{package}': `${currentPrefix}package.yaml`
        })}
            </div>
            <div style="margin-top: 16px; display: flex; gap: 12px; flex-wrap: wrap;">
              <mwc-button raised @click=${() => this._handleEarlySave()}>
                ðŸ’¾ ${this.editor.i18n._t('actions.save_and_create')}
              </mwc-button>
              <mwc-button outlined @click=${() => this.editor.wizard._nextStep()}>
                âš™ï¸ ${this.editor.i18n._t('actions.advanced_config')}
              </mwc-button>
            </div>
          </div>
        ` : html`
          <div class="info-box">
            <strong>â„¹ï¸ ${this.editor.i18n._t('ui.minimal_config_needed')}</strong>
            <p>${this.editor.i18n._t('ui.minimal_config_help')}</p>
          </div>
        `}
      </div>
    `;
  }

  selectPresetWithPrefix(presetId) {
    this.editor._selectedPreset = presetId;
    const tags = {
      'thermostat': 'temp',
      'ev_charging': 'ev',
      'generic_kwh': 'kwh',
      'generic_temperature': 'gentemp',
      'generic_switch': 'switch'
    };
    const newPrefix = `cronostar_${tags[presetId] || 'temp'}_`;

    this.editor._updateConfig('preset', presetId);
    this.editor._updateConfig('global_prefix', newPrefix);

    const presetConfig = CARD_CONFIG_PRESETS[presetId];
    if (presetConfig) {
      Object.assign(this.editor._config, presetConfig);
    }

    this.editor._dispatchConfigChanged(true);
    this.editor.requestUpdate();
  }

  async _handleEarlySave() {
    this.editor._dispatchConfigChanged();
    if (this.editor.hass) {
      try {
        await this.editor._handleFinishClick({ force: true });
      } catch (e) {
        console.error("Early save failed:", e);
      }
    }
  }
}


# --- File: cronostar_card/src/editor/steps/Step2Entities.js ---
# Real size: 6362 bytes, Used: 6362 bytes
import { html } from 'lit';
import { getEffectivePrefix, isValidPrefix } from '../../utils/prefix_utils.js';
import { buildHelpersFilename } from '../../utils/filename_utils.js';

export class Step2Entities {
  constructor(editor) {
    this.editor = editor;
  }

  render() {
    const effectivePrefix = getEffectivePrefix(this.editor._config);
    const prefixValid = isValidPrefix(effectivePrefix);

    const hasPause = !!this.editor._config.pause_entity;
    const pauseVal = this.editor._config.pause_entity || `input_boolean.${effectivePrefix}paused`;

    const hasProfiles = !!this.editor._config.profiles_select_entity;
    const profilesVal = this.editor._config.profiles_select_entity || `input_select.${effectivePrefix}profiles`;

    const packageFilename = buildHelpersFilename(effectivePrefix);
    const helpersDisplayPath = `config/packages/${packageFilename}`;

    // Ensure service handlers are available
    const serviceHandlers = this.editor.serviceHandlers || {};

    return html`
      <div class="step-content">
        <div class="step-header">${this.editor.i18n._t('headers.step2')}</div>
        <div class="step-description">${this.editor.i18n._t('descriptions.step2')}</div>

        <div style="border-bottom: 1px solid var(--divider-color); padding-bottom: 20px; margin-bottom: 20px;">
          <div class="info-box">
            <strong>â„¹ï¸ ${this.editor.i18n._t('ui.automatic_entities_title', 'Automatic Entities')}</strong>
            <p>${this.editor.i18n._t('ui.automatic_entities_desc', {
              '{entity}': `input_number.${effectivePrefix}current`,
              '{package}': packageFilename
            })}</p>
          </div>

          <div class="field-group" style="background: var(--secondary-background-color); padding: 10px; border-radius: 4px; margin-top: 12px;">
            <ha-formfield .label=${this.editor.i18n._t('fields.enable_pause_label')}>
              <ha-switch
                .checked=${hasPause}
                @change=${(e) => this._toggleFeature('pause_entity', e.target.checked, `input_boolean.${effectivePrefix}paused`)}
              ></ha-switch>
            </ha-formfield>
            ${hasPause ? html`
              <div style="margin-top: 8px;">
                ${this.editor._renderTextInput('pause_entity', pauseVal, 'input_boolean.xxx')}
              </div>
            ` : ''}
          </div>

          <div class="field-group" style="background: var(--secondary-background-color); padding: 10px; border-radius: 4px; margin-top: 12px;">
            <ha-formfield .label=${this.editor.i18n._t('fields.enable_profiles_label')}>
              <ha-switch
                .checked=${hasProfiles}
                @change=${(e) => this._toggleFeature('profiles_select_entity', e.target.checked, `input_select.${effectivePrefix}profiles`)}
              ></ha-switch>
            </ha-formfield>
            ${hasProfiles ? html`
              <div style="margin-top: 8px;">
                ${this.editor._renderTextInput('profiles_select_entity', profilesVal, 'input_select.xxx')}
              </div>
            ` : ''}
          </div>
        </div>

        ${this.editor._deepCheckInProgress
          ? html`<div class="info-box" style="text-align: center; padding: 16px;">${this.editor.i18n._t('ui.loading_deep_check_results')}</div>`
          : html`
              <div>
                <div class="field-group">
                  <label class="field-label">${this.editor.i18n._t('fields.package_label')}</label>
                  <div class="field-description">${this.editor.i18n._t('fields.package_desc', { '{path}': helpersDisplayPath })}</div>
                  <div class="action-buttons">
                    ${this.editor._renderButton({
                      label: this.editor.i18n._t('actions.copy_yaml'),
                      click: () => copyToClipboard(
                        this.editor._helpersYaml,
                        this.editor.i18n._t('messages.helpers_yaml_copied') || 'YAML Copied',
                        this.editor.i18n._t('messages.helpers_yaml_error') || 'Copy Failed'
                      )
                    })}
                    ${this.editor._renderButton({
                      label: this.editor.i18n._t('actions.download_file'),
                      click: () => downloadFile(
                        packageFilename,
                        this.editor._helpersYaml,
                        this.editor.i18n._t('messages.helpers_yaml_downloaded') || 'Downloaded',
                        this.editor.i18n._t('messages.file_download_error') || 'Download Failed'
                      )
                    })}
                  </div>

                  <div class="field-group" style="margin-top: 12px;">
                    <ha-formfield .label=${this.editor.i18n._t('actions.show_preview')}>
                      <ha-switch
                        .checked=${this.editor._showHelpersPreview}
                        @change=${(e) => { this.editor._showHelpersPreview = e.target.checked; this.editor.requestUpdate(); }}
                      ></ha-switch>
                    </ha-formfield>
                  </div>
                  ${this.editor._showHelpersPreview ? html`
                    <div class="automation-preview">
                      <pre>${this.editor._helpersYaml}</pre>
                    </div>
                  ` : ''}
                </div>
              </div>
            `}
      </div>
    `;
  }

  _toggleFeature(configKey, isEnabled, defaultValue) {
    if (isEnabled) {
      const current = this.editor._config[configKey];
      if (!current) this.editor._updateConfig(configKey, defaultValue);
    } else {
      this.editor._updateConfig(configKey, null);
    }
  }

  getApplyIncludeDomains() {
    switch (this.editor._selectedPreset) {
      case 'thermostat': return ['climate'];
      case 'ev_charging': return ['number'];
      case 'generic_switch': return ['switch'];
      case 'generic_kwh': return ['number'];
      case 'generic_temperature': return ['number'];
      default: return [];
    }
  }
}

// Helper functions (duplicated locally if not imported from service_handlers to avoid scope issues)
// In a real module system, ensure these are imported correctly at the top
import { copyToClipboard, downloadFile } from '../services/service_handlers.js';


# --- File: cronostar_card/src/editor/steps/Step3Options.js ---
# Real size: 3734 bytes, Used: 3734 bytes
import { html } from 'lit';
import { CARD_CONFIG_PRESETS } from '../../config.js';

export class Step3Options {
  constructor(editor) {
    this.editor = editor;
  }

  render() {
    const presetConfig = CARD_CONFIG_PRESETS[this.editor._config.preset || 'thermostat'] || {};

    return html`
      <div class="step-content">
        <div class="step-header">${this.editor.i18n._t('headers.step3')}</div>
        <div class="step-description">${this.editor.i18n._t('descriptions.step3')}</div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.titlelabel')}</label>
          ${this.editor.renderTextInput('title', this.editor._config.title || presetConfig.title || 'CronoStar Schedule')}
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.yaxislabel')}</label>
          ${this.editor.renderTextInput('y_axis_label', this.editor._config.y_axis_label || presetConfig.yaxislabel)}
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.unitlabel')}</label>
          ${this.editor.renderTextInput('unit_of_measurement', this.editor._config.unit_of_measurement || presetConfig.unitofmeasurement)}
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.minlabel')}</label>
          <div class="field-description">Chart min value.</div>
          ${this.editor.renderTextInput('min_value', this.editor._config.min_value !== undefined ? this.editor._config.min_value : presetConfig.minvalue)}
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.maxlabel')}</label>
          <div class="field-description">Chart max value.</div>
          ${this.editor.renderTextInput('max_value', this.editor._config.max_value !== undefined ? this.editor._config.max_value : presetConfig.maxvalue)}
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.steplabel')}</label>
          ${this.editor.renderTextInput('step_value', this.editor._config.step_value !== undefined ? this.editor._config.step_value : presetConfig.stepvalue)}
        </div>

        <div class="field-group">
          <ha-formfield .label=${this.editor.i18n._t('fields.allowmaxlabel')}>
            <ha-switch .checked=${!!this.editor._config.allow_max_value} @change=${(e) => this.editor._updateConfig('allow_max_value', e.target.checked)}></ha-switch>
          </ha-formfield>
        </div>

        <div class="field-group">
          <label class="field-label">${this.editor.i18n._t('fields.intervallabel')}</label>
          <ha-select
            .value=${this.editor._config.interval_minutes || 60}
            @value-changed=${(e) => {
        const v = e?.detail?.value ?? e?.target?.value;
        if (v === undefined || v === null || v === '') return;
        const n = parseInt(v);
        if (Number.isFinite(n)) this.editor._updateConfig('interval_minutes', n);
      }}
            label="Interval">
            <mwc-list-item value="60">1 hour (24 points)</mwc-list-item>
            <mwc-list-item value="30">30 min (48)</mwc-list-item>
            <mwc-list-item value="15">15 min (96)</mwc-list-item>
          </ha-select>
        </div>

        <div class="field-group">
          <ha-formfield .label=${this.editor.i18n._t('fields.logginglabel')}>
            <ha-switch .checked=${!!this.editor._config.logging_enabled} @change=${(e) => this.editor._updateConfig('logging_enabled', e.target.checked)}></ha-switch>
          </ha-formfield>
        </div>
      </div>
    `;
  }
}


# --- File: cronostar_card/src/editor/steps/Step4Automation.js ---
# Real size: 1414 bytes, Used: 1414 bytes
import { html } from 'lit';

export class Step4Automation {
  constructor(editor) {
    this.editor = editor;
  }

  render() {
    if (!this.editor._config.target_entity) {
      return html`
        <div class="step-content">
          <div class="step-header">${this.editor.i18n._t('headers.step4')}</div>
          <div class="warning-box">
            ${this.editor.i18n._t('step2_msgs.missing_apply')}
          </div>
        </div>
      `;
    }

    return html`
      <div class="step-content">
        <div class="step-header">${this.editor.i18n._t('headers.step4')}</div>
        <div class="step-description">${this.editor.i18n._t('descriptions.step4')}</div>
        <div class="field-group">
          <label class="field-label">Applies to: ${this.editor._config.target_entity}</label>
        </div>
        <pre style="background: var(--secondary-background-color); padding: 12px; border-radius: 4px; overflow: auto; white-space: pre-wrap;">${this.editor._automationYaml}</pre>
        <div class="action-buttons">
          ${this.editor.renderButton(this.editor.i18n._t('actions.copy_yaml'), () => this.editor.serviceHandlers.copyToClipboard(this.editor._automationYaml))}
          ${this.editor.renderButton(this.editor.i18n._t('actions.download_file'), () => this.editor.serviceHandlers.downloadFile('automation.yaml', this.editor._automationYaml))}
        </div>
      </div>
    `;
  }
}


# --- File: cronostar_card/src/editor/steps/Step5Summary.js ---
# Real size: 8149 bytes, Used: 8149 bytes
import { html } from 'lit';
import { getAliasWithPrefix, getEffectivePrefix } from '../../utils/prefix_utils.js';
import { getExpectedAutomationId, buildAutomationFilename } from '../../utils/filename_utils.js';
import { handleSaveAll, runDeepChecks } from '../services/service_handlers.js';

export class Step5Summary {
  constructor(editor) {
    this.editor = editor;
  }

  async handleDeepChecks() {
    try {
      await this.editor._runDeepChecks();
      this.editor.showToast(this.editor.i18n._t('ui.checks_triggered') || 'Deep check triggered');
    } catch (e) {
      this.editor.showToast(e.message);
    }
  }

  async handleSaveAll() {
    try {
      const result = await handleSaveAll(this.editor.hass, this.editor._config, this.editor._deepReport, this.editor._lang);
      this.editor.showToast(result.message);
    } catch (e) {
      this.editor.showToast(e.message);
    }
  }

  render() {
    const hasDeep = !!this.editor.hass?.services?.cronostar?.check_setup;
    const inum = this.editor._deepReport?.input_number;
    const autoInfo = this.editor._deepReport?.automation;
    const effectivePrefix = getEffectivePrefix(this.editor._config);
    const expectedAlias = getAliasWithPrefix(effectivePrefix, this.editor._lang);
    const expectedId = getExpectedAutomationId(effectivePrefix);
    const autoFilename = buildAutomationFilename(effectivePrefix);

    // Verifica configurazione lovelace
    const requiredFields = [
      'preset', 'target_entity', 'global_prefix',
      'min_value', 'max_value', 'step_value'
    ];

    const missingFields = requiredFields.filter(
      field => !this.editor._config[field] && this.editor._config[field] !== 0
    );

    const configComplete = missingFields.length === 0;

    const proposedConfig = {
      type: 'custom:cronostar-card',
      preset: this.editor._config.preset,
      global_prefix: effectivePrefix,
      target_entity: this.editor._config.target_entity,
      pause_entity: this.editor._config.pause_entity,
      profiles_select_entity: this.editor._config.profiles_select_entity,
      min_value: this.editor._config.min_value,
      max_value: this.editor._config.max_value,
      step_value: this.editor._config.step_value,
      unit_of_measurement: this.editor._config.unit_of_measurement,
      y_axis_label: this.editor._config.y_axis_label,
      logging_enabled: this.editor._config.logging_enabled !== false
    };

    return html`
      <div class="step-content">
        <div class="step-header">${this.editor.i18n._t('headers.step5')}</div>
        <div class="step-description">${this.editor.i18n._t('descriptions.step5')}</div>

        <!-- 1. CARD CONFIGURATION SECTION -->
        <div class="field-group" style="border-left: 4px solid #0ea5e9;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <strong style="font-size: 1.1em; color: #fff;">1. Lovelace Card Setup</strong>
            ${configComplete 
              ? html`<span style="background: #22c55e; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold;">READY</span>`
              : html`<span style="background: #ef4444; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold;">INCOMPLETE</span>`
            }
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.9em; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px;">
            <div style="color: #a0a8c0;">Prefix:</div>
            <div style="font-family: monospace; color: #fff;">${proposedConfig.global_prefix}</div>
            
            <div style="color: #a0a8c0;">Target Entity:</div>
            <div style="font-family: monospace; color: #fff;">${this.editor._config.target_entity || 'Not set'}</div>
            
            <div style="color: #a0a8c0;">Preset:</div>
            <div style="font-family: monospace; color: #fff;">${proposedConfig.preset}</div>
          </div>
          
          ${!configComplete ? html`
            <div style="margin-top: 8px; color: #fb923c; font-size: 0.85em;">
              <strong>Missing:</strong> ${missingFields.join(', ')}
            </div>
          ` : ''}
        </div>

        <!-- 2. INFRASTRUCTURE SECTION -->
        <div class="field-group" style="border-left: 4px solid ${inum && inum.found >= inum.expected ? '#22c55e' : '#fb923c'};">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <strong style="font-size: 1.1em; color: #fff;">2. Backend Infrastructure</strong>
            <mwc-button dense .disabled=${this.editor._deepCheckInProgress} @click=${() => this.handleDeepChecks()} style="--mdc-theme-primary: #a0a8c0;">
              ${this.editor._deepCheckInProgress ? html`<ha-circular-progress active size="small"></ha-circular-progress>` : html`<ha-icon icon="mdi:refresh" style="--mdc-icon-size: 18px;"></ha-icon>`}
            </mwc-button>
          </div>

          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; align-items: flex-start; gap: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
              <ha-icon icon="mdi:package-variant-closed" style="color: #0ea5e9;"></ha-icon>
              <div style="flex: 1;">
                <div style="font-size: 0.9em; color: #fff;">YAML Package File</div>
                <div style="font-size: 0.8em; color: #a0a8c0; font-family: monospace;">config/packages/${effectivePrefix}package.yaml</div>
              </div>
              <div style="color: ${inum && inum.found >= inum.expected ? '#22c55e' : '#8891a8'};">
                <ha-icon icon=${inum && inum.found >= inum.expected ? 'mdi:check-circle' : 'mdi:circle-outline'}></ha-icon>
              </div>
            </div>

            <div style="display: flex; align-items: flex-start; gap: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
              <ha-icon icon="mdi:database" style="color: #0ea5e9;"></ha-icon>
              <div style="flex: 1;">
                <div style="font-size: 0.9em; color: #fff;">Profile Data Storage</div>
                <div style="font-size: 0.8em; color: #a0a8c0; font-family: monospace;">config/cronostar/profiles/${effectivePrefix.replace(/_+$/, '')}_data.json</div>
              </div>
              <div style="color: #22c55e;">
                <ha-icon icon="mdi:check-circle"></ha-icon>
              </div>
            </div>
          </div>
        </div>

        <!-- 3. AUTOMATION SECTION -->
        <div class="field-group" style="border-left: 4px solid ${autoInfo && autoInfo.found ? '#22c55e' : '#fb923c'};">
          <strong style="display: block; font-size: 1.1em; color: #fff; margin-bottom: 12px;">3. Automation Logic</strong>
          
          <div style="display: flex; align-items: flex-start; gap: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
            <ha-icon icon="mdi:robot" style="color: #0ea5e9;"></ha-icon>
            <div style="flex: 1;">
              <div style="font-size: 0.9em; color: #fff;">Hourly Scheduler</div>
              <div style="font-size: 0.85em; color: #a0a8c0;">Alias: <strong>${expectedAlias}</strong></div>
              <div style="font-size: 0.8em; color: #a0a8c0; font-family: monospace; margin-top: 4px;">ID: ${expectedId}</div>
            </div>
            <div style="color: ${autoInfo && autoInfo.found ? '#22c55e' : '#8891a8'};">
              <ha-icon icon=${autoInfo && autoInfo.found ? 'mdi:check-circle' : 'mdi:alert-circle-outline'}></ha-icon>
            </div>
          </div>
        </div>

        <!-- SUMMARY ACTION -->
        <div class="info-box" style="border: 1px solid rgba(14, 165, 233, 0.3); background: rgba(14, 165, 233, 0.05);">
          <strong style="color: #fff;">${this.editor.i18n._t('finalmodtitle')}</strong>
          <p style="font-size: 0.9em; margin: 8px 0;">${this.editor.i18n._t('finalmodtext')}</p>
        </div>
      </div>
    `;
  }
}


# --- File: cronostar_card/src/editor/yaml/yaml_generators.js ---
# Real size: 7462 bytes, Used: 7462 bytes
/**
 * YAML generation functions for CronoStar Editor
 */

import { normalizePrefix, getAliasWithPrefix } from '../../utils/prefix_utils.js';

/**
 * Builds the automation YAML with new HA syntax (2025+)
 */
export function buildAutomationYaml(config, style = 'list') {
  const applyEntity = config.target_entity;
  const pauseEntity = config.pause_entity;
  const profilesSelect = config.profiles_select_entity || '';
  const interval = config.interval_minutes || 60;

  const rawPrefix = normalizePrefix(config.global_prefix || 'cronostar_');
  const idBase = rawPrefix.replace(/_+$/, '');
  const id = `${idBase}_apply`;

  const alias = getAliasWithPrefix(rawPrefix, 'en');

  // Determine target entities
  const domain = (applyEntity || '').split('.')[0];
  const isClimate = domain === 'climate';
  const isNumber = domain === 'number';
  const isSwitch = domain === 'switch';

  const lines = [];

  if (style === 'inline') {
    lines.push('automation:');
  }

  const indent = style === 'inline' ? '  ' : '';

  // Header
  lines.push(`${indent}- id: ${id}`);
  lines.push(`${indent}  alias: "${alias}"`);
  lines.push(`${indent}  description: "Generated by CronoStar Editor"`);
  lines.push(`${indent}  mode: restart`);

  // Triggers
  lines.push(`${indent}  triggers:`);

  // Time pattern trigger
  lines.push(`${indent}    - trigger: time_pattern`);
  if (interval === 60) {
    lines.push(`${indent}      minutes: "0"`);
  } else {
    lines.push(`${indent}      minutes: "/${interval}"`);
  }

  // Event trigger (when profiles are loaded)
  lines.push(`${indent}    - trigger: event`);
  lines.push(`${indent}      event_type: cronostar_profiles_loaded`);

  // Conditions
  if (pauseEntity) {
    lines.push(`${indent}  conditions:`);
    lines.push(`${indent}    - condition: state`);
    lines.push(`${indent}      entity_id: ${pauseEntity}`);
    lines.push(`${indent}      state: "off"`);
  } else {
    lines.push(`${indent}  conditions: []`);
  }

  // Actions
  lines.push(`${indent}  actions:`);

  // Variable definitions
  lines.push(`${indent}    - variables:`);
  lines.push(`${indent}        current_hour: "{{ now().hour }}"`);
  lines.push(`${indent}        hour_str: "{{ '%02d' | format(current_hour) }}"`);
  lines.push(`${indent}        target_input: "input_number.${rawPrefix}{{ hour_str }}"`);

  // Determine default value based on domain
  let defaultVal = '20';
  if (isSwitch) defaultVal = '0';
  if (isNumber) defaultVal = '0';

  lines.push(`${indent}        target_value: "{{ states(target_input) | float(${defaultVal}) }}"`);

  // Log action
  lines.push(`${indent}    - action: system_log.write`);
  lines.push(`${indent}      data:`);
  lines.push(`${indent}        message: "[CronoStar] Applying {{ target_value }} to ${applyEntity}"`);
  lines.push(`${indent}        level: info`);

  // Apply action based on domain
  if (isClimate) {
    lines.push(`${indent}    - action: climate.set_temperature`);
    lines.push(`${indent}      target:`);
    lines.push(`${indent}        entity_id: ${applyEntity}`);
    lines.push(`${indent}      data:`);
    lines.push(`${indent}        temperature: "{{ target_value }}"`);
  } else if (isNumber) {
    lines.push(`${indent}    - action: number.set_value`);
    lines.push(`${indent}      target:`);
    lines.push(`${indent}        entity_id: ${applyEntity}`);
    lines.push(`${indent}      data:`);
    lines.push(`${indent}        value: "{{ target_value }}"`);
  } else if (isSwitch) {
    lines.push(`${indent}    - if:`);
    lines.push(`${indent}        - condition: template`);
    lines.push(`${indent}          value_template: "{{ target_value | int > 0 }}"`);
    lines.push(`${indent}      then:`);
    lines.push(`${indent}        - action: switch.turn_on`);
    lines.push(`${indent}          target:`);
    lines.push(`${indent}            entity_id: ${applyEntity}`);
    lines.push(`${indent}      else:`);
    lines.push(`${indent}        - action: switch.turn_off`);
    lines.push(`${indent}          target:`);
    lines.push(`${indent}            entity_id: ${applyEntity}`);
  } else {
    // Generic/Unknown entity fallback
    lines.push(`${indent}    # TODO: Add specific action for ${applyEntity}`);
    lines.push(`${indent}    # - action: domain.service`);
    lines.push(`${indent}    #   target:`);
    lines.push(`${indent}    #     entity_id: ${applyEntity}`);
    lines.push(`${indent}    #   data:`);
    lines.push(`${indent}    #     value: "{{ target_value }}"`);
  }

  return lines.join('\n');
}

/**
 * Builds the helper entities YAML (Package)
 */
export function buildInputNumbersYaml(config, isInline = false) {
  const presetName = getPresetDisplayName(config.preset || 'thermostat');
  const rawPrefix = normalizePrefix(config.global_prefix || 'cronostar_');

  const min = config.min_value ?? 0;
  const max = config.max_value ?? 30;
  const step = config.step_value ?? 0.5;
  const unit = config.unit_of_measurement || '';
  const mode = 'box';

  const pauseEntity = config.pause_entity;
  const profilesEntity = config.profiles_select_entity;
  const applyEntity = config.target_entity;

  const lines = [];
  const isList = false; // Package format usually uses dictionary keys

  // 1. INPUT NUMBERS
  if (isInline) lines.push('input_number:');

  // Current value helper
  const indent = isInline ? '  ' : '';
  lines.push(`${indent}${rawPrefix}current:`);
  lines.push(`${indent}  name: "CronoStar ${presetName} Current"`);
  lines.push(`${indent}  min: ${min}`);
  lines.push(`${indent}  max: ${max}`);
  lines.push(`${indent}  step: ${step}`);
  if (unit) lines.push(`${indent}  unit_of_measurement: "${unit}"`);
  lines.push(`${indent}  mode: ${mode}`);
  lines.push(`${indent}  icon: mdi:chart-timeline`);

  // 2. INPUT BOOLEAN (Pause)
  if (pauseEntity) {
    lines.push('');
    if (isInline) lines.push('input_boolean:');
    // Always enforce correct prefix for the helper key
    const pauseKey = `${rawPrefix}paused`;

    lines.push(`${indent}${pauseKey}:`);
    lines.push(`${indent}  name: "CronoStar ${presetName} Paused"`);
    lines.push(`${indent}  icon: mdi:pause-circle`);
  }

  // 3. INPUT SELECT (Profiles)
  if (profilesEntity) {
    lines.push('');
    if (isInline) lines.push('input_select:');
    // Always enforce correct prefix for the selector key
    const profileKey = `${rawPrefix}profiles`;

    lines.push(`${indent}${profileKey}:`);
    lines.push(`${indent}  name: "CronoStar ${presetName} Profiles"`);
    lines.push(`${indent}  options:`);
    lines.push(`${indent}    - "Default"`);
    lines.push(`${indent}    - "Custom"`);
    lines.push(`${indent}  initial: "Default"`);
    lines.push(`${indent}  icon: mdi:format-list-bulleted`);
  }

  // 4. INPUT TEXT (Target entity) - optional but useful for discovery/debug
  if (applyEntity) {
    lines.push('');
    if (isInline) lines.push('input_text:');
    const key = `${rawPrefix}target_entity`;
    lines.push(`${indent}${key}:`);
    lines.push(`${indent}  name: "CronoStar ${presetName} Target Entity"`);
    lines.push(`${indent}  initial: "${applyEntity}"`);
    lines.push(`${indent}  icon: mdi:target`);
  }

  return lines.join('\n');
}

function getPresetDisplayName(preset) {
  const map = {
    thermostat: 'Thermostat',
    ev_charging: 'EV Charging',
    generic_kwh: 'Generic kWh',
    generic_temperature: 'Generic Temperature',
    generic_switch: 'Generic Switch'
  };
  return map[preset] || preset;
}


# --- File: cronostar_card/src/handlers/keyboard_handler.js ---
# Real size: 15574 bytes, Used: 15574 bytes
/** * Keyboard input handling for CronoStar Card * Supports Alt+Q (insert), Alt+W (delete) */
import { Logger, clamp, roundTo } from '../utils.js';

export class KeyboardHandler {
  constructor(card) {
    this.card = card;
    this.ctrlDown = false;
    this.metaDown = false;
    this.shiftDown = false;
    this.altDown = false;
    this.enabled = true;
    this.containerEl = null;

    this.handleKeydown = this.handleKeydown.bind(this);
    this.handleKeyup = this.handleKeyup.bind(this);
    this.handleFocus = this.handleFocus.bind(this);
    this.handleBlur = this.handleBlur.bind(this);
    this._winKeydown = this._winKeydown.bind(this);
    this._winKeyup = this._winKeyup.bind(this);

    Logger.log('KEYBOARD', '[CronoStar] KeyboardHandler initialized');
  }

  enable() {
    this.enabled = true;
    Logger.log('KEYBOARD', '[CronoStar] Keyboard handling enabled');
  }

  disable() {
    this.enabled = false;
    Logger.log('KEYBOARD', '[CronoStar] Keyboard handling disabled');
  }

  handleFocus(e) {
    Logger.log('KEYBOARD', '[CronoStar] Chart container focused');
    this.enable();
  }

  handleBlur(e) {
    Logger.log('KEYBOARD', '[CronoStar] Chart container blurred');
    this.ctrlDown = false;
    this.metaDown = false;
    this.shiftDown = false;
    this.altDown = false;
  }

  _winKeydown(e) {
    if (!this.enabled) return;
    if (!this.containerEl) return;
    const active = this.card.shadowRoot?.activeElement;
    if (active !== this.containerEl && !(e.ctrlKey || e.metaKey || e.altKey)) return;
    this.handleKeydown(e);
  }

  _winKeyup(e) {
    if (!this.enabled) return;
    if (!this.containerEl) return;
    const active = this.card.shadowRoot?.activeElement;
    if (active !== this.containerEl && !(e.ctrlKey || e.metaKey || e.altKey)) return;
    this.handleKeyup(e);
  }

  focusContainer() {
    try {
      if (this.containerEl && !this.card.isEditorContext()) {
        this.containerEl.focus();
      }
    } catch (e) {
      Logger.warn('KEYBOARD', 'Error focusing container:', e);
    }
  }

  handleKeydown(e) {
    Logger.log('KEYBOARD', `[CronoStar] Keydown: ${e.key}, enabled: ${this.enabled}`);

    // Track modifier keys
    if (e.key === "Control") { this.ctrlDown = true; return; }
    if (e.key === "Meta") { this.metaDown = true; return; }
    if (e.key === "Shift") { this.shiftDown = true; return; }
    if (e.key === "Alt") { this.altDown = true; return; }

    if (!this.enabled) return;

    const isCtrlOrMeta = this.ctrlDown || this.metaDown || e.ctrlKey || e.metaKey;
    const isAlt = this.altDown || e.altKey;

    // Alt+Q: Insert point
    if (isAlt && e.key.toLowerCase() === 'q') {
      e.preventDefault();
      e.stopPropagation();
      this.handleInsertPoint();
      return;
    }

    // Alt+W: Delete point
    if (isAlt && e.key.toLowerCase() === 'w') {
      e.preventDefault();
      e.stopPropagation();
      this.handleDeletePoint();
      return;
    }

    // Ctrl+Enter: Apply now
    if (isCtrlOrMeta && e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      Logger.log('KEYBOARD', '[CronoStar] Apply now triggered via Ctrl+Enter');
      this.card.eventHandlers.handleApplyNow();
      this.focusContainer();
      return;
    }

    // Ctrl+A: Select all
    if (isCtrlOrMeta && e.key.toLowerCase() === 'a') {
      e.preventDefault();
      e.stopPropagation();
      Logger.log('KEYBOARD', '[CronoStar] Select all triggered');
      this.card.selectionManager.selectAll();
      this.card.chartManager?.updatePointStyling(
        this.card.selectionManager.selectedPoint,
        this.card.selectionManager.selectedPoints
      );
      this.card.chartManager?.update();
      this.focusContainer();
      return;
    }

    // Ctrl+S: Save
    if (isCtrlOrMeta && e.key.toLowerCase() === 's') {
      e.preventDefault();
      e.stopPropagation();
      Logger.log('KEYBOARD', '[CronoStar] Save profile triggered via Ctrl+S');
      if (this.card.hasUnsavedChanges && this.card.profileManager.lastLoadedProfile) {
        this.card.profileManager.saveProfile();
      }
      this.focusContainer();
      return;
    }

    // Escape: Clear selection
    if (e.key === "Escape") {
      e.preventDefault();
      this.handleEscape();
      this.focusContainer();
      return;
    }

    const selMgr = this.card.selectionManager;
    const indices = selMgr.getActiveIndices();

    if (indices.length === 0) {
      Logger.log('KEYBOARD', '[CronoStar] No points selected, ignoring arrow keys');
      return;
    }

    // Arrow left/right: Align
    if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
      e.preventDefault();
      this.card.isDragging = true;
      this.card.lastEditAt = Date.now();
      this.handleArrowLeftRight(e, indices);
      this.focusContainer();
      return;
    }

    // Arrow up/down: Adjust value
    if (e.key === "ArrowUp" || e.key === "ArrowDown") {
      e.preventDefault();
      this.card.isDragging = true;
      this.card.lastEditAt = Date.now();
      this.handleArrowUpDown(e, indices);
      this.focusContainer();
      return;
    }
  }

  handleKeyup(e) {
    Logger.log('KEYBOARD', `[CronoStar] Keyup: ${e.key}`);

    if (e.key === "Control") {
      this.ctrlDown = false;
    } else if (e.key === "Meta") {
      this.metaDown = false;
    } else if (e.key === "Shift") {
      this.shiftDown = false;
    } else if (e.key === "Alt") {
      this.altDown = false;
    }

    if (e.key === "ArrowUp" || e.key === "ArrowDown" ||
      e.key === "ArrowLeft" || e.key === "ArrowRight") {
      this.card.isDragging = false;
      this.card.lastEditAt = Date.now();
      this.card.chartManager?.scheduleHideDragValueDisplay(2500);
    }

    this.focusContainer();
  }

  /**
   * Insert point at selected position
   */
  handleInsertPoint() {
    const selMgr = this.card.selectionManager;
    const indices = selMgr.getActiveIndices();

    if (indices.length === 0) {
      Logger.warn('KEYBOARD', 'No point selected for insertion');
      return;
    }

    const anchorIndex = indices[0];
    const scheduleData = this.card.stateManager.scheduleData;

    if (anchorIndex >= scheduleData.length - 1) {
      Logger.warn('KEYBOARD', 'Cannot insert after last point');
      return;
    }

    // Calculate midpoint time
    const currentTime = scheduleData[anchorIndex].time;
    const nextTime = scheduleData[anchorIndex + 1].time;

    const currentMin = this.card.stateManager.timeToMinutes(currentTime);
    const nextMin = this.card.stateManager.timeToMinutes(nextTime);
    const midMin = Math.floor((currentMin + nextMin) / 2);
    const midTime = this.card.stateManager.minutesToTime(midMin);

    // Calculate midpoint value
    const midValue = (scheduleData[anchorIndex].value + scheduleData[anchorIndex + 1].value) / 2;

    // Insert
    const insertedIndex = this.card.stateManager.insertPoint(midTime, midValue);

    // Update chart
    this.card.chartManager.updateData(this.card.stateManager.getData());

    // Select new point
    selMgr.selectIndices([insertedIndex], false);
    this.card.chartManager.updatePointStyling(insertedIndex, [insertedIndex]);

    Logger.log('KEYBOARD', `Inserted point at ${midTime} = ${midValue}`);
  }

  /**
   * Delete selected point
   */
  handleDeletePoint() {
    const selMgr = this.card.selectionManager;
    const indices = selMgr.getActiveIndices();

    if (indices.length === 0) {
      Logger.warn('KEYBOARD', 'No point selected for deletion');
      return;
    }

    const index = indices[0];

    if (this.card.stateManager.removePoint(index)) {
      this.card.chartManager.updateData(this.card.stateManager.getData());
      selMgr.clearSelection();
      Logger.log('KEYBOARD', `Deleted point at index ${index}`);
    }
  }

  handleEscape() {
    const selMgr = this.card.selectionManager;
    selMgr.clearSelection();
    this.card.chartManager?.updatePointStyling(null, []);
    this.card.chartManager?.update();
    Logger.log('KEYBOARD', '[CronoStar] Selection cleared via Escape');
  }

  handleArrowLeftRight(e, indices) {
    const chartMgr = this.card.chartManager;
    const stateMgr = this.card.stateManager;
    if (!chartMgr?.chart?.data?.datasets?.[0]) return;

    const dataset = chartMgr.chart.data.datasets[0];
    const data = dataset.data;
    
    // Alt + Left/Right Arrow: Align Functionality
    if (e.altKey) {
      if (indices.length < 2) return; // Need multiple points to align
      
      const selectedX = indices.map(i => data[i]?.x).filter(x => x !== undefined);
      if (selectedX.length === 0) return;

      // Align Left (Min X) or Right (Max X)
      const targetX = e.key === "ArrowLeft" ? Math.min(...selectedX) : Math.max(...selectedX);
      
      indices.forEach(i => {
         if (i === 0 || i === data.length - 1) return; // Skip anchors
         const p = data[i];
         if (p) p.x = targetX;
      });
      
    } else {
        // Standard Movement
        let minutesStep = 30; // Default requested by user
        if (e.ctrlKey || e.metaKey) minutesStep = 1; // Minimum
        
        // Shift -> Snap to Grid (30 min blocks)
        let snapToGrid = e.shiftKey;

        const dx = e.key === "ArrowLeft" ? -minutesStep : minutesStep;

        // Build time-sorted list
        const allByTime = data
          .map((pt, idx) => ({ idx, x: Math.round(Number(pt?.x ?? 0)) }))
          .sort((a, b) => a.x - b.x);
        const selectedSet = new Set(indices);

        // Determine first and last indices by time
        const firstIdx = allByTime[0]?.idx;
        const lastIdx = allByTime[allByTime.length - 1]?.idx;

        // Compute bounds per selected point
        const boundsMap = new Map();
        indices.forEach((selIdx) => {
          const entryPos = allByTime.findIndex((e2) => e2.idx === selIdx);
          let leftBound = 0;
          let rightBound = 1440;

          // Scan left for nearest non-selected neighbor
          for (let k = entryPos - 1; k >= 0; k--) {
            const e2 = allByTime[k];
            if (!selectedSet.has(e2.idx)) { leftBound = e2.x + 1; break; }
          }

          // Scan right for nearest non-selected neighbor
          for (let k = entryPos + 1; k < allByTime.length; k++) {
            const e2 = allByTime[k];
            if (!selectedSet.has(e2.idx)) { rightBound = e2.x - 1; break; }
          }

          boundsMap.set(selIdx, { left: Math.max(0, leftBound), right: Math.min(1440, rightBound) });
        });

        // Apply movement
        indices.forEach((i) => {
          const p = data[i];
          if (!p) return;
          if (i === firstIdx || i === lastIdx) return; // keep anchors fixed
          
          const b = boundsMap.get(i) || { left: 0, right: 1440 };
          let currentX = Math.round(Number(p.x));
          let desiredX = currentX + dx;
          
          if (snapToGrid) {
              const gridSize = 30;
              // Snap desiredX to nearest grid
              desiredX = Math.round(desiredX / gridSize) * gridSize;
          }

          desiredX = Math.max(b.left, Math.min(b.right, desiredX));
          desiredX = Math.max(0, Math.min(1440, desiredX));
          p.x = desiredX;
        });
    }

    // Persist to state and update chart
    try {
      // Sort data by X to ensure consistency
      // Note: We sort the reference array in place if we want chart to reflect it immediately?
      // Chart.js data is usually an array of objects.
      // We need to re-sort the DATA array because X values changed.
      dataset.data.sort((a, b) => a.x - b.x);
      
      const newData = dataset.data.map((pt) => ({ time: stateMgr.minutesToTime(pt.x), value: Number(pt.y) }));
      stateMgr.setData(newData);
    } catch { }

    chartMgr.updatePointStyling(this.card.selectionManager.selectedPoint, this.card.selectionManager.selectedPoints);
    chartMgr.update('none');
    
    // Show tooltip for the first selected point
    if (indices.length > 0) {
        const firstI = indices[0];
        const p = data[firstI];
        if (p) chartMgr.showDragValueDisplay(p.y, p.x);
    }
  }

  handleArrowUpDown(e, indices) {
    const isSwitch = !!this.card.config?.is_switch_preset;
    let step = isSwitch ? 1 : this.card.config.step_value;
    
    // Modifiers
    if (e.ctrlKey || e.metaKey) {
        step = isSwitch ? 1 : (this.card.config.step_value / 5); // Reduce step
        if (step < 0.1) step = 0.1;
    }
    
    const delta = e.key === "ArrowUp" ? step : -step;

    const selMgr = this.card.selectionManager;
    const stateMgr = this.card.stateManager;
    const chartMgr = this.card.chartManager;

    if (!chartMgr?.chart?.data?.datasets?.[0]) {
      Logger.warn('KEYBOARD', '[CronoStar] Chart not ready');
      return;
    }

    const upperClamp = this.card.config.allow_max_value && !this.card.config.is_switch_preset
      ? this.card.config.max_value + this.card.config.step_value
      : this.card.config.max_value;

    const dataset = chartMgr.chart.data.datasets[0];

    indices.forEach(i => {
      const current = dataset.data[i];
      const currentVal = (typeof current === 'object' && current !== null) ? Number(current.y) : Number(current);
      let val = currentVal + delta;
      
      if (isSwitch) {
        // Preserve ON by only changing on ArrowDown; ArrowUp sets to ON
        val = e.key === 'ArrowUp' ? 1 : 0;
      } else {
        val = clamp(val, this.card.config.min_value, upperClamp);
        
        if (e.shiftKey && !isSwitch) {
             // Snap to integer
             val = Math.round(val);
        } else {
             val = roundTo(val, 1);
        }
      }

      if (typeof dataset.data[i] === 'object' && dataset.data[i] !== null) {
        dataset.data[i].y = val;
      } else {
        dataset.data[i] = val;
      }

      stateMgr.updatePoint(i, val);
    });

    if (this.card.selectedProfile) {
      this.card.profileManager.saveProfile(this.card.selectedProfile)
        .catch(e => Logger.error('KEYBOARD', 'Save failed:', e));
    } else {
      this.card.hasUnsavedChanges = true;
    }

    chartMgr.updatePointStyling(selMgr.selectedPoint, selMgr.selectedPoints);
    chartMgr.update('none');
    
    if (indices.length > 0) {
        const firstI = indices[0];
        const p = dataset.data[firstI];
        if (p) chartMgr.showDragValueDisplay(p.y, p.x);
    }
  }

  attachListeners(element) {
    if (!element) {
      Logger.error('KEYBOARD', '[CronoStar] Cannot attach listeners: element is null');
      return;
    }

    this.detachListeners(element);
    this.containerEl = element;

    element.addEventListener('keydown', this.handleKeydown);
    element.addEventListener('keyup', this.handleKeyup);
    element.addEventListener('focus', this.handleFocus);
    element.addEventListener('blur', this.handleBlur);

    window.addEventListener('keydown', this._winKeydown, true);
    window.addEventListener('keyup', this._winKeyup, true);

    Logger.log('KEYBOARD', '[CronoStar] Keyboard listeners attached');
  }

  detachListeners(element) {
    if (element) {
      element.removeEventListener('keydown', this.handleKeydown);
      element.removeEventListener('keyup', this.handleKeyup);
      element.removeEventListener('focus', this.handleFocus);
      element.removeEventListener('blur', this.handleBlur);
    }

    window.removeEventListener('keydown', this._winKeydown, true);
    window.removeEventListener('keyup', this._winKeyup, true);

    Logger.log('KEYBOARD', '[CronoStar] Keyboard listeners detached');
  }
}  


# --- File: cronostar_card/src/handlers/pointer_handler.js ---
# Real size: 8464 bytes, Used: 8464 bytes
/** * Pointer/touch event handling for area selection * @module pointer-handler */
import { Logger } from '../utils.js';
import { TIMEOUTS } from '../config.js';

export class PointerHandler {
  constructor(card) {
    this.card = card;
    this.isSelecting = false;
    this.pendingSelectStart = null; // start position before threshold exceeded
    this.isGlobalDragging = false;
    this.globalDragStartPx = null;
    this.initialDragValues = new Map();
    this.selStartPx = null;
    this.selEndPx = null;
    this.activePointerId = null;
    this.selectionAdditive = false;
    this.longPressTimeout = null;
    this.dragThresholdPx = 6; // pixels before turning into area selection

    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerCancel = this.onPointerCancel.bind(this);
  }

  /**
   * Get container-relative coordinates
   * @param {PointerEvent} e - Pointer event
   * @returns {Object} {x, y}
   */
  getContainerRelativeCoords(e) {
    const container = this.card.shadowRoot?.querySelector(".chart-container");
    if (!container) return { x: 0, y: 0 };
    const rect = container.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  /**
   * Show selection overlay
   */
  showSelectionOverlay() {
    const el = this.card.shadowRoot?.getElementById('selection-rect');
    if (!el) return;
    el.style.display = 'block';
    this.updateSelectionOverlay();
  }

  /**
   * Hide selection overlay
   */
  hideSelectionOverlay() {
    const el = this.card.shadowRoot?.getElementById('selection-rect');
    if (!el) return;
    el.style.display = 'none';
  }

  /**
   * Update selection overlay position and size
   */
  updateSelectionOverlay() {
    const el = this.card.shadowRoot?.getElementById('selection-rect');
    if (!el || !this.selStartPx || !this.selEndPx) return;

    const minX = Math.min(this.selStartPx.x, this.selEndPx.x);
    const minY = Math.min(this.selStartPx.y, this.selEndPx.y);
    const maxX = Math.max(this.selStartPx.x, this.selEndPx.x);
    const maxY = Math.max(this.selStartPx.y, this.selEndPx.y);

    el.style.left = `${minX}px`;
    el.style.top = `${minY}px`;
    el.style.width = `${Math.max(2, maxX - minX)}px`;
    el.style.height = `${Math.max(2, maxY - minY)}px`;
  }

  /**
   * Handle pointer down event
   */
  onPointerDown(e) {
    try {
      // Ignore pointer selection while a chart drag is in progress
      if (this.card?.isDragging) {
        Logger.log('POINTER', 'onPointerDown ignored: isDragging');
        return;
      }
      // Pointerdown may prevent default in some interactions
      e.stopPropagation();
      // Do not call preventDefault unconditionally: keep compatibility with passive listeners

      const pos = this.getContainerRelativeCoords(e);
      // Defer selection start until movement exceeds threshold
      this.pendingSelectStart = pos;
      this.selStartPx = null;
      this.selEndPx = null;
      this.activePointerId = e.pointerId;
      this.isSelecting = false;
      // Do not mark pointerSelecting yet; allow click selection to proceed if no drag
      this.card.selectionJustCompletedAt = 0;
      this.selectionAdditive = !!(e.ctrlKey || e.metaKey || e.shiftKey);
    } catch (err) {
      Logger.warn('POINTER', 'onPointerDown failed:', err);
    }
  }

  /**
   * Handle pointer move event
   */
  onPointerMove(e) {
    try {
      // Ignore area selection while chart drag is active
      if (this.card?.isDragging) return;
      if (e.pointerId !== this.activePointerId) return;
      const pos = this.getContainerRelativeCoords(e);

      if (!this.isSelecting) {
        // Check if movement exceeded threshold to start area selection
        if (this.pendingSelectStart) {
          const dx = pos.x - this.pendingSelectStart.x;
          const dy = pos.y - this.pendingSelectStart.y;
          if (Math.sqrt(dx * dx + dy * dy) >= this.dragThresholdPx) {
            // Begin selection
            this.isSelecting = true;
            this.card.pointerSelecting = true;
            this.selStartPx = { ...this.pendingSelectStart };
            this.selEndPx = { ...pos };
            this.showSelectionOverlay();
          }
        }
      } else {
        // Update selection rectangle
        this.selEndPx = pos;
        this.updateSelectionOverlay();
      }
    } catch (err) {
      Logger.warn('POINTER', 'onPointerMove failed:', err);
    }
  }

  /**
   * Handle pointer up event
   */
  onPointerUp(e) {
    try {
      // Ignore pointer up selection completion while chart drag is active
      if (this.card?.isDragging) {
        this.activePointerId = null;
        this.pendingSelectStart = null;
        this.selStartPx = null;
        this.selEndPx = null;
        this.card.pointerSelecting = false;
        this.hideSelectionOverlay();
        Logger.log('POINTER', 'onPointerUp ignored: isDragging');
        return;
      }
      if (e.pointerId !== this.activePointerId) return;
      this.activePointerId = null;

      // If no selection started (click), do not interfere; reset state and exit
      if (!this.isSelecting) {
        this.pendingSelectStart = null;
        this.selStartPx = null;
        this.selEndPx = null;
        this.card.pointerSelecting = false;
        this.hideSelectionOverlay();
        return;
      }

      // Complete area selection
      const minX = Math.min(this.selStartPx.x, this.selEndPx.x);
      const minY = Math.min(this.selStartPx.y, this.selEndPx.y);
      const maxX = Math.max(this.selStartPx.x, this.selEndPx.x);
      const maxY = Math.max(this.selStartPx.y, this.selEndPx.y);

      // Compute selected indices from area (delegated to ChartManager)
      const indices = this.card.chartManager?.getIndicesInArea?.(minX, minY, maxX, maxY) || [];

      const selMgr = this.card.selectionManager;
      const chartMgr = this.card.chartManager;

      if (indices.length > 0) {
        if (this.selectionAdditive) {
          const union = [...selMgr.getSelectedPoints()];
          indices.forEach((i) => { if (!union.includes(i)) union.push(i); });
          selMgr.selectIndices(union, true);
        } else {
          selMgr.selectIndices(indices, true);
        }
      } else {
        selMgr.clearSelection();
      }

      chartMgr.updatePointStyling(selMgr.selectedPoint, selMgr.selectedPoints);
      chartMgr.update();
      selMgr.logSelection('area selection completed');

      // Suppress immediate click after selection
      this.card.selectionJustCompletedAt = Date.now();
      this.card.suppressClickUntil = Date.now() + TIMEOUTS.clickSuppression;

      this.hideSelectionOverlay();

      // Reset selection state
      this.isSelecting = false;
      this.card.pointerSelecting = false;
      this.pendingSelectStart = null;
      this.selStartPx = null;
      this.selEndPx = null;
    } catch (err) {
      Logger.warn('POINTER', 'onPointerUp failed:', err);
    }
  }

  /**
   * Handle pointer cancel event
   */
  onPointerCancel() {
    if (!this.isSelecting) return;
    this.isSelecting = false;
    this.activePointerId = null;
    this.card.pointerSelecting = false;
    this.pendingSelectStart = null;
    this.selStartPx = null;
    this.selEndPx = null;
    this.hideSelectionOverlay();
    this.card.suppressClickUntil = Date.now() + 300;
  }

  /**
   * Attach pointer listeners
   * @param {HTMLCanvasElement} canvas - Canvas element
   */
  attachListeners(canvas) {
    canvas.addEventListener('pointerdown', this.onPointerDown, { passive: false, capture: true });
    window.addEventListener('pointermove', this.onPointerMove, { passive: true, capture: true });
    window.addEventListener('pointerup', this.onPointerUp, { passive: true, capture: true });
    window.addEventListener('pointercancel', this.onPointerCancel, { passive: true, capture: true });
  }

  /**
   * Detach pointer listeners
   * @param {HTMLCanvasElement} canvas - Canvas element
   */
  detachListeners(canvas) {
    canvas.removeEventListener('pointerdown', this.onPointerDown, { capture: true });
    window.removeEventListener('pointermove', this.onPointerMove, { capture: true });
    window.removeEventListener('pointerup', this.onPointerUp, { capture: true });
    window.removeEventListener('pointercancel', this.onPointerCancel, { capture: true });
  }
}


# --- File: cronostar_card/src/main.js ---
# Real size: 5131 bytes, Used: 5131 bytes
// main.js â€“ versione pulita con log scoped

console.log('[CronoStar] main.js file loaded by browser');

import { CronoStarCard } from './core/CronoStar.js';
import { CronoStarEditor } from './editor/CronoStarEditor.js';
import { VERSION, CARD_CONFIG_PRESETS } from './config.js';

// Espone preset globali (se servono ad altri script)
globalThis.PRESETS = CARD_CONFIG_PRESETS;

// Espone classi su window (utile per debug / integrazioni esterne)
window.CronoStarCard = CronoStarCard;
window.CronoStarEditor = CronoStarEditor;
///////////
// Register custom element  
customElements.define('cronostar-card', CronoStarCard);  
  
// Add card to custom card picker  
//window.customCards = window.customCards || [];  
//window.customCards.push({  
//  type: 'cronostar-card',  
//  name: 'CronoStar',  
//  description: 'Visual hourly schedule editor with drag-and-drop control',  
//  preview: true,  
//  documentationURL: 'https://github.com/FoliniC/cronostar-card',  
//});  
///////////
console.log(`CRONOSTAR: main.js started (v${VERSION})`);
console.log('CRONOSTAR: window.CronoStarCard assigned:', !!window.CronoStarCard);
console.log('CRONOSTAR: window.CronoStarEditor assigned:', !!window.CronoStarEditor);

// Helper sicuro per registrare in un registry (globale o scoped)
function registerInRegistry(registry, name, constructor, context = 'global') {
  if (!registry) {
    console.warn(`CRONOSTAR: registry nullo per "${name}" in ${context}`);
    return false;
  }

  try {
    if (registry.get && registry.get(name)) {
      console.log(`CRONOSTAR: "${name}" giÃ  registrato in ${context}`);
      return false;
    }
  } catch {
    // se get non esiste/fail, proviamo comunque la define
  }

  try {
    registry.define(name, constructor);
    console.log(`CRONOSTAR: âœ… "${name}" registrato in ${context}`);
    return true;
  } catch (e) {
    const msg = String(e);
    if (!msg.includes('already been used') && !msg.includes('already defined')) {
      console.error(`CRONOSTAR: âŒ Errore registrazione "${name}" in ${context}:`, e);
    } else {
      console.log(`CRONOSTAR: "${name}" risulta giÃ  definito in ${context}`);
    }
    return false;
  }
}

// 1) Registrazione nel registry globale
console.log('CRONOSTAR: Inizio registrazione globale...');
registerInRegistry(customElements, 'cronostar-card', CronoStarCard, 'global');
registerInRegistry(customElements, 'cronostar-card-editor', CronoStarEditor, 'global');

// 2) Supporto per Scoped CustomElementRegistry (usato dal card picker)
if (window.ScopedRegistryHost && window.ScopedRegistryHost.prototype) {
  console.log('CRONOSTAR: ScopedRegistryHost rilevato, patch connectedCallback');

  const origConnected = window.ScopedRegistryHost.prototype.connectedCallback;

  window.ScopedRegistryHost.prototype.connectedCallback = function () {
    try {
      const root = this.renderRoot || this.shadowRoot;
      const registry =
        root?.customElements ||
        this.ownerDocument?.customElements ||
        customElements;

      const ctx =
        this.tagName
          ? `scoped(<${this.tagName.toLowerCase()}>)`
          : 'scoped(unknown-host)';

      console.log(`CRONOSTAR: Scoped host connesso: ${ctx}`);
      if (root && root !== document && root !== document.body) {
        console.log('CRONOSTAR:   renderRoot/shadowRoot presente:', root);
      }

      if (registry && registry !== customElements) {
        console.log('CRONOSTAR:   registry scoped diverso dal globale, registrazione elementi...');
        registerInRegistry(registry, 'cronostar-card', CronoStarCard, `${ctx} / card`);
        registerInRegistry(registry, 'cronostar-card-editor', CronoStarEditor, `${ctx} / editor`);
      } else if (registry === customElements) {
        console.log('CRONOSTAR:   registry coincidente con customElements globale, nessuna azione');
      } else {
        console.warn('CRONOSTAR:   nessun registry valido trovato per host scoped');
      }
    } catch (e) {
      console.error('CRONOSTAR: errore registrazione in scoped registry:', e);
    }

    if (origConnected) {
      return origConnected.apply(this, arguments);
    }
  };
} else {
  console.warn('CRONOSTAR: ScopedRegistryHost non rilevato â€“ niente patch scoped');
}

// 3) Registrazione in window.customCards per apparire nel card picker
window.customCards = window.customCards || [];
if (!window.customCards.some((c) => c.type === 'custom:cronostar-card')) {
  window.customCards.push({
    type: 'cronostar-card',
    name: 'CronoStar Card',
    description: 'Visual hourly schedule editor with drag-and-drop control',
    preview: true,
    documentationURL: 'https://github.com/FoliniC/cronostar_card',
  });
  console.log('CRONOSTAR: âœ… Aggiunto a window.customCards');
} else {
  console.log('CRONOSTAR: GiÃ  presente in window.customCards');
}

// Banner finale
console.log(
  `%c CRONOSTAR %c v${VERSION} LOADED `,
  'color: white; background: #03a9f4; font-weight: 700;',
  'color: #03a9f4; background: white; font-weight: 700;'
);
console.log('CRONOSTAR: Inizializzazione main.js completata âœ…');

export { CronoStarCard, CronoStarEditor };


# --- File: cronostar_card/src/managers/chart_manager.js ---
# Real size: 26543 bytes, Used: 26543 bytes
/** Chart Manager for CronoStar Card with Dynamic Points */
import Chart from 'chart.js/auto';
import dragDataPlugin from 'chartjs-plugin-dragdata';
import zoomPlugin from 'chartjs-plugin-zoom';
import { COLORS } from '../config.js';
import { Logger } from '../utils.js';

Chart.register(dragDataPlugin, zoomPlugin);

export class ChartManager {
  constructor(card) {
    this.card = card;
    this.chart = null;
    this._initialized = false;
    this.lastMousePosition = null;
    this._dragDisplayTimer = null;
    this._hoverHideTimer = null;

    // Manual horizontal drag state
    this._hDragActive = false;
    this._hDragPointerId = null;
    this._hDragStartClient = null;
    this._hDragStartedAt = 0;
    this._boundOnWindowPointerMove = this._onWindowPointerMove.bind(this);
    this._boundOnWindowPointerUp = this._onWindowPointerUp.bind(this);
  }

  // Ensure switch preset loads a profile if schedule is empty
  _ensureSwitchProfileLoaded(retries = 5) {
    try {
      const isSwitch = !!(this.card.config?.is_switch_preset || this.card.selectedPreset?.includes('switch'));
      const hasNoData = !Array.isArray(this.card.stateManager?.scheduleData) || this.card.stateManager.scheduleData.length === 0;
      if (!isSwitch || !hasNoData) return;
      if (!this.card.hass || !this.card.profileManager?.loadProfile) {
        if (retries > 0) setTimeout(() => this._ensureSwitchProfileLoaded(retries - 1), 250);
        return;
      }
      const candidates = [
        this.card.selectedProfile,
        this.card.profileManager.lastLoadedProfile,
        'Default',
        'Comfort'
      ].filter(Boolean);
      if (!candidates.length) return;
      const tryNext = (idx = 0) => {
        const name = candidates[idx];
        if (!name) return;
        Logger.load(`[CronoStar] Auto-loading switch profile '${name}'`);
        this.card.profileManager.loadProfile(name)
          .then(() => Logger.load(`[CronoStar] Loaded profile '${name}' for switch`))
          .catch((e) => {
            Logger.warn('LOAD', `[CronoStar] load_profile failed for '${name}': ${e?.message || e}`);
            if (idx + 1 < candidates.length) tryNext(idx + 1);
            else if (retries > 0) setTimeout(() => this._ensureSwitchProfileLoaded(retries - 1), 500);
          });
      };
      tryNext(0);
    } catch { }
  }

  _onWindowPointerMove(e) {
    try {
      if (!this._hDragActive) return;
      if (this._hDragPointerId !== null && e.pointerId !== this._hDragPointerId) return;
      if (!this.chart) return;
      if (this.card.pointerSelecting) return;

      const dsIndex = this.dragDatasetIndex;
      const activeIndex = this.dragActiveIndex;
      if (dsIndex === null || dsIndex === undefined) return;

      const dataset = this.chart.data.datasets[dsIndex];
      const xScale = this.chart.scales?.x;
      if (!dataset || !xScale) return;

      const allByTime = dataset.data
        .map((pt, idx) => ({ idx, x: Math.round(Number(pt?.x ?? 0)) }))
        .sort((a, b) => a.x - b.x);

      const firstIdx = allByTime[0]?.idx;
      const lastIdx = allByTime[allByTime.length - 1]?.idx;

      const canvasRect = this.chart.canvas.getBoundingClientRect();
      const pxX = e.clientX - canvasRect.left;
      let minutes = xScale.getValueForPixel(pxX);
      if (!Number.isFinite(minutes)) return;

      let snapMinutes = Number(this.card.config?.keyboard_time_step_minutes) || 5;
      
      if (e.shiftKey) snapMinutes = 30; // Snap to grid
      else if (e.ctrlKey || e.metaKey) snapMinutes = 1; // Minimum movement
      else if (e.altKey) snapMinutes = 30; // Legacy alt behavior, but shift is now grid. Keep for consistency or override? User didn't specify Alt for drag snap, but Alt for Alignment. Let's keep 30 or standard. 
      // Actually user said: "Se viene premuto il tasto shift fai un 'snap to grid'".
      // And "Se viene premuto il tasto CTRL riduci il movimento".
      // I will prioritize Shift > Ctrl > Default.

      minutes = Math.round(minutes / snapMinutes) * snapMinutes;

      const boundsActive = this.dragBounds?.[activeIndex] || { left: 0, right: 1440 };
      const clampedActive = Math.max(boundsActive.left, Math.min(boundsActive.right, minutes));
      const dxMinutes = clampedActive - Math.round(Number(this.initialSelectedX?.[activeIndex] ?? this.dragStartX ?? 0));

      const pointsToMove = Array.isArray(this.dragSelectedPoints) ? this.dragSelectedPoints : [activeIndex];

      pointsToMove.forEach((i) => {
        const p = dataset.data[i];
        if (!p || i === firstIdx || i === lastIdx) return;

        const origX = this.initialSelectedX?.[i];
        if (origX === undefined) return;
        const bounds = this.dragBounds?.[i] || { left: 0, right: 1440 };
        let newX = Math.max(bounds.left, Math.min(bounds.right, Math.round(origX + dxMinutes)));
        p.x = Math.max(0, Math.min(1440, newX));
      });

      this.chart.update('none');
      
      const activeX = dataset.data[activeIndex]?.x;
      const activeY = dataset.data[activeIndex]?.y;
      this.showDragValueDisplay(activeY, activeX);
    } catch (err) { }
  }

  _onWindowPointerUp(e) {
    try {
      if (!this._hDragActive) return;
      this._hDragActive = false;
      window.removeEventListener('pointermove', this._boundOnWindowPointerMove, true);
      window.removeEventListener('pointerup', this._boundOnWindowPointerUp, true);

      const dsIndex = this.dragDatasetIndex ?? 0;
      const dataset = this.chart?.data?.datasets?.[dsIndex];
      if (dataset?.data?.length) {
        // Sort by time to ensure data consistency
        const sortedData = [...dataset.data].sort((a, b) => a.x - b.x);
        
        const newData = sortedData.map((p) => ({
          time: this.card.stateManager.minutesToTime(Math.max(0, Math.min(1440, Number(p.x)))),
          value: p.y
        }));
        this.card.stateManager.setData(newData);
        this.card.hasUnsavedChanges = true;
      }
      this.card.isDragging = false;
      this.scheduleHideDragValueDisplay(500);
    } catch { }
  }

  isInitialized() { return this._initialized && !!this.chart; }
  getChart() { return this.chart; }
  _getXTitle() { return this.card.localizationManager?.localize(this.card.language, 'ui.hours_label') || 'Hours'; }
  _getYTitle() { return this.card.config?.y_axis_label || this.card.localizationManager?.localize(this.card.language, 'ui.temperature_label') || 'Value'; }

  update(mode = 'none') {
    if (!this.chart) return;
    try { this.chart.update(mode); } catch { try { this.chart.update(); } catch { } }
  }

  showDragValueDisplay(value, minutes) {
    try {
      const el = this.card.shadowRoot?.getElementById('drag-value-display');
      if (!el || !this.chart || !this.chart.canvas?.isConnected) return;
      
      const valRaw = Number.isFinite(Number(value)) ? Number(value) : 0;
      const xRaw = Number.isFinite(Number(minutes)) ? Number(minutes) : 0;

      // Use chart scales for precise, real-time positioning
      const xScale = this.chart.scales?.x;
      const yScale = this.chart.scales?.y;
      if (!xScale || !yScale) return;

      const pixelX = xScale.getPixelForValue(xRaw);
      const pixelY = yScale.getPixelForValue(valRaw);

      const container = this.card.shadowRoot?.querySelector('.chart-container');
      if (!container) return;

      const canvasRect = this.chart.canvas.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      const isSwitch = !!(this.card.config?.is_switch_preset || this.card.selectedPreset?.includes('switch'));

      let text = '';
      if (isSwitch) {
        text = (valRaw >= 0.5) ? 'On' : 'Off';
      } else {
        text = valRaw.toFixed(1);
      }

      text = `${this.card.stateManager.minutesToTime(xRaw)} â€¢ ${text}`;

      el.textContent = text;
      // Calculate position relative to container
      const leftPos = pixelX + (canvasRect.left - containerRect.left);
      const topPos = pixelY + (canvasRect.top - containerRect.top);

      el.style.left = `${Math.round(leftPos + 8)}px`;
      el.style.top = `${Math.round(topPos - 28)}px`;
      el.style.display = 'block';
    } catch (e) { }
  }

  scheduleHideDragValueDisplay(ms = 2000) {
    if (this._dragDisplayTimer) clearTimeout(this._dragDisplayTimer);
    this._dragDisplayTimer = setTimeout(() => {
      const el = this.card.shadowRoot?.getElementById('drag-value-display');
      if (el) el.style.display = 'none';
    }, ms);
  }

  getIndicesInArea(minX, minY, maxX, maxY) {
    if (!this.chart) return [];
    const meta = this.chart.getDatasetMeta(0);
    const points = meta?.data || [];
    const container = this.card.shadowRoot?.querySelector('.chart-container');
    const canvasRect = this.chart.canvas.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const ox = canvasRect.left - containerRect.left;
    const oy = canvasRect.top - containerRect.top;

    return points.map((pt, i) => {
      const pos = typeof pt.tooltipPosition === 'function' ? pt.tooltipPosition() : { x: pt.x, y: pt.y };
      const x = pos.x + ox; const y = pos.y + oy;
      return (x >= Math.min(minX, maxX) && x <= Math.max(minX, maxX) && y >= Math.min(minY, maxY) && y <= Math.max(minY, maxY)) ? i : -1;
    }).filter(i => i !== -1);
  }

  _getCanvasRelativePosition(evt) {
    const native = evt?.native || evt;
    const clientX = native.touches?.[0]?.clientX ?? native.changedTouches?.[0]?.clientX ?? native.clientX;
    const clientY = native.touches?.[0]?.clientY ?? native.changedTouches?.[0]?.clientY ?? native.clientY;
    const rect = this.chart.canvas.getBoundingClientRect();
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  _interpolateValueAtMinutes(minutes) {
    const ds = this.chart?.data?.datasets?.[0]?.data || [];
    if (!ds.length) return null;
    const data = [...ds].sort((a, b) => a.x - b.x);
    if (minutes <= data[0].x) return data[0].y;
    if (minutes >= data[data.length - 1].x) return data[data.length - 1].y;
    for (let i = 0; i < data.length - 1; i++) {
      if (minutes >= data[i].x && minutes <= data[i + 1].x) {
        const t = (minutes - data[i].x) / (data[i + 1].x - data[i].x || 1);
        return data[i].y + (data[i + 1].y - data[i].y) * t;
      }
    }
    return data[data.length - 1].y;
  }

  _showHoverInfo(evt) {
    try {
      if (this.card.isDragging || this.card.pointerSelecting) { this._hideHoverInfo(); return; }
      const el = this.card.shadowRoot?.getElementById('hover-value-display');
      if (!el || !this.chart || !this.chart.canvas?.isConnected) return;
      const pos = this._getCanvasRelativePosition(evt);
      const { x, y } = this.chart.scales;
      if (!x || !y) return;
      if (pos.x < x.left || pos.x > x.right || pos.y < y.top || pos.y > y.bottom) { this._hideHoverInfo(); return; }
      const minutes = x.getValueForPixel(pos.x);
      const val = this._interpolateValueAtMinutes(minutes);
      if (val === null) return;
      el.textContent = `${this.card.stateManager.minutesToTime(minutes)} â€¢ ${val.toFixed(1)}`;
      const cRect = this.chart.canvas.getBoundingClientRect();
      const container = this.card.shadowRoot.querySelector('.chart-container');
      if (!container) return;
      const contRect = container.getBoundingClientRect();
      el.style.left = `${Math.round(pos.x + (cRect.left - contRect.left) + 10)}px`;
      el.style.top = `${Math.round(pos.y + (cRect.top - contRect.top) - 24)}px`;
      el.style.display = 'block';
      if (this._hoverHideTimer) clearTimeout(this._hoverHideTimer);
      this._hoverHideTimer = setTimeout(() => this._hideHoverInfo(), 1500);
    } catch { }
  }

  _hideHoverInfo() {
    const el = this.card.shadowRoot?.getElementById('hover-value-display');
    if (el) el.style.display = 'none';
  }

  initChart(canvas) {
    if (!canvas) return false;
    if (!canvas.isConnected) { requestAnimationFrame(() => this.initChart(canvas)); return false; }
    this.destroy();

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      
      // Alt + Right Click: Align to Right
      if (e.altKey) {
        const selMgr = this.card.selectionManager;
        const indices = selMgr.getActiveIndices();
        if (indices.length > 1) {
             const data = this.chart.data.datasets[0].data;
             const selectedX = indices.map(i => data[i]?.x).filter(x => x !== undefined);
             const maxX = Math.max(...selectedX);
             indices.forEach(i => {
                 if (i === 0 || i === data.length - 1) return; // Skip anchors
                 data[i].x = maxX;
             });
             // Sort
             this.chart.data.datasets[0].data.sort((a, b) => a.x - b.x);
             
             this.chart.update('none');
             this.card.stateManager.setData(this.chart.data.datasets[0].data.map(p => ({ time: this.card.stateManager.minutesToTime(p.x), value: p.y })));
             return; // Skip point deletion
        }
      }

      const points = this.chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
      if (points.length) {
        this.card.stateManager.removePoint(points[0].index);
        this.updateData(this.card.stateManager.getData());
        this.card.requestUpdate();
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (!this.chart || this.card.pointerSelecting || e.button !== 0) return;
      const points = this.chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
      if (!points.length) return;
      const idx = points[0].index;
      const selMgr = this.card.selectionManager;
      if (selMgr && !selMgr.isSelected(idx)) {
        selMgr.selectPoint(idx);
        this.updatePointStyling(selMgr.selectedPoint, selMgr.selectedPoints);
        this.update('none');
      }
      this.dragBounds = {}; this.initialSelectedX = {};
      const dataset = this.chart.data.datasets[0];
      const allByTime = dataset.data.map((pt, i) => ({ i, x: Math.round(pt.x) })).sort((a, b) => a.x - b.x);
      const selected = selMgr.getSelectedPoints();
      const selectedSet = new Set(selected);
      selected.forEach(sIdx => {
        const pos = allByTime.findIndex(e => e.i === sIdx);
        let l = 0, r = 1440;
        for (let k = pos - 1; k >= 0; k--) { if (!selectedSet.has(allByTime[k].i)) { l = allByTime[k].x + 1; break; } }
        for (let k = pos + 1; k < allByTime.length; k++) { if (!selectedSet.has(allByTime[k].i)) { r = allByTime[k].x - 1; break; } }
        const isEdge = sIdx === allByTime[0].i || sIdx === allByTime[allByTime.length - 1].i;
        const curX = Math.round(dataset.data[sIdx].x);
        this.dragBounds[sIdx] = { left: isEdge ? curX : l, right: isEdge ? curX : r };
        this.initialSelectedX[sIdx] = dataset.data[sIdx].x;
      });
      this.dragDatasetIndex = 0; this.dragActiveIndex = idx; this.dragStartX = dataset.data[idx].x;
      this._hDragActive = true; this._hDragPointerId = e.pointerId;
      this.card.isDragging = true;
      window.addEventListener('pointermove', this._boundOnWindowPointerMove, { capture: true, passive: true });
      window.addEventListener('pointerup', this._boundOnWindowPointerUp, { capture: true, passive: true });
    }, { passive: true, capture: true });
    
    // Add hover listeners
    this._hoverHandler = (e) => this._showHoverInfo(e);
    this._hoverOutHandler = () => this._hideHoverInfo();
    canvas.addEventListener('pointermove', this._hoverHandler, { passive: true });
    canvas.addEventListener('pointerout', this._hoverOutHandler, { passive: true });
    canvas.addEventListener('pointerleave', this._hoverOutHandler, { passive: true });

    const isSwitch = !!(this.card.config?.is_switch_preset || this.card.selectedPreset?.includes('switch'));
    const step = isSwitch ? 1 : (Number(this.card.config?.step_value) || 0.5);
    const minV = isSwitch ? 0 : Number(this.card.config?.min_value ?? 0);
    const maxV = isSwitch ? 1 : Number(this.card.config?.max_value ?? 100);

    // Stabilize initial layout for switch preset by enforcing a fixed container height at first paint
    try {
      const container = this.card.shadowRoot?.querySelector('.chart-container');
      if (container && isSwitch) {
        const fixedPx = Number(this.card.config?.initial_chart_height_px) || 320;
        if (!container.style.height) {
          container.style.height = `${fixedPx}px`;
          container.setAttribute('data-initial-fixed-height', String(fixedPx));
        }
      }
    } catch { }

    if (isSwitch) Logger.log('CHART', '[Switch] Initializing with stepped line and On/Off labels');

    const currentTimeIndicatorPlugin = {
      id: 'currentTimeIndicator',
      afterDatasetsDraw: (chart) => {
        const { ctx, chartArea, scales } = chart;
        if (!ctx || !chartArea || !scales?.x) return;
        const xPos = scales.x.getPixelForValue(new Date().getHours() * 60 + new Date().getMinutes());
        if (xPos < chartArea.left || xPos > chartArea.right) return;
        ctx.save();
        ctx.setLineDash([5, 5]); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255, 82, 82, 0.5)';
        ctx.beginPath(); ctx.moveTo(xPos, chartArea.top); ctx.lineTo(xPos, chartArea.bottom); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#ff5252';
        ctx.beginPath(); ctx.moveTo(xPos, chartArea.top); ctx.lineTo(xPos - 6, chartArea.top - 10); ctx.lineTo(xPos + 6, chartArea.top - 10); ctx.fill();
        ctx.restore();
      }
    };

    // If switch preset and no data loaded yet, attempt to auto-load the current profile
    // Defer profile load until after chart is initialized (ProfileManager updates chart)

    this.chart = new Chart(canvas.getContext('2d'), {
      type: 'line',
      data: {
        datasets: [{
          data: (Array.isArray(this.card.stateManager.scheduleData) && this.card.stateManager.scheduleData.length)
            ? this.card.stateManager.scheduleData.map(p => ({ x: this.card.stateManager.timeToMinutes(p.time), y: Number(p.value) }))
            : [{ x: 0, y: isSwitch ? 0 : minV }, { x: 1439, y: isSwitch ? 0 : minV }],
          borderColor: COLORS.primary, backgroundColor: 'rgba(3, 169, 244, 0.1)',
          pointRadius: 6, borderWidth: 2, tension: 0,
          stepped: isSwitch ? 'before' : false, fill: true, clip: false,
          spanGaps: true
        }]
      },
      plugins: [currentTimeIndicatorPlugin],
      options: {
        responsive: true, maintainAspectRatio: false, animation: false,
        // Debounce internal resize to avoid jitter on initial render
        resizeDelay: 200,
        layout: { padding: { top: 15, right: 10, bottom: 25, left: 10 } },
        onClick: (evt) => {
          if (!this.chart || this.card.pointerSelecting || Date.now() < (this.card.suppressClickUntil || 0)) return;
          
          // Alt + Left Click: Align to Left
          if (evt.altKey) {
             const selMgr = this.card.selectionManager;
             const indices = selMgr.getActiveIndices();
             if (indices.length > 1) {
                 const data = this.chart.data.datasets[0].data;
                 const selectedX = indices.map(i => data[i]?.x).filter(x => x !== undefined);
                 const minX = Math.min(...selectedX);
                 indices.forEach(i => {
                     if (i === 0 || i === data.length - 1) return; // Skip anchors
                     data[i].x = minX;
                 });
                 // Sort
                 this.chart.data.datasets[0].data.sort((a, b) => a.x - b.x);
                 
                 this.chart.update('none');
                 this.card.stateManager.setData(this.chart.data.datasets[0].data.map(p => ({ time: this.card.stateManager.minutesToTime(p.x), value: p.y })));
                 return;
             }
          }

          const pos = this._getCanvasRelativePosition(evt);
          const points = this.chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
          if (points.length) {
            const idx = points[0].index;
            if (isSwitch) {
              const p = this.chart.data.datasets[0].data[idx];
              p.y = (p.y >= 0.5) ? 0 : 1;
              this.chart.update('none');
              this.card.stateManager.setData(this.chart.data.datasets[0].data.map(pt => ({ time: this.card.stateManager.minutesToTime(pt.x), value: pt.y })));
              this.card.hasUnsavedChanges = true; this.card.requestUpdate();
              return;
            }
            this._handleChartClick(evt, points); return;
          }
          const { x, y } = this.chart.scales;
          if (!x || !y) return;
          if (pos.x < x.left || pos.x > x.right || pos.y < y.top || pos.y > y.bottom) return;
          const valY = Math.max(minV, Math.min(maxV, Math.round(y.getValueForPixel(pos.y) / step) * step));
          const idxNew = this.card.stateManager.insertPoint(this.card.stateManager.minutesToTime(x.getValueForPixel(pos.x)), isSwitch ? (valY >= 0.5 ? 1 : 0) : valY);
          this.updateData(this.card.stateManager.getData());
          this.card.selectionManager?.selectPoint(idxNew);
          this.updatePointStyling(idxNew, [idxNew]); this.update('none'); this.card.requestUpdate();
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          dragData: {
            round: step, showTooltip: false, dragX: false, dragY: !isSwitch,
            onDragStart: (e, ds, i, v) => {
              if (!this.chart || this.card.pointerSelecting || isSwitch) return false;
              // Handle case where v is the data object
              const val = (typeof v === 'object' && v !== null && v.y !== undefined) ? v.y : v;
              this.dragStartValue = Number(val); 
              this.initialSelectedValues = {};
              this.dragSelectedPoints = this.card.selectionManager.getSelectedPoints();
              this.dragSelectedPoints.forEach(idx => { this.initialSelectedValues[idx] = this.chart.data.datasets[0].data[idx].y; });
              this.card.isDragging = true; return true;
            },
            onDrag: (e, ds, i, v) => {
              const val = (typeof v === 'object' && v !== null && v.y !== undefined) ? v.y : v;
              // Check for NaN and fallback
              let safeVal = Number(val);
              if (!Number.isFinite(safeVal)) {
                  // If input value is invalid, ignore this drag event to prevent data corruption
                  return;
              }

              const diff = safeVal - this.dragStartValue;
              
              this.dragSelectedPoints.forEach(idx => {
                if (this.initialSelectedValues[idx] === undefined) return;
                let newVal = Math.max(minV, Math.min(maxV, Math.round((this.initialSelectedValues[idx] + diff) / step) * step));
                this.chart.data.datasets[0].data[idx].y = newVal;
              });
              this.chart.update('none');
              
              const p = this.chart.data.datasets[0].data[i];
              if (p) {
                  this.showDragValueDisplay(p.y, p.x);
              }
            },
            onDragEnd: () => {
              this.card.isDragging = false;
              this.scheduleHideDragValueDisplay(500);
              this.card.stateManager.setData(this.chart.data.datasets[0].data.map(p => ({ time: this.card.stateManager.minutesToTime(p.x), value: p.y })));
              this.card.hasUnsavedChanges = true; this.card.requestUpdate();
            }
          }
        },
        scales: {
          x: { 
            type: 'linear', min: 0, max: 1440, 
            ticks: { 
              stepSize: 120, 
              maxRotation: 0, 
              autoSkip: false,
              includeBounds: true, // Ensure 00:00 and 23:59 are shown
              callback: (v, index, ticks) => {
                 // Force 23:59 display if needed or stick to standard
                 if (v === 1439 || v === 1440) return '23:59';
                 return this.card.stateManager.minutesToTime(v); 
              }
            } 
          },
          y: { min: isSwitch ? -0.1 : minV, max: isSwitch ? 1.1 : maxV, ticks: { stepSize: isSwitch ? 1 : undefined, callback: v => isSwitch ? (v === 0 ? 'Off' : (v === 1 ? 'On' : '')) : v } }
        }
      }
    });
    this._initialized = true;
    // Attempt to load switch profile if needed BEFORE returning
    this._ensureSwitchProfileLoaded();
    return true;
  }

  _handleChartClick(evt, points) {
    const idx = points[0].index;
    if (evt.ctrlKey || evt.metaKey) this.card.selectionManager.togglePoint(idx);
    else if (evt.shiftKey) this.card.selectionManager.selectRange(idx);
    else this.card.selectionManager.selectPoint(idx);
  }

  updateData(newData) {
    if (!this.chart) return;
    this.chart.data.datasets[0].data = newData.map(p => ({ x: this.card.stateManager.timeToMinutes(p.time), y: Number(p.value) }));
    this.chart.update('none');
  }

  recreateChartOptions() {
    if (!this.chart) return;
    const isSwitch = !!(this.card.config?.is_switch_preset || this.card.selectedPreset?.includes('switch'));
    if (isSwitch) Logger.log('CHART', '[Switch] Re-applying stepped options');
    const y = this.chart.options.scales.y;
    y.min = isSwitch ? -0.05 : Number(this.card.config.min_value ?? 0);
    y.max = isSwitch ? 1.05 : Number(this.card.config.max_value ?? 100);
    this.chart.data.datasets[0].stepped = isSwitch ? 'before' : false;
    this.chart.data.datasets[0].tension = 0;
    this.chart.update('none');
  }

  updatePointStyling(anchor, selected) {
    if (!this.chart) return;
    const ds = this.chart.data.datasets[0];
    ds.pointBackgroundColor = ds.data.map((_, i) => i === anchor ? COLORS.anchor : (selected.includes(i) ? COLORS.selected : COLORS.primary));
    ds.pointBorderColor = ds.pointBackgroundColor;
  }

  destroy() {
    if (this.chart) {
      const canvas = this.chart.canvas;
      if (canvas && this._hoverHandler && this._hoverOutHandler) {
        canvas.removeEventListener('pointermove', this._hoverHandler);
        canvas.removeEventListener('pointerout', this._hoverOutHandler);
        canvas.removeEventListener('pointerleave', this._hoverOutHandler);
      }
      this._hoverHandler = null;
      this._hoverOutHandler = null;
      try { this.chart.destroy(); } catch { }
      this.chart = null;
    }
    this._initialized = false;
  }
}


# --- File: cronostar_card/src/managers/localization_manager.js ---
# Real size: 8006 bytes, Used: 8006 bytes
/** Localization Manager for CronoStar Card */
import { Logger } from '../utils.js';

const TRANSLATIONS = {
  en: {
    ui: {
      title: "CronoStar",
      loading: "Loadingâ€¦",
      waiting_ha_start: "Waiting for Home Assistant startupâ€¦",
      waiting_profile_restore: "Restoring profilesâ€¦",
      startup_watermark: "Waiting for backend",
      anomalous_operation_warning: "Warning: some entities are missing or unavailable.",
      anomalous_operation_watermark: "Entities missing",
      create_missing_entities_message: "Missing entities for this preset. Please create the following input_number entities:",
      pause: "Pause",
      profile: "Profile",
      unsaved_changes: "Unsaved changes",
      reset: "Reset",
      apply_now_error: "Apply Now error",
      apply_now_success: "Applied successfully for hour {hour}",
      time_label: "Time",
      hours_label: "Hours",
      temperature_label: "Temperature"
    },
    menu: {
      language: "Language",
      select_all: "Select all",
      align_left: "Align Left",
      align_right: "Align Right",
      apply_now: "Apply now",
      add_profile: "Add profile",
      delete_profile: "Delete profile",
      help: "Help",
      enable_logging: "Enable logging",
      select_preset: "Select preset"
    },
    preset: {
      thermostat: "Thermostat",
      ev_charging: "EV Charging",
      generic_kwh: "Generic kWh",
      generic_temperature: "Generic Temperature",
      generic_switch: "Generic Switch"
    },
    prompt: {
      add_profile_name: "Enter new profile name",
      delete_profile_confirm: "Delete profile '{profile}'?"
    },
    notify: {
      add_profile_success: "Profile '{profile}' created",
      add_profile_error: "Error creating profile '{profile}': {error}",
      delete_profile_success: "Profile '{profile}' deleted",
      delete_profile_error: "Error deleting profile '{profile}': {error}"
    },
    help: {
      title: "CronoStar Help",
      text: "Use mouse/touch to drag points. Keyboard: Ctrl+A select all, arrows change values, Esc clears selection."
    },
    error: {
      chart_init_failed: "Chart initialization failed. See console logs."
    }
  },
  it: {
    ui: {
      title: "CronoStar",
      loading: "Caricamentoâ€¦",
      waiting_ha_start: "In attesa dell'avvio di Home Assistantâ€¦",
      waiting_profile_restore: "Ripristino dei profili in corsoâ€¦",
      startup_watermark: "Attesa backend",
      anomalous_operation_warning: "Attenzione: alcune entitÃ  sono mancanti o non disponibili.",
      anomalous_operation_watermark: "EntitÃ  mancanti",
      create_missing_entities_message: "EntitÃ  mancanti per questo preset. Si prega di creare le seguenti entitÃ  input_number:",
      pause: "Pausa",
      profile: "Profilo",
      unsaved_changes: "Modifiche non salvate",
      reset: "Ripristina",
      apply_now_error: "Errore in Applica Ora",
      apply_now_success: "Applicato correttamente per l'ora {hour}",
      time_label: "Orario",
      hours_label: "Ore",
      temperature_label: "Temperatura"
    },
    menu: {
      language: "Lingua",
      select_all: "Seleziona tutto",
      align_left: "Allinea a Sinistra",
      align_right: "Allinea a Destra",
      apply_now: "Applica ora",
      add_profile: "Aggiungi profilo",
      delete_profile: "Elimina profilo",
      help: "Aiuto",
      enable_logging: "Abilita log",
      select_preset: "Seleziona preset"
    },
    preset: {
      thermostat: "Termostato",
      ev_charging: "Ricarica EV",
      generic_kwh: "kWh generico",
      generic_temperature: "Temperatura generica",
      generic_switch: "Interruttore generico"
    },
    prompt: {
      add_profile_name: "Inserisci il nome del nuovo profilo",
      delete_profile_confirm: "Eliminare il profilo '{profile}'?"
    },
    notify: {
      add_profile_success: "Profilo '{profile}' creato",
      add_profile_error: "Errore nella creazione del profilo '{profile}': {error}",
      delete_profile_success: "Profilo '{profile}' eliminato",
      delete_profile_error: "Errore nell'eliminazione del profilo '{profile}': {error}"
    },
    help: {
      title: "Aiuto CronoStar",
      text: "Usa mouse/touch per trascinare i punti. Tastiera: Ctrl+A seleziona tutto, frecce cambiano i valori, Esc cancella la selezione."
    },
    error: {
      chart_init_failed: "Chart initialization failed. See console logs.",
      config_error: "Configuration error",
      initialization_failed: "Card initialization failed",
      reinitialization_failed: "Card reinitialization failed",
      first_update_failed: "First update failed",
      chart_rendering_failed: "Chart rendering failed"
    }
  },
  it: {
    ui: {
      title: "CronoStar",
      loading: "Caricamentoâ€¦",
      waiting_ha_start: "In attesa dell'avvio di Home Assistantâ€¦",
      waiting_profile_restore: "Ripristino dei profili in corsoâ€¦",
      startup_watermark: "Attesa backend",
      anomalous_operation_warning: "Attenzione: alcune entitÃ  sono mancanti o non disponibili.",
      anomalous_operation_watermark: "EntitÃ  mancanti",
      create_missing_entities_message: "EntitÃ  mancanti per questo preset. Si prega di creare le seguenti entitÃ  input_number:",
      pause: "Pausa",
      profile: "Profilo",
      unsaved_changes: "Modifiche non salvate",
      reset: "Ripristina",
      apply_now_error: "Errore in Applica Ora",
      apply_now_success: "Applicato correttamente per l'ora {hour}",
      time_label: "Orario",
      temperature_label: "Temperatura"
    },
    menu: {
      language: "Lingua",
      select_all: "Seleziona tutto",
      align_left: "Allinea a Sinistra",
      align_right: "Allinea a Destra",
      apply_now: "Applica ora",
      add_profile: "Aggiungi profilo",
      delete_profile: "Elimina profilo",
      help: "Aiuto",
      enable_logging: "Abilita log",
      select_preset: "Seleziona preset"
    },
    preset: {
      thermostat: "Termostato",
      ev_charging: "Ricarica EV",
      generic_kwh: "kWh generico",
      generic_temperature: "Temperatura generica",
      generic_switch: "Interruttore generico"
    },
    prompt: {
      add_profile_name: "Inserisci il nome del nuovo profilo",
      delete_profile_confirm: "Eliminare il profilo '{profile}'?"
    },
    notify: {
      add_profile_success: "Profilo '{profile}' creato",
      add_profile_error: "Errore nella creazione del profilo '{profile}': {error}",
      delete_profile_success: "Profilo '{profile}' eliminato",
      delete_profile_error: "Errore nell'eliminazione del profilo '{profile}': {error}"
    },
    help: {
      title: "Aiuto CronoStar",
      text: "Usa mouse/touch per trascinare i punti. Tastiera: Ctrl+A seleziona tutto, frecce cambiano i valori, Esc cancella la selezione."
    },
    error: {
      chart_init_failed: "Inizializzazione grafico fallita. Vedi i log della console.",
      config_error: "Errore di configurazione",
      initialization_failed: "Inizializzazione card fallita",
      reinitialization_failed: "Reinizializzazione card fallita",
      first_update_failed: "Primo aggiornamento fallito",
      chart_rendering_failed: "Errore nel rendering del grafico"
    }
  }
};

export class LocalizationManager {
  localize(lang, key, search, replace) {
    try {
      const parts = key.split('.');
      let obj = TRANSLATIONS[lang] || TRANSLATIONS.en;
      for (const p of parts) {
        obj = obj?.[p];
      }
      let value = typeof obj === 'string' ? obj : key;
      if (search && typeof search === 'object') {
        Object.keys(search).forEach((needle) => {
          value = value.replace(needle, search[needle]);
        });
      }
      if (replace && typeof replace === 'object') {
        Object.keys(replace).forEach((needle) => {
          value = value.replace(needle, replace[needle]);
        });
      }
      return value;
    } catch (e) {
      Logger.warn('I18N', `[Localization] Missing key '${key}' for lang '${lang}'`);
      return key;
    }
  }
}  


# --- File: cronostar_card/src/managers/profile_manager.js ---
# Real size: 7938 bytes, Used: 7938 bytes
/**
 * Profile management for CronoStar Card (Refactored - No Entities)
 * @module profile-manager
 */

import { Logger, safeParseFloat } from '../utils.js';
import { TIMEOUTS } from '../config.js';
import { getEffectivePrefix } from '../utils/prefix_utils.js';

export class ProfileManager {
  constructor(card) {
    this.card = card;
    this.lastLoadedProfile = "";
  }

  _buildMetaFromConfig(config) {
    const src = (config && typeof config === 'object') ? config : {};
    // Persist only safe wizard/card config keys (single source of truth).
    // IMPORTANT: do not leak deprecated keys like entity_prefix into saved JSON.
    const { entity_prefix, ...rest } = src;
    // Ensure meta carries global_prefix consistently.
    if (!rest.global_prefix) {
      const effectivePrefix = getEffectivePrefix(src);
      if (effectivePrefix) rest.global_prefix = effectivePrefix;
    }
    return rest;
  }

  async saveProfile(profileName = this.lastLoadedProfile) {
    if (!profileName) {
      Logger.warn('SAVE', "[CronoStar] No profile specified for saving.");
      throw new Error("No profile specified for saving");
    }

    const presetType = this.card.selectedPreset || 'thermostat';
    const effectivePrefix = getEffectivePrefix(this.card.config);

    Logger.save(
      `[CronoStar] === SAVE PROFILE START === Profile: '${profileName}', Preset: ${presetType}, Prefix: ${effectivePrefix}`
    );

    // Build schedule from current points without extra compression;
    // backend will normalize and optimize.
    const rawData = this.card.stateManager.getData() || [];
    const scheduleData = rawData
      .map((p) => ({
        minutes: this.card.stateManager.timeToMinutes(p.time),
        time: String(p.time),
        value: Number(p.value)
      }))
      .filter((pt) => Number.isFinite(pt.value) && /^\d{2}:\d{2}$/.test(pt.time))
      .sort((a, b) => a.minutes - b.minutes)
      .map(({ time, value }) => ({ time, value }));

    // Log outgoing sparse schedule
    Logger.save(
      `[CronoStar] ðŸ“¤ Outgoing schedule: count=${scheduleData.length}, sample=${JSON.stringify(scheduleData.slice(0, 10))}`
    );

    try {
      await this.card.hass.callService('cronostar', 'save_profile', {
        profile_name: profileName,
        preset_type: presetType,
        schedule: scheduleData,
        global_prefix: effectivePrefix,
        meta: this._buildMetaFromConfig(this.card.config),
      });

      this.card.hasUnsavedChanges = false;
      this.lastLoadedProfile = profileName;

      Logger.save(`[CronoStar] âœ… Profile '${profileName}' saved successfully.`);
      Logger.save("[CronoStar] === SAVE PROFILE END ===");
    } catch (err) {
      Logger.error('SAVE', `[CronoStar] âŒ Error calling save_profile service for '${profileName}':`, err);
      Logger.save("[CronoStar] === SAVE PROFILE END (ERROR) ===");
      throw err;
    }
  }

  /**
   * Load a profile into the schedule using the backend service.
   * @param {string} profileName - Name of the profile to load.
   * @returns {Promise}
   */
  async loadProfile(profileName) {
    this.card.stateManager.isLoadingProfile = true;

    const effectivePrefix = getEffectivePrefix(this.card.config);
    Logger.load(
      `[CronoStar] === LOAD PROFILE START === Profile: '${profileName}', Prefix: '${effectivePrefix}'`
    );

    try {
      const presetType = this.card.selectedPreset || 'thermostat';

      const result = await this.card.hass.callWS({
        type: "call_service",
        domain: "cronostar",
        service: "load_profile",
        service_data: {
          profile_name: profileName,
          preset_type: presetType,
          global_prefix: effectivePrefix
        },
        return_response: true,
      });

      const responseData = result?.response;

      Logger.load(`[CronoStar] ðŸ“¥ Response received:`, responseData);

      const rawSchedule = responseData?.schedule;
      let scheduleValues = null;

      if (responseData && !responseData.error && rawSchedule && Array.isArray(rawSchedule)) {
        // Success case: Profile loaded from backend
        // Sparse mode: expect {time,value} or {x,y} objects and pass through
        scheduleValues = rawSchedule;

        // Log sample
        const sample = scheduleValues.slice(0, 5);
        Logger.load(
          `[CronoStar] ðŸ“Š Parsed schedule: length=${scheduleValues.length}, sample=${JSON.stringify(sample)}`
        );

        Logger.load(`[CronoStar] âœ… Profile data processed for '${profileName}'. Points: ${scheduleValues.length}`);
      } else {
        // Fallback: no schedule returned; keep existing data (sparse mode)
        Logger.warn('LOAD', `[CronoStar] âš ï¸ Profile '${profileName}' not found or invalid. Keeping existing schedule.`);
        scheduleValues = this.card.stateManager.getData();
      }

      // Update Internal Memory directly
      this.card.stateManager.setData(scheduleValues);

      // Sparse mode: no grid resize

      // Update Chart
      if (this.card.chartManager?.isInitialized()) {
        this.card.chartManager.updateData(scheduleValues);
      }

      this.card.hasUnsavedChanges = false;
      this.lastLoadedProfile = profileName;
      Logger.load(`[CronoStar] âœ… Profile '${profileName}' loaded to memory successfully.`);
      Logger.load("[CronoStar] === LOAD PROFILE END ===");

    } catch (err) {
      Logger.error('LOAD', `[CronoStar] âŒ Error calling load_profile service for '${profileName}':`, err);
      Logger.load("[CronoStar] === LOAD PROFILE END (ERROR) ===");
    } finally {
      this.card.stateManager.isLoadingProfile = false;
    }
  }

  /**
   * Handle profile selection change from the UI.
   * @param {Event} e - The selection event.
   */
  async handleProfileSelection(e) {
    this.card.suppressClickUntil = Date.now() + TIMEOUTS.menuSuppression + 500;

    if (this.card.selectionManager) {
      this.card.selectionManager.snapshotSelection();
    }

    const newProfile = e?.target?.value || e?.detail?.value || '';
    if (!newProfile || newProfile === this.card.selectedProfile) {
      return;
    }

    const previousProfile = this.lastLoadedProfile || this.card.selectedProfile;

    if (this.card.hasUnsavedChanges && previousProfile) {
      try {
        Logger.save(`[CronoStar] Auto-saving previous profile '${previousProfile}'`);
        await this.saveProfile(previousProfile);
      } catch (err) {
        Logger.error('SAVE', "[CronoStar] Error during auto-save:", err);
      }
    }

    this.card.selectedProfile = newProfile;

    // Update the input_select entity so other clients know (if configured)
    if (this.card.config.profiles_select_entity) {
      this.card.hass.callService("input_select", "select_option", {
        entity_id: this.card.config.profiles_select_entity,
        option: newProfile,
      }).catch(err => Logger.warn('LOAD', "[CronoStar] select_option failed:", err));
    }

    try {
      await this.loadProfile(newProfile);
      if (this.card.selectionManager) {
        this.card.selectionManager.restoreSelectionFromSnapshot();
      }
      this.card.suppressClickUntil = Date.now() + TIMEOUTS.clickSuppression;
    } catch (err) {
      Logger.error('LOAD', "[CronoStar] Error during profile load:", err);
    }
  }

  /**
   * Reset changes by reloading the current profile.
   */
  async resetChanges() {
    const profileToReload = this.lastLoadedProfile || this.card.selectedProfile;
    if (!profileToReload) {
      Logger.warn('LOAD', "[CronoStar] No profile to reload.");
      return;
    }

    if (this.card.selectionManager) {
      this.card.selectionManager.snapshotSelection();
    }

    try {
      await this.loadProfile(profileToReload);
      if (this.card.selectionManager) {
        this.card.selectionManager.restoreSelectionFromSnapshot();
      }
    } catch (err) {
      Logger.error('LOAD', "[CronoStar] Error reloading profile:", err);
    }
  }
}


# --- File: cronostar_card/src/managers/selection_manager.js ---
# Real size: 7919 bytes, Used: 7919 bytes
/**
 * Selection management for CronoStar Card
 * @module selection-manager
 */

import { Logger, unique } from '../utils.js';

export class SelectionManager {
  constructor(card) {
    this.card = card;
    this.selectedPoint = null;
    this.selectedPoints = [];
    this.selectionSnapshot = null;
  }

  /**
   * Select a single point (alias for compatibility with ChartManager)
   * @param {number} index - Index to select
   */
  selectPoint(index) {
    this.selectIndices([index], false);

    // Ensure update is triggered safely
    if (this.card.chartManager && typeof this.card.chartManager.updatePointStyling === 'function') {
      this.card.chartManager.updatePointStyling(this.selectedPoint, this.selectedPoints);
      if (this.card.chartManager.isInitialized()) {
        this.card.chartManager.getChart()?.update('none'); // Use 'none' to avoid animation glitches
      }
    }

    this.card.requestUpdate();
  }

  /**
   * Toggle a point (alias for compatibility with ChartManager)
   * @param {number} index - Index to toggle
   */
  togglePoint(index) {
    this.toggleIndexSelection(index);

    if (this.card.chartManager && typeof this.card.chartManager.updatePointStyling === 'function') {
      this.card.chartManager.updatePointStyling(this.selectedPoint, this.selectedPoints);
      if (this.card.chartManager.isInitialized()) {
        this.card.chartManager.getChart()?.update('none');
      }
    }

    this.card.requestUpdate();
  }

  /**
   * Select a range of points (required by ChartManager)
   * @param {number} endIndex - End index of the range
   */
  selectRange(endIndex) {
    if (this.selectedPoints.length === 0) {
      this.selectPoint(endIndex);
      return;
    }

    const start = Math.min(...this.selectedPoints);
    const rangeStart = Math.min(start, endIndex);
    const rangeEnd = Math.max(start, endIndex);

    const indices = [];
    for (let i = rangeStart; i <= rangeEnd; i++) indices.push(i);

    this.selectIndices(indices, false);

    if (this.card.chartManager && typeof this.card.chartManager.updatePointStyling === 'function') {
      this.card.chartManager.updatePointStyling(this.selectedPoint, this.selectedPoints);
      if (this.card.chartManager.isInitialized()) {
        this.card.chartManager.getChart()?.update('none');
      }
    }

    this.card.requestUpdate();
  }

  /**
   * Select all points
   */
  selectAll() {
    const count = this.card?.stateManager?.getNumPoints?.() || 24;
    const allIndices = Array.from({ length: count }, (_, i) => i);
    this.selectIndices(allIndices, false);

    if (this.card.chartManager && typeof this.card.chartManager.updatePointStyling === 'function') {
      this.card.chartManager.updatePointStyling(this.selectedPoint, this.selectedPoints);
      if (this.card.chartManager.isInitialized()) {
        this.card.chartManager.getChart()?.update('none');
      }
    }
  }

  /**
   * Select exact indices
   * @param {number[]} indices
   * @param {boolean} preserveAnchor - whether to keep current anchor if still valid
   */
  selectIndices(indices, preserveAnchor = true) {
    const total = this.card?.stateManager?.getNumPoints?.() || 24;
    const filtered = unique(Array.isArray(indices) ? indices : [])
      .map((i) => Number(i))
      .filter((i) => Number.isInteger(i) && i >= 0 && i < total);

    this.selectedPoints = filtered;

    if (preserveAnchor && this.selectedPoint !== null && this.selectedPoints.includes(this.selectedPoint)) {
      // Keep existing anchor
    } else {
      this.selectedPoint = this.selectedPoints.length > 0 ? this.selectedPoints[0] : null;
    }

    // Sync with card property for reactivity
    this.card.selectedPoints = [...this.selectedPoints];

    this.logSelection('selectIndices');
  }

  /**
   * Toggle index selection
   * @param {number} index - Index to toggle
   */
  toggleIndexSelection(index) {
    const total = this.card?.stateManager?.getNumPoints?.() || 24;
    if (!Number.isInteger(index) || index < 0 || index >= total) return;

    const set = new Set(this.selectedPoints);
    if (set.has(index)) {
      set.delete(index);
    } else {
      set.add(index);
    }

    this.selectedPoints = Array.from(set);

    if (this.selectedPoint === null || !this.selectedPoints.includes(this.selectedPoint)) {
      this.selectedPoint = this.selectedPoints.length > 0 ? this.selectedPoints[0] : null;
    }

    // Sync with card property
    this.card.selectedPoints = [...this.selectedPoints];

    this.logSelection('toggleIndexSelection');
  }

  /**
   * Clear all selections
   */
  clearSelection() {
    this.selectedPoints = [];
    this.selectedPoint = null;
    this.selectionSnapshot = null;
    this.card.selectedPoints = []; // Sync
    Logger.sel('Selection cleared');
  }

  /**
   * Snapshot current selection
   */
  snapshotSelection() {
    const pts = Array.isArray(this.selectedPoints) ? [...this.selectedPoints] : [];
    if (pts.length > 0) {
      this.selectionSnapshot = {
        points: [...pts],
        anchor: this.selectedPoint
      };
      this.logSelection('snapshot before profile change');
    } else {
      this.selectionSnapshot = null;
      Logger.sel('Snapshot: no active selection');
    }
  }

  /**
   * Restore selection from snapshot
   */
  restoreSelectionFromSnapshot() {
    if (!this.selectionSnapshot) {
      Logger.sel('Restore: no snapshot to restore');
      return;
    }

    const total = this.card?.stateManager?.getNumPoints?.() || 24;

    const pts = Array.isArray(this.selectionSnapshot.points)
      ? [...this.selectionSnapshot.points]
      : [];

    this.selectedPoints = pts
      .map((i) => Number(i))
      .filter((i) => Number.isInteger(i) && i >= 0 && i < total);

    if (
      this.selectionSnapshot.anchor !== null &&
      this.selectedPoints.includes(this.selectionSnapshot.anchor)
    ) {
      this.selectedPoint = this.selectionSnapshot.anchor;
    } else {
      this.selectedPoint = this.selectedPoints.length > 0 ? this.selectedPoints[0] : null;
    }

    this.card.selectedPoints = [...this.selectedPoints]; // Sync

    if (this.card.chartManager && typeof this.card.chartManager.updatePointStyling === 'function') {
      this.card.chartManager.updatePointStyling(this.selectedPoint, this.selectedPoints);
    }

    this.logSelection('restore selection after profile change');
  }

  /**
   * Log current selection
   * @param {string} tag - Log tag
   */
  logSelection(tag = '') {
    const anchorLabel =
      this.selectedPoint !== null && this.card.stateManager
        ? this.card.stateManager.getPointLabel(this.selectedPoint)
        : 'n/a';

    Logger.sel(`${tag} - anchor=${this.selectedPoint} (${anchorLabel}) points=${JSON.stringify(this.selectedPoints)}`);
  }

  /**
   * Get selected indices or fallback to anchor
   * @returns {Array<number>}
   */
  getActiveIndices() {
    if (Array.isArray(this.selectedPoints) && this.selectedPoints.length > 0) {
      return [...this.selectedPoints];
    }
    if (this.selectedPoint !== null) {
      return [this.selectedPoint];
    }
    return [];
  }

  /**
   * Check if index is selected
   * @param {number} index - Index to check
   * @returns {boolean}
   */
  isSelected(index) {
    return this.selectedPoints.includes(index);
  }

  /**
   * Check if index is anchor
   * @param {number} index - Index to check
   * @returns {boolean}
   */
  isAnchor(index) {
    return this.selectedPoint === index;
  }

  /**
   * Set anchor point
   * @param {number} index - Index to set as anchor
   */
  setAnchor(index) {
    if (this.selectedPoints.includes(index)) {
      this.selectedPoint = index;
    }
  }

  /**
   * Get anchor point
   * @returns {number|null}
   */
  getAnchor() {
    return this.selectedPoint;
  }

  /**
   * Get selected points
   * @returns {Array<number>}
   */
  getSelectedPoints() {
    return [...this.selectedPoints];
  }
}


# --- File: cronostar_card/src/managers/shared_data_manager.js ---
# Real size: 7842 bytes, Used: 7842 bytes
/**  
 * SharedDataManager - Manages shared data for CronoStar Card  
 * Uses JSON files in the /config/cronostar/ directory  
 * @module shared-data-manager  
 */

import { Logger } from '../utils.js';

export class SharedDataManager {
  constructor(card) {
    this.card = card;
    this.baseUrl = '/local/cronostar_profiles';
    this.cache = new Map();
    this.cacheTimeout = 5000; // 5 second cache  
  }

  /**  
   * Generates the filename for a profile  
   * @param {string} profileName - Profile name  
   * @param {string} presetType - Preset type (temp, ev, switch, etc.)  
   * @returns {string} Filename  
   */
  getProfileFilename(profileName, presetType = null) {
    const type = presetType || this.getPresetType();
    const slug = this.slugify(profileName);
    return `cronostar_${type}_${slug}.json`;
  }

  /**  
   * Gets the preset type from the configuration  
   * @returns {string}  
   */
  getPresetType() {
    const prefix = this.card.config?.global_prefix || 'cronostar_';
    const match = prefix.match(/^cronostar_([^_]+)_$/);
    return match ? match[1] : 'temp';
  }

  /**  
   * Slugifies a string for use in filenames  
   * @param {string} str - String to slugify  
   * @returns {string}  
   */
  slugify(str) {
    if (!str) return '';
    return str
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  /**  
   * Constructs the URL for a profile  
   * @param {string} profileName - Profile name  
   * @returns {string}  
   */
  getProfileUrl(profileName) {
    const filename = this.getProfileFilename(profileName);
    return `${this.baseUrl}/${filename}`;
  }

  /**  
   * Loads profile data  
   * @param {string} profileName - Profile name  
   * @returns {Promise<Object|null>}  
   */
  async loadProfile(profileName) {
    const url = this.getProfileUrl(profileName);
    const cacheKey = `profile_${profileName}`;

    // Check cache  
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      Logger.log('CACHE', `[SharedDataManager] Using cached profile: ${profileName}`);
      return cached.data;
    }

    Logger.log('LOAD', `[SharedDataManager] Loading profile from: ${url}`);

    try {
      const cacheBuster = `?t=${Date.now()}`;
      const response = await fetch(url + cacheBuster, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache',
        }
      });

      if (!response.ok) {
        if (response.status === 404) {
          Logger.log('LOAD', `[SharedDataManager] Profile not found: ${profileName}`);
          return null;
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      // Validate data structure  
      if (!this.validateProfileData(data)) {
        Logger.warn('LOAD', `[SharedDataManager] Invalid profile data structure`);
        return null;
      }

      // Update cache  
      this.cache.set(cacheKey, {
        data: data,
        timestamp: Date.now()
      });

      Logger.log('LOAD', `[SharedDataManager] Profile loaded successfully: ${profileName}`);
      return data;

    } catch (error) {
      Logger.error('LOAD', `[SharedDataManager] Error loading profile: ${error.message}`);
      return null;
    }
  }

  /**  
   * Validates the profile data structure  
   * @param {Object} data - Data to validate  
   * @returns {boolean}  
   */
  validateProfileData(data) {
    if (!data || typeof data !== 'object') {
      return false;
    }

    // Check for schedule array with 24 elements  
    if (data.schedule) {
      if (!Array.isArray(data.schedule) || data.schedule.length !== 24) {
        return false;
      }
      return true;
    }

    // Fallback: simple array of 24 elements  
    if (Array.isArray(data) && data.length === 24) {
      return true;
    }

    return false;
  }

  /**  
   * Extracts the schedule array from profile data  
   * @param {Object|Array} data - Profile data  
   * @returns {Array<number>}  
   */
  extractSchedule(data) {
    if (!data) return null;

    if (data.schedule && Array.isArray(data.schedule)) {
      return data.schedule.map(v => parseFloat(v) || 0);
    }

    if (Array.isArray(data) && data.length === 24) {
      return data.map(v => parseFloat(v) || 0);
    }

    return null;
  }

  /**  
   * Saves a profile using the HA service  
   * @param {string} profileName - Profile name  
   * @param {Array<number>} schedule - Array of 24 values  
   * @param {Object} metadata - Additional metadata  
   * @returns {Promise<boolean>}  
   */
  async saveProfile(profileName, schedule, metadata = {}) {
    if (!this.card.hass) {
      Logger.error('SAVE', '[SharedDataManager] Home Assistant not available');
      return false;
    }

    const filename = this.getProfileFilename(profileName);
    const presetType = this.getPresetType();

    const profileData = {
      version: 1,
      profile_name: profileName,
      preset_type: presetType,
      global_prefix: this.card.config?.global_prefix || '',
      unit_of_measurement: this.card.config?.unit_of_measurement || '',
      min_value: this.card.config?.min_value || 0,
      max_value: this.card.config?.max_value || 100,
      step_value: this.card.config?.step_value || 1,
      saved_at: new Date().toISOString(),
      schedule: schedule,
      ...metadata
    };

    Logger.log('SAVE', `[SharedDataManager] Saving profile: ${profileName}`);

    try {
      const scriptName = (this.card.config?.save_script || 'script.cronostar_save_profile')
        .replace('script.', '');

      await this.card.hass.callService('script', scriptName, {
        profile_name: profileName,
        filename: filename,
        preset_type: presetType,
        global_prefix: this.card.config?.global_prefix || '',
        hour_base: this.card.hourBase || 0,
        profile_data: JSON.stringify(profileData),
      });

      // Invalidate cache for this profile  
      this.cache.delete(`profile_${profileName}`);

      Logger.log('SAVE', `[SharedDataManager] Profile saved successfully: ${profileName}`);
      return true;

    } catch (error) {
      Logger.error('SAVE', `[SharedDataManager] Error saving profile: ${error.message}`);
      return false;
    }
  }

  /**  
   * Checks if a profile exists  
   * @param {string} profileName - Profile name  
   * @returns {Promise<boolean>}  
   */
  async profileExists(profileName) {
    const url = this.getProfileUrl(profileName);

    try {
      const response = await fetch(url, {
        method: 'HEAD',
        cache: 'no-store'
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  /**  
   * Lists all available profiles for the current preset  
   * @returns {Promise<Array<string>>}  
   */
  async listProfiles() {
    // This functionality requires a server-side endpoint  
    // For now, it returns profiles from input_select  
    if (!this.card.hass || !this.card.config?.profiles_select_entity) {
      return [];
    }

    const selectEntity = this.card.hass.states[this.card.config.profiles_select_entity];
    if (!selectEntity || !selectEntity.attributes?.options) {
      return [];
    }

    return selectEntity.attributes.options;
  }

  /**  
   * Clears the cache  
   */
  clearCache() {
    this.cache.clear();
    Logger.log('CACHE', '[SharedDataManager] Cache cleared');
  }

  /**  
   * Invalidates a specific profile in the cache  
   * @param {string} profileName - Profile name  
   */
  invalidateProfile(profileName) {
    this.cache.delete(`profile_${profileName}`);
    Logger.log('CACHE', `[SharedDataManager] Cache invalidated for: ${profileName}`);
  }
}  


# --- File: cronostar_card/src/managers/state_manager.js ---
# Real size: 7218 bytes, Used: 7218 bytes
import { Logger } from '../utils.js';

export class StateManager {
  constructor(card) {
    this.card = card;
    // Sparse schedule: array of {time: "HH:MM", value: number}
    this.scheduleData = [];
    this.isLoadingProfile = false;

    this._initializeScheduleData();
  }

  /**
   * Initialize schedule for sparse mode: start with boundary points.
   */
  _initializeScheduleData() {
    const defaultVal = this.card.config?.min_value ?? 0;
    this.scheduleData = [
      { time: "00:00", value: defaultVal },
      { time: "23:59", value: defaultVal }
    ];
    Logger.state(`[StateManager] Initialized (sparse) with ${this.scheduleData.length} points`);
  }

  /**
   * Get current number of points (sparse schedule)
   */
  getNumPoints() {
    return this.scheduleData.length;
  }

  // Sparse mode: no interval-based resizing

  /**
   * Robustly set data, normalizing missing time/value fields
   */
  setData(newData) {
    if (!Array.isArray(newData)) {
      Logger.warn('STATE', '[StateManager] setData received non-array data');
      return;
    }

    // Sparse mode: accept only object items with {time,value} or {x,y}
    this.scheduleData = newData
      .map((item) => {
        if (typeof item !== 'object' || item === null) return null;
        let timeStr;
        let val;

        if (typeof item.time === 'string' && item.value !== undefined) {
          timeStr = String(item.time);
          val = Number(item.value);
        } else if (item.x !== undefined && item.y !== undefined) {
          timeStr = this.minutesToTime(Number(item.x));
          val = Number(item.y);
        } else {
          return null;
        }

        if (!/^\d{2}:\d{2}$/.test(timeStr)) return null;
        if (!Number.isFinite(val)) val = 0;
        return { time: timeStr, value: val };
      })
      .filter((p) => p !== null);

    // Ensure at least boundary points exist
    if (this.scheduleData.length === 0) {
      const defaultVal = this.card.config?.min_value ?? 0;
      this.scheduleData = [
        { time: "00:00", value: defaultVal },
        { time: "23:59", value: defaultVal }
      ];
    }

    this.card.hasUnsavedChanges = true;
    Logger.state(`[StateManager] setData (sparse) accepted ${this.scheduleData.length} points`);
  }

  /**
   * Return copy of schedule data
   */
  getData() {
    return [...this.scheduleData];
  }

  /**
   * Insert point (used by pointer/keyboard handlers)
   */
  insertPoint(timeStr, value) {
    const newMinutes = this.timeToMinutes(timeStr);

    // Try to update existing point within small tolerance
    const existingIndex = this.scheduleData.findIndex(p => Math.abs(this.timeToMinutes(p.time) - newMinutes) < 2);
    if (existingIndex !== -1) {
      this.scheduleData[existingIndex].value = value;
      this.card.hasUnsavedChanges = true;
      Logger.state(`[StateManager] Updated existing point at ${timeStr} = ${value}`);
      return existingIndex;
    }

    // Find insertion position
    let insertIndex = this.scheduleData.findIndex(p => this.timeToMinutes(p.time) > newMinutes);
    if (insertIndex === -1) insertIndex = this.scheduleData.length;

    this.scheduleData.splice(insertIndex, 0, { time: timeStr, value });
    this.card.hasUnsavedChanges = true;

    Logger.state(`[StateManager] Inserted point at ${timeStr} = ${value}`);
    return insertIndex;
  }

  /**
   * Remove point at index
   */
  removePoint(index) {
    if (index >= 0 && index < this.scheduleData.length) {
      this.scheduleData.splice(index, 1);
      this.card.hasUnsavedChanges = true;
      Logger.state(`[StateManager] Removed point at index ${index}`);
      return true;
    }
    return false;
  }

  /**
   * Update a single point's value by index
   */
  updatePoint(index, value) {
    if (index < 0 || index >= this.scheduleData.length) return;
    this.scheduleData[index].value = value;
    this.card.hasUnsavedChanges = true;
    this.card.lastEditAt = Date.now();
  }

  /**
   * Align selected points to leftmost or rightmost selected value
   */
  alignSelectedPoints(direction) {
    try {
      const selMgr = this.card.selectionManager;
      let indices = selMgr?.getSelectedPoints?.() || [];
      if (!Array.isArray(indices) || indices.length === 0) return;

      // Keep indices within bounds to avoid "undefined.value" errors
      indices = indices
        .map((i) => Number(i))
        .filter((i) => Number.isInteger(i) && i >= 0 && i < this.scheduleData.length);

      if (!indices.length) return;

      const sorted = [...indices].sort((a, b) => a - b);
      const anchorIdx = direction === 'right' ? sorted[sorted.length - 1] : sorted[0];

      const anchorValue = this.scheduleData[anchorIdx]?.value;
      if (anchorValue === undefined) return;

      sorted.forEach((i) => {
        if (i !== anchorIdx && this.scheduleData[i]) {
          this.scheduleData[i].value = anchorValue;
        }
      });

      // Update chart to reflect changes
      if (this.card.chartManager?.isInitialized()) {
        this.card.chartManager.updateData(this.scheduleData);
      }

      this.card.hasUnsavedChanges = true;
      this.card.lastEditAt = Date.now();
      Logger.state(`[StateManager] Aligned ${indices.length} points to ${direction} value=${anchorValue}`);
    } catch (e) {
      Logger.warn('STATE', 'alignSelectedPoints failed:', e);
    }
  }

  /**
   * Utility: convert minutes to HH:MM
   */
  minutesToTime(minutes) {
    let m = Math.round(minutes);
    while (m < 0) m += 1440;
    while (m >= 1440) m -= 1440;
    const h = Math.floor(m / 60) % 24;
    const mm = m % 60;
    return `${String(h).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
  }

  /**
   * Utility: convert HH:MM to total minutes
   */
  timeToMinutes(timeStr) {
    const [hh, mm] = String(timeStr || '00:00').split(':').map((s) => Number(s));
    const h = Number.isFinite(hh) ? hh : 0;
    const m = Number.isFinite(mm) ? mm : 0;
    return (h % 24) * 60 + (m % 60);
  }

  /**
   * Get value at a given time, using nearest or previous point
   */
  getValueAtTime(timeStr) {
    const target = this.timeToMinutes(timeStr);
    let bestIdx = -1;
    let bestDelta = Infinity;

    for (let i = 0; i < this.scheduleData.length; i++) {
      const d = Math.abs(this.timeToMinutes(this.scheduleData[i].time) - target);
      if (d < bestDelta) {
        bestDelta = d;
        bestIdx = i;
      }
    }

    if (bestIdx !== -1) return this.scheduleData[bestIdx].value;
    return this.card.config?.min_value ?? 0;
  }

  /**
   * Current index based on local time and interval
   */
  getCurrentIndex() {
    // Sparse: find nearest point to current time
    const now = new Date();
    const target = now.getHours() * 60 + now.getMinutes();
    let bestIdx = -1;
    let bestDelta = Infinity;
    for (let i = 0; i < this.scheduleData.length; i++) {
      const d = Math.abs(this.timeToMinutes(this.scheduleData[i].time) - target);
      if (d < bestDelta) {
        bestDelta = d;
        bestIdx = i;
      }
    }
    return bestIdx === -1 ? 0 : bestIdx;
  }

  /**
   * Get label for a point (HH:MM)
   */
  getPointLabel(index) {
    const p = this.scheduleData[index];
    return p?.time || '00:00';
  }
}


# --- File: cronostar_card/src/styles.js ---
# Real size: 7672 bytes, Used: 7672 bytes
/**
 * Styles for CronoStar Card
 * @module styles
 */
import { css } from 'lit';
export const cardStyles = css`
  ha-card {
    padding: 16px;
    height: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 8px;
  }

  .name {
    font-size: 1.2rem;
    font-weight: 500;
  }

  .menu-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    position: absolute;
    top: 12px;
    right: 12px;
  }

  .menu-button svg {
    fill: var(--primary-text-color);
  }

  .language-menu mwc-button {
    margin: 0 4px;
  }

  /* Fallback highlight if raised/unelevated are not visually obvious */
  .language-menu mwc-button:disabled {
    opacity: 0.6;
  }

  .menu-content {
    position: absolute;
    top: 48px;
    right: 8px;
    background: var(--card-background-color, white);
    border: 1px solid var(--divider-color, #e0e0e0);
    border-radius: 4px;
    z-index: 100;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    padding: 8px 0;
  }

  .menu-item-with-switch,
  .menu-item-with-select {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    min-height: 48px;
  }

  .menu-item-with-switch span,
  .menu-item-with-select span {
    flex-grow: 1;
    color: var(--primary-text-color);
  }

  .language-menu {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border: 1px solid var(--divider-color, #e0e0e0);
    border-radius: 4px;
    margin: 8px 16px;
    background: var(--card-background-color, white);
  }

  .language-menu mwc-button {
    margin: 0 4px;
  }
  
  .language-menu mwc-button[raised] {
    --mdc-theme-primary: var(--primary-color, #03a9f4);
    --mdc-theme-on-primary: white;
    font-weight: bold;
    border: 2px solid var(--primary-color, #03a9f4);
  }

  .card-content {
    flex-grow: 1;
    position: relative;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    min-height: 0;
  }

  .chart-container {
    position: relative;
    flex-grow: 1;
    min-height: 300px;
    user-select: none;
    outline: none;
    border-radius: 4px;
    overflow: hidden;
    transition: box-shadow 0.2s ease;
  }

  /* Visual focus indicator for keyboard navigation */
  .chart-container:focus {
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color, #03a9f4);
  }

  .chart-container:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color, #03a9f4);
  }

  /* Preset card grid and 3D outlined style for editor presets */
  .preset-cards {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 12px !important;
    margin-top: 16px !important;
    width: 100% !important;
    box-sizing: border-box !important;
  }

  .preset-card {
    -webkit-appearance: none;
    appearance: none;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
    text-align: center !important;
    padding: 12px !important;
    gap: 4px !important;
    background: #3c3c3c !important;
    border-radius: 8px !important;
    border: 1px solid #555 !important;
    transition: all 0.2s ease !important;
    cursor: pointer !important;
    color: #ffffff !important;
    width: 100% !important;
    box-sizing: border-box !important;
    min-height: 100px !important;
    margin: 0 !important;
  }

  .preset-card .preset-icon {
    font-size: 1.8rem !important;
    margin-bottom: 2px !important;
    display: block !important;
  }

  .preset-card .preset-title {
    font-weight: 600 !important;
    font-size: 0.95rem !important;
    margin: 0 !important;
    display: block !important;
  }

  .preset-card .preset-description {
    font-size: 0.75rem !important;
    color: #b0b0b0 !important;
    line-height: 1.2 !important;
    display: block !important;
  }

  .preset-card:hover {
    background: #4a4a4a !important;
    border-color: #777 !important;
  }

  .preset-card.selected {
    border: 2px solid #00b0ff !important;
    background: #3c3c3c !important;
    box-shadow: 0 0 10px rgba(0, 176, 255, 0.5) !important;
  }

  .preset-card:focus-visible {
    outline: 3px solid color-mix(in srgb, var(--primary-color, #03a9f4) 18%, transparent 82%);
    outline-offset: 2px;
  }

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
    font-size: 14px;
    color: var(--primary-text-color);
    pointer-events: none;
  }

  .startup-overlay {
    backdrop-filter: blur(1px);
    color: var(--error-color, red);
  }

  .selection-rect {
    position: absolute;
    border: 2px dashed var(--primary-color, #03a9f4);
    background: rgba(3, 169, 244, 0.15);
    display: none;
    pointer-events: none;
    z-index: 20;
    border-radius: 4px;
  }

  .anomalous-operation-overlay {
    background: transparent;
    color: var(--primary-text-color);
    font-weight: bold;
    text-align: center;
    padding: 20px;
    pointer-events: none;
  }

  .loading-overlay.awaiting-automation-overlay {
    background: transparent;
    color: var(--warning-color, #ff9800);
    font-weight: bold;
    text-align: center;
    padding: 20px;
  }

  .anomalous-watermark {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-45deg);
    font-size: 2em;
    color: rgba(128, 128, 128, 0.1);
    pointer-events: none;
    user-select: none;
    z-index: 1;
    white-space: nowrap;
    text-shadow: none;
  }

  .startup-watermark {
    position: absolute;
    top: 55%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-25deg);
    font-size: 1.8em;
    color: rgba(0, 128, 255, 0.10);
    pointer-events: none;
    user-select: none;
    z-index: 1;
    white-space: nowrap;
    text-shadow: none;
    font-weight: 700;
    letter-spacing: 1px;
  }

  canvas {
    display: block;
    cursor: ns-resize;
    touch-action: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .drag-value-display {
    position: absolute;
    top: 0;
    left: 0;
    background: var(--card-background-color, white);
    border: 1px solid var(--divider-color, #e0e0e0);
    padding: 4px 8px;
    border-radius: 4px;
    display: none;
    z-index: 100;
    font-size: 12px;
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    white-space: nowrap;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 16px;
    align-items: center;
    padding-top: 12px;
    border-top: 1px solid var(--divider-color, #e0e0e0);
    flex-shrink: 0;
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .control-group span {
    font-size: 14px;
    color: var(--primary-text-color);
  }

  ha-select {
    min-width: 180px;
  }

  mwc-button {
    --mdc-theme-primary: var(--primary-color);
  }

  mwc-button.outlined {
    --mdc-button-outline-color: var(--primary-color);
  }

  .unsaved-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    color: var(--warning-color, #ff9800);
  }

  @media (max-width: 600px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }

    .control-group {
      width: 100%;
      justify-content: space-between;
    }

    ha-select {
      width: 100%;
    }
  }
`;  


# --- File: cronostar_card/src/utils.js ---
# Real size: 3487 bytes, Used: 3487 bytes
/**
 * Utility functions for CronoStar Card
 * @module utils
 */

/**
 * Wait for a promise to resolve with timeout
 * @param {Promise} promise - Promise to wait for
 * @param {number} timeoutMs - Timeout in milliseconds
 * @returns {Promise}
 */
export async function waitWithTimeout(promise, timeoutMs) {
  return Promise.race([
    promise,
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), timeoutMs)
    )
  ]);
}

/**
 * Debounce function calls
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in ms
 * @returns {Function}
 */
export function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Round number to specified decimal places
 * @param {number} value - Value to round
 * @param {number} decimals - Number of decimal places
 * @returns {number}
 */
export function roundTo(value, decimals = 1) {
  const multiplier = Math.pow(10, decimals);
  return Math.round(value * multiplier) / multiplier;
}

/**
 * Clamp value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number}
 */
export function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

/**
 * Format hour string with padding
 * @param {number} hour - Hour (0-23 or 1-24)
 * @param {number} base - Base (0 or 1)
 * @returns {string}
 */
export function formatHourString(hour, base = 0) {
  const num = hour + base;
  return num.toString().padStart(2, '0');
}

/**
 * Parse float safely
 * @param {*} value - Value to parse
 * @param {number} defaultValue - Default if parse fails
 * @returns {number}
 */
export function safeParseFloat(value, defaultValue = null) {
  const parsed = parseFloat(value);
  return Number.isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Deep clone object
 * @param {Object} obj - Object to clone
 * @returns {Object}
 */
export function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Get unique array elements
 * @param {Array} arr - Input array
 * @returns {Array}
 */
export function unique(arr) {
  return [...new Set(arr)];
}

/**
 * Check if value is defined and not null
 * @param {*} value - Value to check
 * @returns {boolean}
 */
export function isDefined(value) {
  return value !== undefined && value !== null;
}

/**
 * Logging utility with tags
 */
let loggingEnabled = false;

export const Logger = {
  setEnabled: (enabled) => {
    loggingEnabled = !!enabled;
    console.log('Logger.setEnabled called, loggingEnabled is now', loggingEnabled);
  },
  log: (tag, ...args) => {
    if (loggingEnabled) {
      console.log(`[${tag}]`, ...args);
    }
  },
  warn: (tag, ...args) => {
    if (loggingEnabled) {
      console.warn(`[${tag}]`, ...args);
    }
  },
  error: (tag, ...args) => console.error(`[${tag}]`, ...args),
  
  state: (...args) => Logger.log('STATE', ...args),
  load: (...args) => Logger.log('LOAD', ...args),
  save: (...args) => Logger.log('SAVE', ...args),
  sel: (...args) => Logger.log('SEL', ...args),
  memo: (...args) => Logger.log('MEMO', ...args),
  diff: (...args) => Logger.log('DIFF', ...args),
  key: (...args) => Logger.log('KEY', ...args),
  base: (...args) => Logger.log('BASE', ...args),
};

window.Logger = Logger;


# --- File: cronostar_card/src/utils/editor_utils.js ---
# Real size: 1267 bytes, Used: 1267 bytes
/**
 * Utility functions for CronoStar Editor
 */

/**
 * Creates a slug from a string
 */
export function slugify(str) {
  if (!str) return '';
  return str
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '');
}

/**
 * Formats hour string with padding
 */
export function pad2(n) {
  return String(n).padStart(2, '0');
}

/**
 * Gets hours list based on hour_base and interval
 * @param {number|string} hourBase - 0 or 1
 * @param {number} intervalMinutes - Default 60
 */
export function getHoursList(hourBase, intervalMinutes = 60) {
  const points = Math.floor(1440 / intervalMinutes);
  const base = hourBase === '1' || hourBase === 1 ? 1 : 0;
  
  if (base === 1 && intervalMinutes === 60) {
    // 1-based indexing for hourly (legacy support 01..24)
    return Array.from({ length: points }, (_, i) => pad2(i + 1));
  }
  
  // 0-based indexing for all others (00..23, 00..47, etc.)
  return Array.from({ length: points }, (_, i) => pad2(i));
}

/**
 * Escapes HTML special characters
 */
export function escapeHtml(s) {
  try {
    return String(s)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  } catch {
    return s;
  }
}


# --- File: cronostar_card/src/utils/filename_utils.js ---
# Real size: 1188 bytes, Used: 1188 bytes
/**
 * Utility functions for building filenames in CronoStar Editor
 */
import { normalizePrefix } from './prefix_utils.js';
import { slugify } from './editor_utils.js';

/**
 * Builds the profile filename using the correct prefix
 */
export function buildProfileFilename(profileName, prefix) {
  const normalizedPrefix = normalizePrefix(prefix);

  const profileSlug = slugify(profileName);
  return `${normalizedPrefix.replace(/_+$/, '')}_${profileSlug}.json`;
}

/**
 * Builds the helpers filename
 */
export function buildHelpersFilename(prefix) {
  const normalizedPrefix = normalizePrefix(prefix);
  // Required naming: <Identification Prefix>_package.yaml
  // normalizedPrefix already ends with "_", so appending yields "..._package.yaml"
  return `${normalizedPrefix}package.yaml`;
}

/**
 * Builds the automation filename
 */
export function buildAutomationFilename(prefix) {
  const normalizedPrefix = normalizePrefix(prefix);
  return `${normalizedPrefix.replace(/_+$/, '')}_automation.yaml`;
}

/**
 * Gets the expected automation ID
 */
export function getExpectedAutomationId(prefix) {
  const base = normalizePrefix(prefix).replace(/_+$/, '');
  return `${base}_apply`;
}


# --- File: cronostar_card/src/utils/prefix_utils.js ---
# Real size: 1492 bytes, Used: 1492 bytes
/**
 * Utility functions for handling prefixes in CronoStar Editor
 */

/**
 * Normalizes a prefix to ensure it ends with underscore
 */
export function normalizePrefix(prefix) {
  if (!prefix) return "";
  const s = prefix.trim().toLowerCase();
  return s.endsWith("_") ? s : `${s}_`;
}

/**
 * Validates if a prefix is in correct format
 */
export function isValidPrefix(prefix) {
  if (!prefix || typeof prefix !== 'string') return false;
  return /^[a-z0-9_]+_$/.test(prefix);
}

/**
 * Humanizes a prefix for display (removes cronostar_ and underscores)
 */
export function humanizePrefix(prefix, language = 'en') {
  try {
    let s = String(prefix || '').trim();
    if (!s) return language === 'it' ? 'programma' : 'schedule';
    s = s.replace(/_+$/, '');
    s = s.replace(/^cronostar_/, '');
    s = s.replace(/_/g, ' ').replace(/\s+/g, ' ').trim().toLowerCase();
    return s || (language === 'it' ? 'programma' : 'schedule');
  } catch {
    return language === 'it' ? 'programma' : 'schedule';
  }
}

/**
 * Gets the effective prefix (global_prefix only)
 */
export function getEffectivePrefix(config) {
  const globalPrefix = (config.global_prefix || '').trim();
  return globalPrefix || 'cronostar_';
}

/**
 * Gets the alias for automation with correct prefix
 */
export function getAliasWithPrefix(prefix, language = 'en') {
  const verb = language === 'it' ? 'applica' : 'apply';
  const human = humanizePrefix(prefix, language);
  return `CronoStar - ${verb} ${human}`;
}


# --- File: custom_components/cronostar/scheduler/auto_updater.py ---
# Real size: 10317 bytes, Used: 10317 bytes
"""
CronoStar Auto-Updater - Automatically saves profiles when input_numbers change.
Monitors state changes and triggers profile saves intelligently.
"""
import logging
import asyncio
from typing import Dict, Set, Optional
from datetime import datetime, timedelta

from homeassistant.core import HomeAssistant, Event, callback
from homeassistant.helpers.event import async_track_state_change_event
from homeassistant.const import EVENT_STATE_CHANGED

_LOGGER = logging.getLogger(__name__)

class AutoUpdater:
    """Monitors input_number changes and auto-saves profiles."""
    
    def __init__(
        self,
        hass: HomeAssistant,
        storage_manager,
        profile_service
    ):
        """Initialize auto-updater.
        
        Args:
            hass: Home Assistant instance
            storage_manager: StorageManager instance
            profile_service: ProfileService instance
        """
        self.hass = hass
        self.storage = storage_manager
        self.profile_service = profile_service
        
        # Track pending changes per preset
        self._pending_changes: Dict[str, Set[str]] = {}
        self._save_tasks: Dict[str, asyncio.Task] = {}
        self._last_save: Dict[str, float] = {}
        
        # Configuration
        self.debounce_seconds = 3.0  # Wait 3s after last change
        self.min_save_interval = 5.0  # Min 5s between saves
        
        self._unsub = None
        _LOGGER.info("AutoUpdater initialized")
    
    def start_monitoring(self, prefixes: Dict[str, str]):
        """Start monitoring input_number entities for changes.
        
        Args:
            prefixes: Dict mapping preset_type to global_prefix
        """
        if self._unsub:
            self._unsub()
        
        # Build list of entities to monitor
        entities_to_monitor = []
        for preset_type, prefix in prefixes.items():
            for hour in range(24):
                entity_id = f"input_number.{prefix}{hour:02d}"
                entities_to_monitor.append(entity_id)
        
        # Subscribe to state changes
        self._unsub = async_track_state_change_event(
            self.hass,
            entities_to_monitor,
            self._on_state_change
        )
        
        _LOGGER.info(
            "Monitoring %d entities for auto-save",
            len(entities_to_monitor)
        )
    
    def stop_monitoring(self):
        """Stop monitoring state changes."""
        if self._unsub:
            self._unsub()
            self._unsub = None
        
        # Cancel pending save tasks
        for task in self._save_tasks.values():
            if not task.done():
                task.cancel()
        
        self._save_tasks.clear()
        self._pending_changes.clear()
        _LOGGER.info("AutoUpdater stopped")
    
    @callback
    def _on_state_change(self, event: Event):
        """Handle input_number state change."""
        entity_id = event.data.get("entity_id")
        old_state = event.data.get("old_state")
        new_state = event.data.get("new_state")
        
        if not entity_id or not new_state:
            return
        
        # Skip if state hasn't actually changed
        if old_state and old_state.state == new_state.state:
            return
        
        # Skip unavailable/unknown states
        if new_state.state in ("unavailable", "unknown"):
            return
        
        # Determine preset type from entity_id
        preset_type = self._detect_preset_type(entity_id)
        if not preset_type:
            return
        
        _LOGGER.debug(
            "State change detected: %s = %s (preset=%s)",
            entity_id,
            new_state.state,
            preset_type
        )
        
        # Track pending change
        if preset_type not in self._pending_changes:
            self._pending_changes[preset_type] = set()
        
        self._pending_changes[preset_type].add(entity_id)
        
        # Schedule debounced save
        self._schedule_save(preset_type)
    
    def _schedule_save(self, preset_type: str):
        """Schedule a debounced save for preset."""
        # Cancel existing task
        if preset_type in self._save_tasks:
            task = self._save_tasks[preset_type]
            if not task.done():
                task.cancel()
        
        # Create new delayed task
        self._save_tasks[preset_type] = asyncio.create_task(
            self._debounced_save(preset_type)
        )
    
    async def _debounced_save(self, preset_type: str):
        """Wait for debounce period, then save."""
        try:
            # Wait for debounce period
            await asyncio.sleep(self.debounce_seconds)
            
            # Check minimum save interval
            last_save = self._last_save.get(preset_type, 0)
            time_since_save = asyncio.get_event_loop().time() - last_save
            
            if time_since_save < self.min_save_interval:
                wait_time = self.min_save_interval - time_since_save
                _LOGGER.debug(
                    "Waiting %.1fs before save (min interval)",
                    wait_time
                )
                await asyncio.sleep(wait_time)
            
            # Get current profile for this preset
            profile_name = await self._get_active_profile(preset_type)
            
            if not profile_name:
                _LOGGER.warning(
                    "No active profile for %s, skipping auto-save",
                    preset_type
                )
                return
            
            # Collect schedule from input_numbers
            schedule = await self._collect_schedule(preset_type)
            
            if not schedule:
                _LOGGER.warning(
                    "Failed to collect schedule for %s",
                    preset_type
                )
                return
            
            # Save profile
            _LOGGER.info(
                "Auto-saving profile '%s' (preset=%s, changed=%d entities)",
                profile_name,
                preset_type,
                len(self._pending_changes.get(preset_type, []))
            )
            
            from homeassistant.core import ServiceCall
            
            # Use ProfileService to save
            call = ServiceCall(
                domain="cronostar",
                service="save_profile",
                data={
                    "profile_name": profile_name,
                    "preset_type": preset_type,
                    "schedule": schedule
                }
            )
            
            await self.profile_service.save_profile(call)
            
            # Update last save time
            self._last_save[preset_type] = asyncio.get_event_loop().time()
            
            # Clear pending changes
            self._pending_changes.pop(preset_type, None)
            
            _LOGGER.info("Auto-save completed for '%s'", profile_name)
            
        except asyncio.CancelledError:
            _LOGGER.debug("Save cancelled for %s", preset_type)
        except Exception as e:
            _LOGGER.error("Auto-save failed for %s: %s", preset_type, e)
    
    async def _get_active_profile(self, preset_type: str) -> Optional[str]:
        """Get the currently active profile for a preset."""
        # Map preset to input_text entity
        profile_entities = {
            "thermostat": "input_text.cronostar_active_profile_thermostat",
            "ev_charging": "input_text.cronostar_active_profile_ev_charging",
            "generic_switch": "input_text.cronostar_active_profile_generic_switch",
            "generic_kwh": "input_text.cronostar_active_profile_generic_kwh",
            "generic_temperature": "input_text.cronostar_active_profile_generic_temperature",
        }
        
        entity_id = profile_entities.get(preset_type)
        if not entity_id:
            return None
        
        state = self.hass.states.get(entity_id)
        if not state or state.state in ("unknown", "unavailable", ""):
            return None
        
        return state.state
    
    async def _collect_schedule(self, preset_type: str) -> Optional[list]:
        """Collect current schedule values from input_numbers."""
        # Get prefix for this preset
        from ..utils.prefix_normalizer import PRESETS_CONFIG
        
        config = PRESETS_CONFIG.get(preset_type, {})
        prefix = config.get("global_prefix", config.get("entity_prefix", "cronostar_"))
        
        schedule = []
        for hour in range(24):
            entity_id = f"input_number.{prefix}{hour:02d}"
            state = self.hass.states.get(entity_id)
            
            if not state or state.state in ("unknown", "unavailable"):
                _LOGGER.warning("Entity unavailable: %s", entity_id)
                return None
            
            try:
                value = float(state.state)
                schedule.append({"hour": hour, "value": value})
            except (ValueError, TypeError):
                _LOGGER.error("Invalid value for %s: %s", entity_id, state.state)
                return None
        
        return schedule
    
    def _detect_preset_type(self, entity_id: str) -> Optional[str]:
        """Detect preset type from entity_id."""
        from ..utils.prefix_normalizer import PRESETS_CONFIG
        
        for preset_type, config in PRESETS_CONFIG.items():
            prefix = config.get("global_prefix", config.get("entity_prefix", ""))
            if entity_id.startswith(f"input_number.{prefix}"):
                return preset_type
        
        return None
    
    def force_save(self, preset_type: str):
        """Force immediate save for a preset (bypass debouncing)."""
        _LOGGER.info("Force save requested for %s", preset_type)
        
        # Cancel existing task
        if preset_type in self._save_tasks:
            task = self._save_tasks[preset_type]
            if not task.done():
                task.cancel()
        
        # Reset debounce timer
        self._last_save.pop(preset_type, None)
        
        # Trigger immediate save
        self._save_tasks[preset_type] = asyncio.create_task(
            self._debounced_save(preset_type)
        )


# --- File: custom_components/cronostar/scheduler/smart_scheduler.py ---
# Real size: 28596 bytes, Used: 28596 bytes
"""
CronoStar Smart Scheduler - Irregular Intervals Support
Calculates values from dynamic schedule with time-based points
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, Optional, List, Any

from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.event import async_track_point_in_time
from homeassistant.util import dt as dt_util

from ..utils.prefix_normalizer import PRESETS_CONFIG

_LOGGER = logging.getLogger(__name__)

class SmartScheduler:
    """Smart Scheduler for profiles with irregular intervals."""
    
    def __init__(self, hass: HomeAssistant, profile_service):
        self.hass = hass
        self.profile_service = profile_service
        self._timers: Dict[str, Any] = {}
        self._profiles_cache: Dict[str, Dict] = {}

    async def async_initialize(self):
        """Initialize schedulers for all presets."""
        _LOGGER.info("Initializing Smart Scheduler...")
        for preset_type in PRESETS_CONFIG:
            await self.update_preset(preset_type)

        # Also initialize any presets that may not be in PRESETS_CONFIG but exist as stored profiles
        try:
            if hasattr(self.profile_service, "storage"):
                files = await self.profile_service.storage.list_profiles()
                extra_presets = set()
                for fname in files:
                    try:
                        data = await self.profile_service.storage.load_profile_cached(fname)
                        canonical = (data or {}).get("meta", {}).get("preset_type")
                        if canonical and canonical not in PRESETS_CONFIG:
                            extra_presets.add(canonical)
                    except Exception:
                        continue
                for preset_type in sorted(extra_presets):
                    _LOGGER.info("Initializing scheduler for stored preset '%s'", preset_type)
                    await self.update_preset(preset_type)
        except Exception as e:
            _LOGGER.debug("async_initialize extra preset scan skipped: %s", e)

    def stop(self):
        """Stop all timers."""
        for timer_key, cancel_func in list(self._timers.items()):
            if cancel_func:
                try:
                    cancel_func()
                except Exception as e:
                    _LOGGER.warning("Error cancelling timer for %s: %s", timer_key, e)
        self._timers.clear()
        _LOGGER.info("Smart Scheduler stopped.")

    @staticmethod
    def _time_to_minutes(time_str: str) -> int:
        """Convert HH:MM to minutes since midnight."""
        try:
            hours, minutes = map(int, time_str.split(':'))
            if not (0 <= hours < 24 and 0 <= minutes < 60):
                _LOGGER.warning("Invalid time value: %s", time_str)
                return 0
            return hours * 60 + minutes
        except (ValueError, AttributeError) as e:
            _LOGGER.error("Failed to parse time string '%s': %s", time_str, e)
            return 0

    @staticmethod
    def _deduce_interval_from_indices(indices: List[int]) -> int:
        """Deduce interval in minutes from a list of index-based points.
        Assumes indices are 0..N-1 evenly spaced. Falls back to 60 if unknown."""
        try:
            if not indices:
                return 60
            max_idx = max(indices)
            total = max_idx + 1
            if total <= 0:
                return 60
            interval = round(1440 / total)
            return max(1, min(1440, interval))
        except Exception:
            return 60

    def _normalize_schedule(self, schedule: List[Dict]) -> List[Dict]:
        """Normalize schedule to time-based format.
        
        Automatically converts from old format (index) to new (time) if necessary.
        
        Args:
            schedule: Schedule in old or new format
            interval_minutes: Interval for index conversion
            
        Returns:
            Normalized schedule with "time" and "value" fields
        """
        normalized = []
        indices: List[int] = []
        
        for point in schedule:
            if not isinstance(point, dict):
                continue
            
            # New format (already has "time")
            if "time" in point and "value" in point:
                normalized.append({
                    "time": point["time"],
                    "value": float(point["value"])
                })
            
            # Old format (has "index")
            elif "index" in point and "value" in point:
                try:
                    idx = int(point["index"])
                    indices.append(idx)
                except Exception:
                    continue

        # Convert index points after deducing interval
        if indices:
            interval_minutes = self._deduce_interval_from_indices(indices)
            for point in schedule:
                if isinstance(point, dict) and "index" in point and "value" in point:
                    try:
                        idx = int(point["index"])
                        minutes = (idx * interval_minutes) % 1440
                        hours = minutes // 60
                        mins = minutes % 60
                        normalized.append({
                            "time": f"{hours:02d}:{mins:02d}",
                            "value": float(point["value"])
                        })
                    except Exception:
                        continue
        
        # Sort by time
        normalized.sort(key=lambda p: p["time"])
        
        # Log warning if schedule is empty
        if not normalized:
            _LOGGER.warning("Empty schedule after normalization")
        
        return normalized

    def _get_value_at_time(
        self,
        schedule: List[Dict],
        target_time: datetime
    ) -> Optional[float]:
        """Get interpolated value for a specific time.
        
        Args:
            schedule: List of points with "time" and "value"
            target_time: Target time to calculate value for
            interval_minutes: Interval (used for backward compatibility)
            
        Returns:
            Interpolated value or None if schedule is empty
        """
        if not schedule:
            _LOGGER.debug("Empty schedule")
            return None
        
        # Normalize schedule (convert from index to time if needed)
        normalized_schedule = self._normalize_schedule(schedule)
        
        if not normalized_schedule:
            _LOGGER.error("Cannot normalize schedule")
            return None
        
        target_minutes = target_time.hour * 60 + target_time.minute
        
        # Find points before and after
        before = None
        after = None
        
        for point in normalized_schedule:
            point_minutes = self._time_to_minutes(point["time"])
            
            if point_minutes <= target_minutes:
                before = point
            if point_minutes >= target_minutes and not after:
                after = point
        
        # Handle wrap-around midnight
        if not before:
            before = normalized_schedule[-1]
            _LOGGER.debug("Wrap-around: using last point %s", before["time"])
        if not after:
            after = normalized_schedule[0]
            _LOGGER.debug("Wrap-around: using first point %s", after["time"])
        
        # Exact match
        before_minutes = self._time_to_minutes(before["time"])
        after_minutes = self._time_to_minutes(after["time"])
        
        if before_minutes == target_minutes:
            _LOGGER.debug("Exact match at %s: %.2f", before["time"], before["value"])
            return float(before["value"])
        
        if after_minutes == target_minutes:
            _LOGGER.debug("Exact match at %s: %.2f", after["time"], after["value"])
            return float(after["value"])
        
        # Handle wrap-around for ratio calculation
        if after_minutes < before_minutes:
            after_minutes += 1440  # Add 24 hours
        
        if target_minutes < before_minutes:
            target_minutes += 1440
        
        # Avoid division by zero
        if after_minutes == before_minutes:
            _LOGGER.warning("Duplicate times: %s", before["time"])
            return float(before["value"])
        
        # Linear interpolation
        ratio = (target_minutes - before_minutes) / (after_minutes - before_minutes)
        interpolated = before["value"] + ratio * (after["value"] - before["value"])
        result = round(interpolated, 2)
        
        _LOGGER.debug(
            "Interpolation: %s (%.2f) -> %s (%.2f) at %s: ratio=%.3f, result=%.2f",
            before["time"], before["value"],
            after["time"], after["value"],
            target_time.strftime("%H:%M"),
            ratio, result
        )
        
        return result

    def _find_next_change(
        self,
        schedule: List[Dict],
        now: datetime
    ) -> Optional[datetime]:
        """Find next value change in schedule.
        
        Args:
            schedule: Normalized schedule
            now: Current time
            interval_minutes: Interval (for backward compatibility)
            
        Returns:
            DateTime of next change, or None if no changes found
        """
        if not schedule:
            return None
        
        # Normalize schedule
        normalized_schedule = self._normalize_schedule(schedule)
        
        if not normalized_schedule:
            return None
        
        current_minutes = now.hour * 60 + now.minute
        
        # Search next point after current time
        for point in normalized_schedule:
            point_minutes = self._time_to_minutes(point["time"])
            
            if point_minutes > current_minutes:
                hours = point_minutes // 60
                minutes = point_minutes % 60
                
                next_time = now.replace(
                    hour=hours,
                    minute=minutes,
                    second=0,
                    microsecond=0
                )
                
                _LOGGER.debug("Next change today at %s", next_time.strftime("%H:%M"))
                return next_time
        
        # No change today, use first point tomorrow
        if normalized_schedule:
            first_point = normalized_schedule[0]
            first_minutes = self._time_to_minutes(first_point["time"])
            
            tomorrow = now + timedelta(days=1)
            next_time = tomorrow.replace(
                hour=first_minutes // 60,
                minute=first_minutes % 60,
                second=0,
                microsecond=0
            )
            
            _LOGGER.debug("Next change tomorrow at %s", next_time.strftime("%H:%M"))
            return next_time
        
        return None

    async def update_preset(self, preset_type: str, profile_data: Optional[Dict] = None):
        """Update schedule for a preset."""
        try:
            # Cancel existing timer
            if preset_type in self._timers:
                try:
                    self._timers[preset_type]()
                except Exception as e:
                    _LOGGER.debug("Error cancelling old timer for %s: %s", preset_type, e)
                del self._timers[preset_type]

            # Load or use profile_data
            if not profile_data:
                profile_data = await self._get_active_profile_data(preset_type)
            
            if not profile_data:
                _LOGGER.warning("No profile data for %s", preset_type)
                self._schedule_retry(preset_type)
                return

            # Cache profile
            self._profiles_cache[preset_type] = profile_data

            # Get schedule
            schedule = profile_data.get("schedule", [])
            
            if not schedule:
                _LOGGER.warning("Empty schedule for %s", preset_type)
                self._schedule_retry(preset_type)
                return
            
            # Calculate current value
            now = dt_util.now()
            current_value = self._get_value_at_time(schedule, now)
            
            if current_value is None:
                _LOGGER.warning("Cannot calculate value for %s", preset_type)
                self._schedule_retry(preset_type)
                return
            
            # Update entity
            await self._update_current_value_entity(preset_type, current_value)

            # Apply value to target entity immediately (scheduler is source of truth)
            try:
                await self._apply_target_entity(preset_type, profile_data, current_value)
            except Exception as e:
                _LOGGER.warning("Failed to apply target entity for %s: %s", preset_type, e)
            
            # Schedule next update
            next_change = self._find_next_change(schedule, now)
            
            if next_change:
                @callback
                def _update_callback(now):
                    self.hass.async_create_task(self.update_preset(preset_type))
                
                self._timers[preset_type] = async_track_point_in_time(
                    self.hass,
                    _update_callback,
                    next_change
                )
                
                _LOGGER.info(
                    "Next update for %s at %s",
                    preset_type,
                    next_change.strftime("%Y-%m-%d %H:%M:%S")
                )
            
        except Exception as e:
            _LOGGER.error(
                "Unexpected error in update_preset for %s: %s", 
                preset_type, e, exc_info=True
            )
            # Schedule retry in case of error
            self._schedule_retry(preset_type)

    async def _apply_target_entity(self, preset_type: str, profile_data: Dict, value: float) -> None:
        """Apply the computed value to the configured target entity for this preset.

        Resolution order:
        1) dynamic target entity derived from the stored profile prefix when possible
        2) fallback to PRESETS_CONFIG target_entity if present

        Note: input_number update is handled separately; this is the actual actuator apply.
        """
        cfg = PRESETS_CONFIG.get(preset_type, {})
        target_entity = None

        # Prefer target from stored container meta (wizard/card config).
        # NOTE: profile_data returned by _get_active_profile_data currently contains the *profile content*
        # (schedule/updated_at/...) but NOT the container meta. So meta may be missing here.
        try:
            meta = profile_data.get("meta") if isinstance(profile_data, dict) else None
            if isinstance(meta, dict):
                target_entity = meta.get("target_entity")
        except Exception:
            target_entity = None

        # Also allow top-level canonical key (if present)
        if not target_entity and isinstance(profile_data, dict):
            target_entity = profile_data.get("target_entity")

        if not target_entity:
            target_entity = cfg.get("target_entity")

        # NOTE: legacy aliases removed; only `target_entity` is supported.

        profile_prefix = profile_data.get("global_prefix")
        if profile_prefix:
            if not profile_prefix.endswith("_"):
                profile_prefix += "_"
            # Try a conventional dynamic target if provided via cfg map
            # (If user stores target entity elsewhere, they should set cfg.target_entity.)
            # No-op here.
            pass

        if not target_entity:
            try:
                _LOGGER.debug(
                    "_apply_target_entity: no target_entity configured for preset '%s' (profile_keys=%s)",
                    preset_type,
                    sorted(list(profile_data.keys())) if isinstance(profile_data, dict) else type(profile_data),
                )
            except Exception:
                _LOGGER.debug("_apply_target_entity: no target_entity configured for preset '%s'", preset_type)
            return

        domain = target_entity.split(".")[0]
        if domain == "climate":
            await self.hass.services.async_call(
                "climate",
                "set_temperature",
                {"entity_id": target_entity, "temperature": float(value)},
                blocking=False,
            )
        elif domain == "number":
            await self.hass.services.async_call(
                "number",
                "set_value",
                {"entity_id": target_entity, "value": float(value)},
                blocking=False,
            )
        elif domain == "switch":
            service = "turn_on" if int(value) == 1 else "turn_off"
            await self.hass.services.async_call(
                "switch",
                service,
                {"entity_id": target_entity},
                blocking=False,
            )
        else:
            _LOGGER.debug("_apply_target_entity: unsupported domain '%s'", domain)

    async def _update_current_value_entity(self, preset_type: str, current_value: float):
        """Update the input_number entity with the calculated value."""
        profile_data = self._profiles_cache.get(preset_type)
        if not profile_data:
            _LOGGER.warning("No profile data found in cache for %s during update", preset_type)
            return

        config = PRESETS_CONFIG.get(preset_type) or {}

        # Update entity
        profile_prefix = profile_data.get("global_prefix")
        target_entity = None
        
        if profile_prefix:
            if not profile_prefix.endswith("_"):
                profile_prefix += "_"
            dynamic_entity = f"input_number.{profile_prefix}current"
            
            if self.hass.states.get(dynamic_entity):
                target_entity = dynamic_entity
            else:
                default_entity = config.get("current_value_entity")
                if default_entity:
                    _LOGGER.warning(
                        "Dynamic entity %s not found. Falling back to %s",
                        dynamic_entity, default_entity
                    )
                    target_entity = default_entity
        
        if not target_entity:
            target_entity = config.get("current_value_entity")

        if target_entity:
            try:
                await self.hass.services.async_call(
                    "input_number",
                    "set_value",
                    {"entity_id": target_entity, "value": current_value}
                )
                _LOGGER.info(
                    "Scheduler Update: %s = %s", 
                    target_entity, 
                    current_value
                )
            except Exception as e:
                _LOGGER.warning("Failed to update %s: %s", target_entity, e)
        else:
            _LOGGER.warning("No target entity found for preset type: %s", preset_type)

    def _schedule_retry(self, preset_type: str):
        """Schedule retry if loading failed."""
        next_retry = dt_util.now() + timedelta(minutes=1)
        _LOGGER.info("Scheduling retry for %s at %s", preset_type, next_retry)

        @callback
        def _retry_callback(now):
            _LOGGER.debug("Retry timer fired for %s", preset_type)
            self.hass.async_create_task(self.update_preset(preset_type))

        self._timers[preset_type] = async_track_point_in_time(
            self.hass,
            _retry_callback,
            next_retry
        )

    async def _get_active_profile_data(self, preset_type: str) -> Optional[Dict]:
        """Fetch JSON data for currently selected profile."""
        config = PRESETS_CONFIG.get(preset_type)
        if not config:
            _LOGGER.warning("No config found for preset type: %s. Falling back to latest stored profile.", preset_type)
            return await self._get_latest_profile_data_for_preset(preset_type)
            
        selector_entity = config.get("profiles_select")
        
        if not selector_entity:
            _LOGGER.warning("No selector entity configured for preset type: %s. Falling back to latest stored profile.", preset_type)
            return await self._get_latest_profile_data_for_preset(preset_type)
            
        state = self.hass.states.get(selector_entity)
        if not state:
            _LOGGER.warning("Selector entity not found: %s. Falling back to latest stored profile.", selector_entity)
            return await self._get_latest_profile_data_for_preset(preset_type)
            
        profile_name = state.state
        if not profile_name or profile_name in ("unknown", "unavailable"):
            _LOGGER.warning("Invalid profile state for %s: %s. Falling back to latest stored profile.", selector_entity, profile_name)
            return await self._get_latest_profile_data_for_preset(preset_type)

        _LOGGER.debug(
            "Fetching profile data for preset %s, profile: %s", 
            preset_type, profile_name
        )

        from ..utils.prefix_normalizer import normalize_preset_type
        
        canonical = normalize_preset_type(preset_type)
        
        if hasattr(self.profile_service, "storage"):
            try:
                files = await self.profile_service.storage.list_profiles()
                matches = []
                
                for fname in files:
                    try:
                        data = await self.profile_service.storage.load_profile_cached(fname)
                        
                        if data and data.get("meta", {}).get("preset_type") == canonical:
                            if "profiles" in data and profile_name in data["profiles"]:
                                profile_content = data["profiles"][profile_name]
                                
                                # Validate profile data
                                if not isinstance(profile_content, dict):
                                    _LOGGER.warning(
                                        "Profile content is not a dict in %s/%s: %s",
                                        fname, profile_name, type(profile_content)
                                    )
                                    continue
                                
                                # Add metadata
                                profile_content["global_prefix"] = data.get("meta", {}).get("global_prefix")
                                profile_content["profile_name"] = profile_name
                                profile_content["_container_updated_at"] = data.get("meta", {}).get("updated_at", 0)

                                # Propagate container meta needed by the scheduler (e.g. target_entity)
                                # so `_apply_target_entity` can work even when profile_content itself doesn't include it.
                                profile_content["meta"] = data.get("meta", {})
                                
                                # Validate schedule
                                if "schedule" in profile_content:
                                    schedule = profile_content["schedule"]
                                    if isinstance(schedule, list):
                                        # Remove invalid points (minimal check, full check in normalize)
                                        valid_schedule = []
                                        for point in schedule:
                                            if isinstance(point, dict):
                                                valid_schedule.append(point)
                                        
                                        profile_content["schedule"] = valid_schedule
                                    else:
                                        _LOGGER.warning(
                                            "Schedule is not a list in %s/%s: %s",
                                            fname, profile_name, type(schedule)
                                        )
                                        profile_content["schedule"] = []
                                
                                matches.append(profile_content)
                                _LOGGER.debug(
                                    "Found matching profile in %s, updated_at: %s",
                                    fname, profile_content.get("updated_at", "unknown")
                                )
                    except Exception as e:
                        _LOGGER.warning("Error loading profile %s: %s", fname, e)
                
                if matches:
                    matches.sort(
                        key=lambda p: (p.get("updated_at", 0), p.get("_container_updated_at", 0)), 
                        reverse=True
                    )
                    selected = matches[0]
                    _LOGGER.info(
                        "Selected profile '%s' for %s (updated_at: %s)",
                        selected.get("profile_name", "unknown"),
                        preset_type,
                        selected.get("updated_at", "unknown")
                    )
                    return selected
                else:
                    _LOGGER.warning(
                        "No matching profile found for %s with name '%s'",
                        preset_type, profile_name
                    )
                    
            except Exception as e:
                _LOGGER.error("Error fetching profile data for %s: %s", preset_type, e, exc_info=True)
        
        _LOGGER.warning("Could not retrieve profile data for %s", preset_type)
        return None

    async def _get_latest_profile_data_for_preset(self, preset_type: str) -> Optional[Dict]:
        """Fallback: pick the newest stored profile container for the preset and then the newest profile inside it.

        This improves reliability at startup when input_select entities are unavailable.
        """
        try:
            if not hasattr(self.profile_service, "storage"):
                return None

            from ..utils.prefix_normalizer import normalize_preset_type
            canonical = normalize_preset_type(preset_type)

            files = await self.profile_service.storage.list_profiles()
            best_container = None
            best_container_key = ""

            for fname in files:
                try:
                    data = await self.profile_service.storage.load_profile_cached(fname)
                except Exception:
                    continue
                if not data or not isinstance(data, dict):
                    continue
                if (data.get("meta", {}) or {}).get("preset_type") != canonical:
                    continue

                key = str((data.get("meta", {}) or {}).get("updated_at") or "")
                if not best_container or key > best_container_key:
                    best_container = data
                    best_container_key = key

            if not best_container:
                _LOGGER.warning("Fallback: no profile containers found for preset '%s'", canonical)
                return None

            profiles = best_container.get("profiles", {})
            if not isinstance(profiles, dict) or not profiles:
                return None

            chosen_name = None
            chosen = None
            chosen_key = ""
            for name, content in profiles.items():
                if not isinstance(content, dict):
                    continue
                key = str(content.get("updated_at") or "")
                if not chosen or key > chosen_key:
                    chosen = content
                    chosen_name = name
                    chosen_key = key

            if not chosen:
                return None

            chosen["global_prefix"] = (best_container.get("meta", {}) or {}).get("global_prefix")
            chosen["profile_name"] = chosen_name or "Default"
            chosen["_container_updated_at"] = (best_container.get("meta", {}) or {}).get("updated_at", 0)
            # Propagate container meta so scheduler can read target_entity.
            chosen["meta"] = best_container.get("meta", {})
            return chosen
        except Exception as e:
            _LOGGER.debug("_get_latest_profile_data_for_preset failed: %s", e)
            return None


# --- File: custom_components/cronostar/services/automation_service.py ---
# Real size: 3395 bytes, Used: 3395 bytes
import logging

from homeassistant.core import HomeAssistant, ServiceCall
from homeassistant.util import dt as dt_util

from ..utils.prefix_normalizer import normalize_preset_type, normalize_prefix, PRESETS_CONFIG

_LOGGER = logging.getLogger(__name__)

class AutomationService:
    def __init__(self, hass: HomeAssistant):
        self.hass = hass

    async def apply_now(self, call: ServiceCall):
        """Apply current hour's scheduled value immediately."""
        target_entity = call.data.get("target_entity")
        preset_type = call.data.get("preset_type")
        allow_max = call.data.get("allow_max_value", False)
        global_prefix = call.data.get("global_prefix")
        
        if not all((target_entity, preset_type)):
            return
        
        canonical = normalize_preset_type(preset_type)
        
        # New Logic: Read from the single current_value_entity
        config = PRESETS_CONFIG.get(canonical, {})
        
        # Determine which prefix to use
        if not global_prefix:
            _LOGGER.warning("apply_now: missing global_prefix")
            return

        used_prefix = normalize_prefix(global_prefix)
        
        # Construct dynamic entity ID
        current_value_entity = f"input_number.{used_prefix}current"
        
        if not current_value_entity:
            _LOGGER.warning("Could not determine current_value_entity for preset %s", canonical)
            return
            
        # Read from the single current_value_entity (scheduler is the source of truth)
        state = self.hass.states.get(current_value_entity)
        # No fallback: global_prefix is the only supported configuration

        if not state or state.state in ("unknown", "unavailable"):
            _LOGGER.warning("Current value entity not available: %s", current_value_entity)
            return
        
        try:
            target_value = float(state.state)
            max_value = state.attributes.get("max")
        except (ValueError, TypeError):
            _LOGGER.warning("Invalid state value for %s", current_value_entity)
            return
        
        # Check for Max value
        if allow_max and max_value is not None and target_value >= max_value:
            _LOGGER.info(
                "apply_now: Max value detected for %s, deferring",
                target_entity
            )
            return

        
        # Apply value based on target entity domain
        domain = target_entity.split('.')[0]
        
        if domain == "climate":
            await self.hass.services.async_call(
                "climate",
                "set_temperature",
                {"entity_id": target_entity, "temperature": target_value}
            )
        elif domain == "number":
            await self.hass.services.async_call(
                "number",
                "set_value",
                {"entity_id": target_entity, "value": target_value}
            )
        elif domain == "switch":
            service = "turn_on" if int(target_value) == 1 else "turn_off"
            await self.hass.services.async_call(
                "switch",
                service,
                {"entity_id": target_entity}
            )
        
        _LOGGER.info(
            "Applied value %.2f from %s to %s",
            target_value,
            current_value_entity,
            target_entity
        )



# --- File: custom_components/cronostar/services/file_service.py ---
# Real size: 2171 bytes, Used: 2171 bytes
import logging
import os
import json
from functools import partial

from homeassistant.core import HomeAssistant, ServiceCall

_LOGGER = logging.getLogger(__name__)

PROFILES_PATH = "cronostar/profiles" 

class FileService:
    def __init__(self, hass: HomeAssistant):
        self.hass = hass
        self.profiles_dir = hass.config.path(PROFILES_PATH)
        os.makedirs(self.profiles_dir, exist_ok=True)

    def save_json(self, path: str, data: dict):
        """Save JSON data to file."""
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)

    def load_json(self, path: str) -> dict:
        """Load JSON data from file."""
        if not os.path.exists(path):
            return {"error": "File not found"}
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)

    async def create_yaml_file(self, call: ServiceCall):
        """Creates a YAML file with the given content."""
        file_path = call.data.get("file_path")
        content = call.data.get("content")
        append = call.data.get("append", False)

        if not file_path or content is None:
            _LOGGER.error("create_yaml_file: Missing file_path or content")
            return

        # Sanitize path to ensure it's within the config directory
        abs_path = self.hass.config.path(file_path)
        if not abs_path.startswith(self.hass.config.path("")):
            _LOGGER.error("Attempted to write file outside of config directory: %s", file_path)
            return

        # Ensure directory exists
        os.makedirs(os.path.dirname(abs_path), exist_ok=True)

        mode = "a" if append else "w"
        try:
            await self.hass.async_add_executor_job(
                partial(self._write_file_content, abs_path, content, mode)
            )
            _LOGGER.info("Successfully wrote to file: %s (mode: %s)", file_path, mode)
        except Exception as e:
            _LOGGER.error("Failed to write file %s: %s", file_path, e)

    def _write_file_content(self, path: str, content: str, mode: str):
        with open(path, mode, encoding="utf-8") as f:
            f.write(content)



# --- File: custom_components/cronostar/services/interval_service.py ---
# Real size: 7193 bytes, Used: 7193 bytes
"""Gestione intervalli variabili per CronoStar."""
import logging
from typing import List, Optional
from enum import Enum

from homeassistant.core import HomeAssistant, ServiceCall, ServiceResponse

_LOGGER = logging.getLogger(__name__)


class IntervalType(Enum):
    """Intervalli supportati."""
    HOURLY = 60
    HALF_HOUR = 30
    QUARTER = 15
    TEN_MIN = 10
    FIVE_MIN = 5
    MINUTE = 1
    
    @classmethod
    def from_minutes(cls, minutes: int) -> Optional['IntervalType']:
        for interval in cls:
            if interval.value == minutes:
                return interval
        return None
    
    def get_points_count(self) -> int:
        return (24 * 60) // self.value
    
    def get_time_labels(self) -> List[str]:
        labels = []
        for i in range(0, 24 * 60, self.value):
            h = i // 60
            m = i % 60
            labels.append(f"{h:02d}:{m:02d}")
        return labels


class IntervalConverter:
    """Converte schedule tra intervalli."""
    
    @staticmethod
    def convert_schedule(schedule, target_interval: IntervalType):
        """Converte schedule a nuovo intervallo."""
        from ..storage.schedule_manager import Schedule, SchedulePoint
        
        if schedule.interval_minutes == target_interval.value:
            return schedule
        
        if schedule.interval_minutes > target_interval.value:
            # Upscale: interpola
            new_points = IntervalConverter._interpolate(
                schedule.points,
                schedule.interval_minutes,
                target_interval.value
            )
        else:
            # Downscale: seleziona
            new_points = IntervalConverter._select(
                schedule.points,
                target_interval.value
            )
        
        return Schedule(
            profile_name=schedule.profile_name,
            preset_type=schedule.preset_type,
            interval_minutes=target_interval.value,
            points=new_points,
            global_prefix=getattr(schedule, 'global_prefix', None),
            saved_at=schedule.saved_at
        )
    
    @staticmethod
    def _interpolate(points, from_interval: int, to_interval: int):
        """Interpolazione lineare."""
        from ..storage.schedule_manager import SchedulePoint
        
        new_points = []
        sorted_points = sorted(points, key=lambda p: p.to_minutes())
        
        for i in range(0, 24 * 60, to_interval):
            h = i // 60
            m = i % 60
            time_str = f"{h:02d}:{m:02d}"
            
            # Trova punti prima/dopo
            prev_point = None
            next_point = None
            
            for idx, point in enumerate(sorted_points):
                if point.to_minutes() <= i:
                    prev_point = point
                if point.to_minutes() > i:
                    next_point = point
                    break
            
            if not next_point:
                next_point = sorted_points[0]
            if not prev_point:
                prev_point = sorted_points[-1]
            
            # Interpola
            if prev_point.time == next_point.time:
                value = prev_point.value
            else:
                prev_min = prev_point.to_minutes()
                next_min = next_point.to_minutes()
                
                if next_min < prev_min:
                    next_min += 24 * 60
                
                if next_min == prev_min:
                    ratio = 0
                else:
                    ratio = (i - prev_min) / (next_min - prev_min)
                
                value = prev_point.value + ratio * (next_point.value - prev_point.value)
            
            new_points.append(SchedulePoint(time=time_str, value=round(value, 2)))
        
        return new_points
    
    @staticmethod
    def _select(points, to_interval: int):
        """Seleziona solo punti su intervallo."""
        target_times = set()
        for i in range(0, 24 * 60, to_interval):
            h = i // 60
            m = i % 60
            target_times.add(f"{h:02d}:{m:02d}")
        
        return [p for p in points if p.time in target_times]


class IntervalService:
    """Servizi intervalli."""
    
    def __init__(self, hass: HomeAssistant, storage_manager):
        self.hass = hass
        self.storage_manager = storage_manager
    
    async def convert_schedule_interval(self, call: ServiceCall) -> ServiceResponse:
        """Converte schedule a nuovo intervallo."""
        profile_name = call.data.get("profile_name")
        preset_type = call.data.get("preset_type")
        global_prefix = call.data.get("global_prefix", "cronostar_")
        target_minutes = int(call.data.get("target_interval", 60))
        save_as = call.data.get("save_as")
        
        target_interval = IntervalType.from_minutes(target_minutes)
        if not target_interval:
            return {
                "success": False,
                "error": f"Invalid interval: {target_minutes}"
            }
        
        schedule = await self.storage_manager.load_schedule(
            profile_name,
            preset_type,
            global_prefix
        )
        
        if not schedule:
            return {
                "success": False,
                "error": f"Schedule not found: {profile_name}"
            }
        
        converted = IntervalConverter.convert_schedule(schedule, target_interval)
        
        if save_as:
            converted.profile_name = save_as
        
        success = await self.storage_manager.save_schedule(converted)
        
        return {
            "success": success,
            "original_interval": schedule.interval_minutes,
            "new_interval": converted.interval_minutes,
            "original_points": len(schedule.points),
            "new_points": len(converted.points),
            "profile_name": converted.profile_name
        }
    
    async def get_schedule_info(self, call: ServiceCall) -> ServiceResponse:
        """Info su schedule."""
        profile_name = call.data.get("profile_name")
        preset_type = call.data.get("preset_type")
        global_prefix = call.data.get("global_prefix", "cronostar_")
        
        schedule = await self.storage_manager.load_schedule(
            profile_name,
            preset_type,
            global_prefix
        )
        
        if not schedule:
            return {
                "success": False,
                "error": f"Schedule not found: {profile_name}"
            }
        
        values = [p.value for p in schedule.points]
        
        return {
            "success": True,
            "profile_name": schedule.profile_name,
            "preset_type": schedule.preset_type,
            "interval_minutes": schedule.interval_minutes,
            "points": [{"time": p.time, "value": p.value} for p in schedule.points],
            "points_count": len(schedule.points),
            "min_value": min(values) if values else None,
            "max_value": max(values) if values else None,
            "avg_value": sum(values) / len(values) if values else None
        }


# --- File: custom_components/cronostar/services/profile_service.py ---
# Real size: 21833 bytes, Used: 21833 bytes
"""Profile management with BACKWARD COMPATIBILITY for old format."""
import logging
import time
from datetime import datetime
from collections import OrderedDict
import json

from homeassistant.core import HomeAssistant, ServiceCall, ServiceResponse

from ..utils.filename_builder import build_profile_filename
from ..utils.prefix_normalizer import normalize_preset_type, PRESETS_CONFIG
from .file_service import FileService

_LOGGER = logging.getLogger(__name__)

class ProfileService:
    def __init__(self, hass: HomeAssistant, file_service: FileService, storage_manager):
        self.hass = hass
        self.file_service = file_service
        self.storage = storage_manager

    def _to_iso8601(self, timestamp=None):
        """Convert timestamp to ISO 8601 format."""
        if timestamp is None:
            timestamp = time.time()
        return datetime.fromtimestamp(timestamp).isoformat()

    def _optimize_schedule(self, schedule):
        """Remove redundant points where value doesn't change."""
        if not schedule or len(schedule) <= 2:
            return schedule
        
        optimized = [schedule[0]]
        
        for i in range(1, len(schedule) - 1):
            prev_val = schedule[i - 1].get('value')
            curr_val = schedule[i].get('value')
            next_val = schedule[i + 1].get('value')
            
            if abs(curr_val - prev_val) > 0.01 or abs(curr_val - next_val) > 0.01:
                optimized.append(schedule[i])
        
        optimized.append(schedule[-1])
        
        removed = len(schedule) - len(optimized)
        if removed > 0:
            _LOGGER.info("Optimized schedule: removed %d redundant points", removed)
        
        return optimized

    def _time_to_minutes(self, t: str) -> int:
        """Convert HH:MM to minutes since midnight, clamp to [0, 1439]."""
        try:
            parts = str(t).strip().split(":")
            h = int(parts[0]) if parts and parts[0] != '' else 0
            m = int(parts[1]) if len(parts) > 1 and parts[1] != '' else 0
            total = max(0, min(23, h)) * 60 + max(0, min(59, m))
            return min(total, 1439)
        except Exception:
            return 0

    def _minutes_to_time(self, minutes: int) -> str:
        minutes = max(0, min(1439, int(minutes)))
        h = minutes // 60
        m = minutes % 60
        return f"{h:02d}:{m:02d}"

    def _normalize_schedule(self, schedule):
        """Ensure schedule is sorted and contains 00:00 and 23:59 boundary points."""
        if not isinstance(schedule, list):
            return []

        # Map minute -> value (last wins for duplicates)
        by_minute = {}
        for item in schedule:
            if not isinstance(item, dict):
                continue
            t = item.get('time')
            v = item.get('value')
            if t is None or v is None:
                continue
            minute = self._time_to_minutes(t)
            by_minute[minute] = v

        if not by_minute:
            return []

        # Ensure boundaries
        sorted_minutes = sorted(by_minute.keys())
        first_minute = sorted_minutes[0]
        last_minute = sorted_minutes[-1]
        first_value = by_minute[first_minute]
        last_value = by_minute[last_minute]

        if 0 not in by_minute:
            by_minute[0] = first_value
        if 1439 not in by_minute:
            by_minute[1439] = last_value

        # Build sorted list
        normalized = [
            { 'time': self._minutes_to_time(m), 'value': by_minute[m] }
            for m in sorted(by_minute.keys())
        ]

        return normalized

    async def save_profile(self, call: ServiceCall):
        """Save a profile with ISO 8601 dates and new container format."""
        # Log inbound payload (best-effort, keep it compact).
        try:
            data = dict((getattr(call, "service_data", None) or getattr(call, "data", None) or {}))
            # Avoid huge logs
            if isinstance(data.get("schedule"), list):
                data["schedule_len"] = len(data.get("schedule"))
                data.pop("schedule", None)
            if isinstance(data.get("meta"), dict):
                # Don't spam with whole config; only show key set
                data["meta_keys"] = sorted(list(data.get("meta").keys()))
                data.pop("meta", None)
            _LOGGER.info("[PROFILE] save_profile: inbound data=%s", json.dumps(data, ensure_ascii=False, default=str))
        except Exception:
            pass

        payload = getattr(call, "service_data", None) or getattr(call, "data", None) or {}

        profile_name = payload.get("profile_name")
        preset_type = payload.get("preset_type")
        schedule = payload.get("schedule")
        global_prefix = payload.get("global_prefix")

        # NOTE: schedule can legitimately be an empty list.
        # Also, some callers may persist meta-only updates.
        if not profile_name or not preset_type:
            missing = []
            if not profile_name:
                missing.append("profile_name")
            if not preset_type:
                missing.append("preset_type")
            _LOGGER.warning(
                "save_profile: Missing required parameters: %s (profile_name=%s preset_type=%s global_prefix=%s schedule_is_none=%s)",
                ",".join(missing) if missing else "<unknown>",
                profile_name,
                preset_type,
                global_prefix,
                schedule is None,
            )
            return
        
        canonical = normalize_preset_type(preset_type)
        
        if not global_prefix:
            _LOGGER.warning(
                "save_profile: Missing required parameter global_prefix (profile_name=%s preset_type=%s schedule_is_none=%s)",
                profile_name,
                preset_type,
                schedule is None,
            )
            return

        if schedule is None:
            schedule = []

        filename = build_profile_filename(profile_name, canonical, global_prefix=global_prefix)
        
        _LOGGER.info(
            "=== SAVE PROFILE START === Profile: '%s', Preset: %s, File: %s",
            profile_name,
            canonical,
            filename
        )
        try:
            _LOGGER.info("[PROFILE] Incoming schedule points: %d; first=%s; last=%s",
                         len(schedule) if isinstance(schedule, list) else -1,
                         schedule[0] if isinstance(schedule, list) and schedule else None,
                         schedule[-1] if isinstance(schedule, list) and schedule else None)
        except Exception:
            pass
        
        # Normalize and optimize schedule (ensure 00:00 and 23:59 bounds)
        normalized_schedule = self._normalize_schedule(schedule)
        optimized_schedule = self._optimize_schedule(normalized_schedule)
        try:
            _LOGGER.info("[PROFILE] Normalized schedule points: %d; first=%s; last=%s",
                         len(normalized_schedule),
                         normalized_schedule[0] if normalized_schedule else None,
                         normalized_schedule[-1] if normalized_schedule else None)
            _LOGGER.info("[PROFILE] Optimized schedule points: %d; first=%s; last=%s",
                         len(optimized_schedule),
                         optimized_schedule[0] if optimized_schedule else None,
                         optimized_schedule[-1] if optimized_schedule else None)
        except Exception:
            pass
        
        # Load existing data
        existing_data = await self.storage.load_profile_cached(filename) or {}
        
        # MIGRATE old format to new if needed
        if "meta" not in existing_data and "profile_name" in existing_data:
            _LOGGER.info("Migrating old format to new container format")
            old_profile_name = existing_data.get("profile_name", "Default")
            old_schedule = existing_data.get("schedule", [])
            
            existing_data = {
                "meta": {
                    "global_prefix": global_prefix,
                    "preset_type": canonical,
                    "created_at": self._to_iso8601(existing_data.get("saved_at", time.time())),
                    "updated_at": self._to_iso8601()
                },
                "profiles": {
                    old_profile_name: {
                        "schedule": old_schedule,
                        "updated_at": self._to_iso8601(existing_data.get("saved_at", time.time()))
                    }
                }
            }
        
        # Prepare NEW container structure
        new_data = OrderedDict()
        
        if "meta" in existing_data:
            new_data["meta"] = existing_data["meta"]
            new_data["meta"]["updated_at"] = self._to_iso8601()
        else:
            new_data["meta"] = {
                "global_prefix": global_prefix,
                "preset_type": canonical,
                "created_at": self._to_iso8601(),
                "updated_at": self._to_iso8601()
            }

        # Always enforce canonical identifiers in meta (do not rely on previous files)
        try:
            new_data["meta"]["global_prefix"] = global_prefix
            new_data["meta"]["preset_type"] = canonical
        except Exception:
            pass

        # Persist wizard/card configuration in meta (best-effort).
        # This allows SmartScheduler to discover target_entity and other settings from JSON.
        wizard_meta = payload.get("meta")
        if isinstance(wizard_meta, dict) and wizard_meta:
            try:
                # Defensive: never persist deprecated keys
                wizard_meta.pop("entity_prefix", None)
                new_data["meta"].update(wizard_meta)
            except Exception:
                pass
        
        if "profiles" in existing_data:
            new_data["profiles"] = existing_data["profiles"]
        else:
            new_data["profiles"] = {}
        
        # Update specific profile
        new_data["profiles"][profile_name] = {
            "schedule": optimized_schedule,
            "updated_at": self._to_iso8601()
        }
        
        # Atomic save
        success = await self.storage.save_profile_atomic(filename, new_data, backup=True)
        
        if success:
            _LOGGER.info("âœ… Profile saved successfully!")
            await self.async_update_profile_selectors()
        else:
            _LOGGER.error("âŒ Failed to save profile container: %s", filename)
        
        _LOGGER.info("=== SAVE PROFILE END ===")
    
    async def get_profile_data(
        self,
        profile_name: str,
        preset_type: str,
        global_prefix: str | None = None
    ) -> dict:
        """Fetch profile data with BACKWARD COMPATIBILITY."""
        # Input validation with logging
        if not all((profile_name, preset_type)):
            _LOGGER.warning(
                "[PROFILE] get_profile_data called with missing parameters: profile_name=%s, preset_type=%s",
                profile_name,
                preset_type,
            )
            return {"error": "Missing parameters"}
        
        canonical = normalize_preset_type(preset_type)
        _LOGGER.debug("[PROFILE] normalized preset_type: '%s' -> '%s'", preset_type, canonical)
        
        if not global_prefix:
            _LOGGER.warning("[PROFILE] get_profile_data missing global_prefix for profile '%s'", profile_name)
            return {"error": "Missing global_prefix"}

        filenames_to_try = [build_profile_filename(profile_name, canonical, global_prefix=global_prefix)]
        _LOGGER.info(
            "[PROFILE] get_profile_data: name=%s, preset=%s, global_prefix=%s, filenames_to_try=%s",
            profile_name,
            canonical,
            global_prefix,
            filenames_to_try,
        )
        
        for filename in filenames_to_try:
            _LOGGER.debug("[PROFILE] Attempting to load cached container: %s", filename)
            data = await self.storage.load_profile_cached(filename)
            
            if not data:
                _LOGGER.debug("[PROFILE] No data found for: %s", filename)
                continue
            else:
                meta = data.get("meta", {})
                keys = list(data.keys())
                _LOGGER.debug("[PROFILE] Container loaded: keys=%s, meta=%s", keys, meta)
            
            # NEW FORMAT: Container with meta + profiles
            if "profiles" in data:
                available_profiles = list(data.get("profiles", {}).keys())
                _LOGGER.debug("[PROFILE] Available profiles in container: %s", available_profiles)
                if profile_name in data["profiles"]:
                    profile_content = data["profiles"][profile_name]
                    profile_content["global_prefix"] = data.get("meta", {}).get("global_prefix")
                    profile_content["profile_name"] = profile_name
                    sched = profile_content.get("schedule", [])
                    _LOGGER.info(
                        "[PROFILE] Profile '%s' extracted: points=%d, first=%s, last=%s (file=%s)",
                        profile_name,
                        len(sched),
                        sched[0] if sched else None,
                        sched[-1] if sched else None,
                        filename,
                    )
                    return profile_content
                else:
                    _LOGGER.warning(
                        "[PROFILE] Requested profile '%s' not present in container (available=%s)",
                        profile_name,
                        available_profiles,
                    )
            else:
                _LOGGER.warning("[PROFILE] Unsupported container format (missing 'profiles') for %s", filename)
            
            # OLD FORMAT is not supported anymore
        
        _LOGGER.warning(
            "[PROFILE] Profile not found: name=%s, preset=%s, global_prefix=%s",
            profile_name,
            canonical,
            global_prefix,
        )
        return {"error": "Profile not found"}

    async def load_profile(self, call: ServiceCall) -> ServiceResponse:
        """Load a profile."""
        profile_name = call.data.get("profile_name")
        preset_type = call.data.get("preset_type")
        global_prefix = call.data.get("global_prefix")
        
        _LOGGER.info(
            "=== LOAD PROFILE START === Profile: '%s', Preset: %s",
            profile_name,
            preset_type
        )
        
        result = await self.get_profile_data(
            profile_name, 
            preset_type, 
            global_prefix
        )
        
        if "error" not in result:
            try:
                sched = result.get("schedule", [])
                _LOGGER.info(
                    "âœ… Profile loaded: name=%s, points=%d, first=%s, last=%s",
                    profile_name,
                    len(sched),
                    sched[0] if sched else None,
                    sched[-1] if sched else None,
                )
            except Exception:
                _LOGGER.info("âœ… Profile loaded successfully: %s", profile_name)
        else:
            _LOGGER.warning("âš ï¸ Profile load failed: %s", result.get("error"))
        
        _LOGGER.info("=== LOAD PROFILE END ===")
        return result
    
    async def add_profile(self, call: ServiceCall):
        """Create a new profile with default values."""
        profile_name = call.data.get("profile_name")
        preset_type = call.data.get("preset_type")
        global_prefix = call.data.get("global_prefix")
        
        if not all((profile_name, preset_type)):
            return
        
        canonical = normalize_preset_type(preset_type)
        
        # Get default value
        default_value = 20 if canonical == "thermostat" else 0
        # Minimal sparse default schedule with boundaries
        default_schedule = [
            {"time": "00:00", "value": default_value},
            {"time": "23:59", "value": default_value},
        ]
        
        if not global_prefix:
            _LOGGER.warning("add_profile: Missing required parameter global_prefix")
            return

        filename = build_profile_filename(profile_name, canonical, global_prefix=global_prefix)
        
        # Create NEW format container
        profile_data = {
            "meta": {
                "global_prefix": global_prefix,
                "preset_type": canonical,
                "created_at": self._to_iso8601(),
                "updated_at": self._to_iso8601()
            },
            "profiles": {
                profile_name: {
                    "schedule": self._normalize_schedule(default_schedule),
                    "updated_at": self._to_iso8601()
                }
            }
        }
        
        _LOGGER.info("Creating new profile: %s", filename)
        _LOGGER.info("[PROFILE] Default schedule points: %d -> %s ... %s",
                 len(profile_data["profiles"][profile_name]["schedule"]),
                 profile_data["profiles"][profile_name]["schedule"][0],
                 profile_data["profiles"][profile_name]["schedule"][-1])
        
        success = await self.storage.save_profile_atomic(filename, profile_data, backup=False)
        
        if success:
            _LOGGER.info("âœ… Profile created: %s", filename)
            await self.async_update_profile_selectors()
        else:
            _LOGGER.error("âŒ Failed to create profile: %s", filename)
    
    async def delete_profile(self, call: ServiceCall):
        """Delete a profile."""
        profile_name = call.data.get("profile_name")
        preset_type = call.data.get("preset_type")
        global_prefix = call.data.get("global_prefix")
        
        if not all((profile_name, preset_type)):
            return
        
        canonical = normalize_preset_type(preset_type)
        
        filenames_to_delete = []
        
        if not global_prefix:
            _LOGGER.warning("delete_profile: Missing required parameter global_prefix")
            return

        filenames_to_delete.append(build_profile_filename(profile_name, canonical, global_prefix=global_prefix))
        
        deleted = False
        for filename in filenames_to_delete:
            if await self.storage.delete_profile(filename):
                deleted = True
                _LOGGER.info("âœ… Profile deleted: %s", filename)
        
        if not deleted:
            _LOGGER.warning("âŒ No profile file found to delete: %s", profile_name)
        else:
            await self.async_update_profile_selectors()
    
    async def async_update_profile_selectors(self):
        """Scan profiles and update input_select entities."""
        _LOGGER.info("Updating profile selectors...")
        
        profiles_by_preset = {}
        all_files = await self.storage.list_profiles()
        
        for filename in all_files:
            try:
                container_data = await self.storage.load_profile_cached(filename)
                
                if not container_data:
                    continue
                
                # NEW format
                if "meta" in container_data:
                    preset_type = container_data["meta"].get("preset_type")
                    profiles_dict = container_data.get("profiles", {})
                    
                    if preset_type and profiles_dict:
                        canonical_preset = normalize_preset_type(preset_type)
                        
                        if canonical_preset not in profiles_by_preset:
                            profiles_by_preset[canonical_preset] = []
                        
                        profiles_by_preset[canonical_preset].extend(profiles_dict.keys())
                
                # OLD format
                elif "profile_name" in container_data:
                    preset_type = container_data.get("preset_type", "thermostat")
                    profile_name = container_data.get("profile_name")
                    
                    canonical_preset = normalize_preset_type(preset_type)
                    
                    if canonical_preset not in profiles_by_preset:
                        profiles_by_preset[canonical_preset] = []
                    
                    profiles_by_preset[canonical_preset].append(profile_name)
            
            except Exception as e:
                _LOGGER.warning("Could not read profile container %s: %s", filename, e)
        
        # Update input_select entities
        for preset, config in PRESETS_CONFIG.items():
            selector_entity_id = config.get("profiles_select")
            
            if not selector_entity_id or preset not in profiles_by_preset:
                continue
            
            current_state = self.hass.states.get(selector_entity_id)
            current_options = current_state.attributes.get("options", []) if current_state else []
            
            new_options = sorted(list(set(profiles_by_preset[preset])))
            
            if set(current_options) != set(new_options):
                _LOGGER.info("Updating %s with %d profiles", selector_entity_id, len(new_options))
                
                try:
                    await self.hass.services.async_call(
                        "input_select",
                        "set_options",
                        {"entity_id": selector_entity_id, "options": new_options},
                        blocking=True,
                    )
                except Exception as e:
                    _LOGGER.error("Failed to update %s: %s", selector_entity_id, e)


# --- File: custom_components/cronostar/services/scheduler_service.py ---
# Real size: 14289 bytes, Used: 14289 bytes
"""CronoStar Scheduler Service - Automatic value updates based on schedule."""

import logging
from datetime import datetime, timedelta
from typing import Dict, Optional, List
import asyncio

from homeassistant.core import HomeAssistant, ServiceCall, callback
from homeassistant.helpers.event import async_track_point_in_time
from homeassistant.util import dt as dt_util

from ..utils.prefix_normalizer import normalize_preset_type, normalize_prefix, PRESETS_CONFIG

_LOGGER = logging.getLogger(__name__)


class SchedulerService:
    """Manages automatic schedule updates for all presets."""

    def __init__(self, hass: HomeAssistant, profile_service):
        """Initialize the scheduler service."""
        self.hass = hass
        self.profile_service = profile_service
        self.active_timers: Dict[str, callable] = {}
        self.cached_schedules: Dict[str, Dict] = {}
        self.check_interval = 60  # Default: check every minute

        _LOGGER.info("SchedulerService initialized. check_interval=%s", self.check_interval)
        _LOGGER.debug("SchedulerService: PRESETS_CONFIG keys: %s", list(PRESETS_CONFIG.keys()))

    async def async_start(self):
        """Start the scheduler for all presets."""
        _LOGGER.info("SchedulerService: async_start called")
        if not PRESETS_CONFIG:
            _LOGGER.warning("SchedulerService: PRESETS_CONFIG is empty, nothing to schedule")
            return

        for preset in PRESETS_CONFIG.keys():
            _LOGGER.info("SchedulerService: starting scheduler for preset=%s", preset)
            await self._start_preset_scheduler(preset)

    async def _start_preset_scheduler(self, preset: str):
        """Start scheduler for a specific preset."""
        _LOGGER.debug("_start_preset_scheduler called for preset=%s", preset)

        config = PRESETS_CONFIG.get(preset, {})
        _LOGGER.debug("Preset %s config: %s", preset, config)

        current_value_entity = config.get("current_value_entity")
        if not current_value_entity:
            _LOGGER.debug("No current_value_entity for preset %s, skipping", preset)
            return

        # Load active profile for this preset
        _LOGGER.info("Loading and applying schedule for preset=%s", preset)
        await self._load_and_apply_schedule(preset)

        # Schedule next update
        _LOGGER.info("Scheduling next update for preset=%s", preset)
        await self._schedule_next_update(preset)

    async def _load_and_apply_schedule(self, preset: str):
        """Load schedule from active profile and apply current value."""
        _LOGGER.debug("_load_and_apply_schedule called for preset=%s", preset)

        config = PRESETS_CONFIG.get(preset, {})
        profiles_select = config.get("profiles_select")
        if not profiles_select:
            _LOGGER.warning("No profiles_select configured for preset %s, skipping", preset)
            return

        # Get active profile name
        select_state = self.hass.states.get(profiles_select)
        if not select_state:
            _LOGGER.warning("profiles_select entity %s not found for preset %s", profiles_select, preset)
            return

        profile_name = select_state.state
        _LOGGER.info(
            "Preset %s using active profile '%s' from %s",
            preset,
            profile_name,
            profiles_select,
        )

        # Load profile data
        try:
            _LOGGER.debug("Loading profile data for preset=%s profile=%s", preset, profile_name)
            profile_data = await self.profile_service.load_profile_from_call(
                {
                    "profile_name": profile_name,
                    "preset_type": preset,
                }
            )

            _LOGGER.debug("Profile data loaded for preset=%s: keys=%s", preset, list(profile_data.keys()))

            if "error" in profile_data:
                _LOGGER.warning(
                    "Failed to load profile '%s' for preset '%s': %s",
                    profile_name,
                    preset,
                    profile_data.get("error"),
                )
                return

            # Cache the schedule
            self.cached_schedules[preset] = profile_data
            _LOGGER.info("Cached schedule for preset=%s", preset)

            # Apply current value
            await self._apply_current_value(preset, profile_data)

        except Exception as e:
            _LOGGER.error("Error loading schedule for %s: %s", preset, e)

    async def _apply_current_value(self, preset: str, profile_data: Dict):
        """Apply the appropriate value for current time."""
        _LOGGER.debug("_apply_current_value called for preset=%s", preset)

        config = PRESETS_CONFIG.get(preset, {})
        current_value_entity = config.get("current_value_entity")
        if not current_value_entity:
            _LOGGER.warning("No current_value_entity configured for preset %s", preset)
            return

        # Get schedule and interval
        schedule = profile_data.get("schedule", [])
        interval_minutes = profile_data.get("interval_minutes", 60)
        _LOGGER.debug(
            "Preset %s: schedule length=%d, interval_minutes=%s",
            preset,
            len(schedule),
            interval_minutes,
        )

        # Find current value
        current_value = self._get_value_for_time(schedule, interval_minutes)
        _LOGGER.debug("Preset %s: current_value computed=%s", preset, current_value)

        if current_value is None:
            _LOGGER.info("No current value found for preset %s at this time", preset)
            return

        # Update input_number
        try:
            _LOGGER.info(
                "Calling input_number.set_value for %s with value=%s (preset=%s)",
                current_value_entity,
                current_value,
                preset,
            )
            await self.hass.services.async_call(
                "input_number",
                "set_value",
                {
                    "entity_id": current_value_entity,
                    "value": current_value,
                },
                blocking=True,
            )

            _LOGGER.info(
                "Updated %s to value %.2f for preset %s",
                current_value_entity,
                current_value,
                preset,
            )

            # Also apply to target entity if configured
            await self._apply_to_target(preset, current_value)

        except Exception as e:
            _LOGGER.error("Error updating %s: %s", current_value_entity, e)

    def _get_value_for_time(
        self,
        schedule: List[Dict],
        interval_minutes: int,
        target_time: Optional[datetime] = None,
    ) -> Optional[float]:
        """Get the scheduled value for a specific time."""
        if not schedule:
            _LOGGER.debug("_get_value_for_time: empty schedule")
            return None

        if target_time is None:
            target_time = dt_util.now()

        minutes_since_midnight = target_time.hour * 60 + target_time.minute
        _LOGGER.debug(
            "_get_value_for_time: target_time=%s, minutes_since_midnight=%d, interval_minutes=%d",
            target_time,
            minutes_since_midnight,
            interval_minutes,
        )

        # Find the appropriate schedule entry
        for entry in schedule:
            entry_minutes = entry.get("minutes_from_midnight", 0)
            value = entry.get("value")
            if entry_minutes <= minutes_since_midnight < entry_minutes + interval_minutes:
                _LOGGER.debug(
                    "_get_value_for_time: matched entry minutes=%d value=%s",
                    entry_minutes,
                    value,
                )
                return float(value)

        # If no match, use last entry (wrap around)
        if schedule:
            last_value = schedule[-1].get("value", 0)
            _LOGGER.debug(
                "_get_value_for_time: no match, using last entry value=%s",
                last_value,
            )
            return float(last_value)

        return None

    def _calculate_next_change(
        self,
        schedule: List[Dict],
        interval_minutes: int,
    ) -> Optional[datetime]:
        """Calculate when the next value change occurs."""
        if not schedule:
            _LOGGER.debug("_calculate_next_change: empty schedule")
            return None

        now = dt_util.now()
        current_minutes = now.hour * 60 + now.minute
        _LOGGER.debug(
            "_calculate_next_change: now=%s, current_minutes=%d",
            now,
            current_minutes,
        )

        # Find next schedule entry
        for entry in schedule:
            entry_minutes = entry.get("minutes_from_midnight", 0)
            if entry_minutes > current_minutes:
                target_time = now.replace(
                    hour=entry_minutes // 60,
                    minute=entry_minutes % 60,
                    second=0,
                    microsecond=0,
                )
                _LOGGER.debug(
                    "_calculate_next_change: next change today at %s (entry_minutes=%d)",
                    target_time,
                    entry_minutes,
                )
                return target_time

        # Next change is first entry tomorrow
        first_entry_minutes = schedule[0].get("minutes_from_midnight", 0)
        tomorrow = now + timedelta(days=1)
        target_time = tomorrow.replace(
            hour=first_entry_minutes // 60,
            minute=first_entry_minutes % 60,
            second=0,
            microsecond=0,
        )
        _LOGGER.debug(
            "_calculate_next_change: next change tomorrow at %s (first_entry_minutes=%d)",
            target_time,
            first_entry_minutes,
        )
        return target_time

    async def _schedule_next_update(self, preset: str):
        """Schedule the next automatic update."""
        _LOGGER.debug("_schedule_next_update called for preset=%s", preset)

        profile_data = self.cached_schedules.get(preset)
        if not profile_data:
            _LOGGER.warning(
                "No cached schedule for preset %s, using fallback interval %s seconds",
                preset,
                self.check_interval,
            )
            next_check = dt_util.now() + timedelta(seconds=self.check_interval)
        else:
            schedule = profile_data.get("schedule", [])
            interval_minutes = profile_data.get("interval_minutes", 60)
            _LOGGER.debug(
                "Scheduling next update for preset=%s, schedule_len=%d, interval_minutes=%s",
                preset,
                len(schedule),
                interval_minutes,
            )

            next_change = self._calculate_next_change(schedule, interval_minutes)
            if next_change:
                next_check = next_change
            else:
                _LOGGER.warning(
                    "Could not calculate next change for preset %s, using fallback interval %s seconds",
                    preset,
                    self.check_interval,
                )
                next_check = dt_util.now() + timedelta(seconds=self.check_interval)

        timer_key = f"{preset}_timer"

        # Cancel existing timer
        if timer_key in self.active_timers:
            _LOGGER.debug("Cancelling existing timer for preset=%s", preset)
            self.active_timers[timer_key]()
            del self.active_timers[timer_key]

        @callback
        async def update_callback(now):
            """Handle scheduled update."""
            _LOGGER.info("update_callback fired for preset=%s at %s", preset, now)
            await self._load_and_apply_schedule(preset)
            await self._schedule_next_update(preset)

        cancel = async_track_point_in_time(
            self.hass,
            update_callback,
            next_check,
        )

        self.active_timers[timer_key] = cancel
        _LOGGER.debug(
            "Scheduled next update for %s at %s",
            preset,
            next_check.strftime("%Y-%m-%d %H:%M:%S"),
        )

    async def _apply_to_target(self, preset: str, value: float):
        """Apply value to target entity if configured."""
        config = PRESETS_CONFIG.get(preset, {})
        # This would need target entity info - for now just log
        _LOGGER.debug(
            "_apply_to_target called: preset=%s, value=%.2f, config=%s",
            preset,
            value,
            config,
        )

    async def start_scheduler(self, call: ServiceCall):
        """Service call to start scheduler."""
        preset = call.data.get("preset")
        _LOGGER.info("Service start_scheduler called with preset=%s", preset)

        if preset:
            await self._start_preset_scheduler(preset)
        else:
            await self.async_start()

    async def stop_scheduler(self, call: ServiceCall):
        """Service call to stop scheduler."""
        preset = call.data.get("preset")
        _LOGGER.info("Service stop_scheduler called with preset=%s", preset)

        if preset:
            timer_key = f"{preset}_timer"
            if timer_key in self.active_timers:
                self.active_timers[timer_key]()
                del self.active_timers[timer_key]
                _LOGGER.info("Stopped scheduler for %s", preset)
            else:
                _LOGGER.warning("No active timer found for preset %s", preset)
        else:
            # Stop all
            for cancel in self.active_timers.values():
                cancel()
            self.active_timers.clear()
            _LOGGER.info("Stopped all schedulers")

    async def reload_schedule(self, call: ServiceCall):
        """Service call to reload schedule."""
        preset = call.data.get("preset")
        _LOGGER.info("Service reload_schedule called with preset=%s", preset)

        if preset:
            await self._load_and_apply_schedule(preset)
            _LOGGER.info("Reloaded schedule for %s", preset)
        else:
            for preset_name in PRESETS_CONFIG.keys():
                await self._load_and_apply_schedule(preset_name)
            _LOGGER.info("Reloaded all schedules")


# --- File: custom_components/cronostar/storage/storage_manager.py ---
# Real size: 12377 bytes, Used: 12377 bytes
"""
CronoStar Storage Manager - Centralizes all profile storage operations.
Handles atomic saves, concurrent access, and profile versioning.
"""
import logging
import os
import json
import time
from datetime import datetime, timezone
import asyncio
from typing import Dict, List, Optional, Any
from functools import partial
from pathlib import Path

from homeassistant.core import HomeAssistant

_LOGGER = logging.getLogger(__name__)

class StorageManager:
    """Centralized storage management for CronoStar profiles."""
    
    def __init__(self, hass: HomeAssistant, profiles_dir: str):
        """Initialize storage manager.
        
        Args:
            hass: Home Assistant instance
            profiles_dir: Directory for profile storage
        """
        self.hass = hass
        self.profiles_dir = Path(profiles_dir)
        self._locks: Dict[str, asyncio.Lock] = {}
        self._cache: Dict[str, Dict[str, Any]] = {}
        self._cache_timeout = 30  # seconds
        
        # Ensure directory exists
        self.profiles_dir.mkdir(parents=True, exist_ok=True)
        _LOGGER.info("StorageManager initialized: %s", self.profiles_dir)
    
    def _get_lock(self, filename: str) -> asyncio.Lock:
        """Get or create a lock for a specific file."""
        if filename not in self._locks:
            self._locks[filename] = asyncio.Lock()
        return self._locks[filename]
    
    async def save_profile_atomic(
        self,
        filename: str,
        profile_data: Dict[str, Any],
        backup: bool = True
    ) -> bool:
        """Save profile with atomic write and optional backup.
        
        Args:
            filename: Profile filename
            profile_data: Profile data to save
            backup: Whether to create backup of existing file
            
        Returns:
            True if save successful, False otherwise
        """
        file_path = self.profiles_dir / filename
        lock = self._get_lock(filename)
        
        async with lock:
            try:
                # Add metadata
                # Save both epoch (backward-compatible) and ISO 8601 UTC timestamp
                now_ts = time.time()
                profile_data["saved_at"] = now_ts
                profile_data["saved_at_iso"] = datetime.fromtimestamp(now_ts, tz=timezone.utc).isoformat().replace("+00:00", "Z")
                profile_data["version"] = 2  # Storage format version
                
                # Create backup if file exists and backup is requested
                if backup and file_path.exists():
                    backup_path = file_path.with_suffix(f".{int(time.time())}.bak")
                    await self.hass.async_add_executor_job(
                        self._copy_file, file_path, backup_path
                    )
                    _LOGGER.debug("Backup created: %s", backup_path.name)
                
                # Atomic write: write to temp file, then rename
                temp_path = file_path.with_suffix(".tmp")
                await self.hass.async_add_executor_job(
                    self._write_json, temp_path, profile_data
                )
                await self.hass.async_add_executor_job(
                    self._rename_file, temp_path, file_path
                )
                
                # Update cache
                self._cache[filename] = {
                    "data": profile_data,
                    "timestamp": time.time()
                }
                
                # Log a concise summary of what was written
                try:
                    profiles = profile_data.get("profiles", {}) if isinstance(profile_data, dict) else {}
                    profile_names = list(profiles.keys())
                    first_name = profile_names[0] if profile_names else None
                    sched = profiles.get(first_name, {}).get("schedule", []) if first_name else []
                    _LOGGER.info(
                        "[STORAGE] Saved profile container: file=%s, profiles=%d, first_profile=%s, schedule_points=%d",
                        filename,
                        len(profile_names),
                        first_name,
                        len(sched),
                    )
                except Exception:
                    _LOGGER.info("Profile saved atomically: %s", filename)
                return True
                
            except Exception as e:
                _LOGGER.error("Failed to save profile %s: %s", filename, e)
                return False
    
    async def load_profile_cached(
        self,
        filename: str,
        force_reload: bool = False
    ) -> Optional[Dict[str, Any]]:
        """Load profile with caching support.
        
        Args:
            filename: Profile filename
            force_reload: Force reload from disk, bypassing cache
            
        Returns:
            Profile data or None if not found
        """
        # Check cache first
        if not force_reload and filename in self._cache:
            cache_entry = self._cache[filename]
            age = time.time() - cache_entry["timestamp"]
            
            if age < self._cache_timeout:
                _LOGGER.debug("Cache hit for %s (age: %.1fs)", filename, age)
                return cache_entry["data"]
        
        # Load from disk
        file_path = self.profiles_dir / filename
        
        if not file_path.exists():
            _LOGGER.info("[STORAGE] Profile file not found: %s", file_path)
            return None
        
        try:
            data = await self.hass.async_add_executor_job(
                self._read_json, file_path
            )
            
            # Update cache
            self._cache[filename] = {
                "data": data,
                "timestamp": time.time()
            }
            
            # Log a concise summary of what was read
            try:
                if isinstance(data, dict):
                    if "profiles" in data:
                        profiles = data.get("profiles", {})
                        names = list(profiles.keys())
                        first_name = names[0] if names else None
                        sched = profiles.get(first_name, {}).get("schedule", []) if first_name else []
                        _LOGGER.info(
                            "[STORAGE] Loaded container: file=%s, profiles=%d, first_profile=%s, schedule_points=%d",
                            file_path,
                            len(names),
                            first_name,
                            len(sched),
                        )
                    elif "profile_name" in data:
                        name = data.get("profile_name")
                        sched = data.get("schedule", [])
                        _LOGGER.info(
                            "[STORAGE] Loaded legacy profile: file=%s, profile=%s, schedule_points=%d",
                            file_path,
                            name,
                            len(sched),
                        )
                    else:
                        _LOGGER.info("[STORAGE] Loaded JSON file: %s", file_path)
                else:
                    _LOGGER.info("[STORAGE] Loaded non-dict JSON from: %s", file_path)
            except Exception:
                _LOGGER.debug("Profile loaded from disk: %s", filename)
            return data
            
        except Exception as e:
            _LOGGER.error("Failed to load profile %s: %s", filename, e)
            return None
    
    async def delete_profile(self, filename: str) -> bool:
        """Delete a profile file.
        
        Args:
            filename: Profile filename to delete
            
        Returns:
            True if deleted successfully
        """
        file_path = self.profiles_dir / filename
        lock = self._get_lock(filename)
        
        async with lock:
            try:
                if file_path.exists():
                    await self.hass.async_add_executor_job(file_path.unlink)
                    
                    # Clear cache
                    self._cache.pop(filename, None)
                    
                    _LOGGER.info("Profile deleted: %s", filename)
                    return True
                else:
                    _LOGGER.warning("Profile not found for deletion: %s", filename)
                    return False
                    
            except Exception as e:
                _LOGGER.error("Failed to delete profile %s: %s", filename, e)
                return False
    
    async def list_profiles(
        self,
        preset_type: Optional[str] = None,
        prefix: Optional[str] = None
    ) -> List[str]:
        """List all profile files, optionally filtered.
        
        Args:
            preset_type: Filter by preset type
            prefix: Filter by prefix
            
        Returns:
            List of profile filenames
        """
        try:
            files = await self.hass.async_add_executor_job(
                lambda: [f.name for f in self.profiles_dir.glob("*.json")]
            )
            
            # Apply filters
            if prefix:
                files = [f for f in files if f.startswith(prefix)]
            
            if preset_type:
                # Load each file to check preset_type
                filtered = []
                for filename in files:
                    data = await self.load_profile_cached(filename)
                    if not data:
                        continue
                    # Check both new format (meta) and legacy format (root)
                    file_preset = data.get("meta", {}).get("preset_type") or data.get("preset_type")
                    if file_preset == preset_type:
                        filtered.append(filename)
                files = filtered
            
            _LOGGER.debug("Listed %d profiles (preset=%s, prefix=%s)", 
                         len(files), preset_type, prefix)
            return sorted(files)
            
        except Exception as e:
            _LOGGER.error("Failed to list profiles: %s", e)
            return []
    
    async def cleanup_old_backups(self, days: int = 7) -> int:
        """Remove backup files older than specified days.
        
        Args:
            days: Maximum age of backups to keep
            
        Returns:
            Number of backups deleted
        """
        try:
            cutoff = time.time() - (days * 86400)
            backups = await self.hass.async_add_executor_job(
                lambda: list(self.profiles_dir.glob("*.bak"))
            )
            
            deleted = 0
            for backup_file in backups:
                if backup_file.stat().st_mtime < cutoff:
                    await self.hass.async_add_executor_job(backup_file.unlink)
                    deleted += 1
            
            if deleted > 0:
                _LOGGER.info("Cleaned up %d old backup files", deleted)
            
            return deleted
            
        except Exception as e:
            _LOGGER.error("Failed to cleanup backups: %s", e)
            return 0
    
    def clear_cache(self, filename: Optional[str] = None):
        """Clear profile cache.
        
        Args:
            filename: Specific file to clear, or None for all
        """
        if filename:
            self._cache.pop(filename, None)
            _LOGGER.debug("Cache cleared for: %s", filename)
        else:
            self._cache.clear()
            _LOGGER.debug("All cache cleared")
    
    # Synchronous helper methods (run in executor)
    
    @staticmethod
    def _write_json(path: Path, data: Dict[str, Any]):
        """Write JSON data to file."""
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    @staticmethod
    def _read_json(path: Path) -> Dict[str, Any]:
        """Read JSON data from file."""
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    
    @staticmethod
    def _copy_file(src: Path, dst: Path):
        """Copy file."""
        import shutil
        shutil.copy2(src, dst)
    
    @staticmethod
    def _rename_file(src: Path, dst: Path):
        """Rename/move file (atomic on POSIX)."""
        src.replace(dst)


# --- File: custom_components/cronostar/utils/filename_builder.py ---
# Real size: 1012 bytes, Used: 1012 bytes
import logging
from typing import Optional

from .prefix_normalizer import slugify, normalize_prefix, PRESETS_CONFIG

_LOGGER = logging.getLogger(__name__)

def build_profile_filename(
    profile_name: str,
    canonical_preset: str,
    global_prefix: str | None = None
) -> str:
    """
    Build profile filename using the correct prefix.
    Generates a single file per prefix context (e.g. cronostar_prefix_data.json).
    """
    # Determine which prefix to use
    if global_prefix:
        used_prefix = normalize_prefix(global_prefix)
    else:
        raise ValueError("global_prefix is required")
    _LOGGER.debug("FilenameBuilder: resolved prefix '%s' (global=%s, preset=%s)", used_prefix, bool(global_prefix), canonical_preset)
    
    # Remove trailing underscore and create filename
    prefix_base = used_prefix.rstrip("_")
    
    _LOGGER.debug(
        "Building filename: prefix=%s (profile_name ignored for filename)",
        prefix_base
    )
    
    return f"{prefix_base}_data.json"


# --- File: custom_components/cronostar/utils/prefix_normalizer.py ---
# Real size: 2703 bytes, Used: 2703 bytes
import re

PRESETS_CONFIG = {
    "thermostat": {
        "input_text": "input_text.cronostar_active_profile_thermostat",
        "profiles_select": "input_select.cronostar_temp_profiles",
        "current_value_entity": "input_number.cronostar_temp_current",
        "file_tag": "thermostat"
    },
    "ev_charging": {
        "input_text": "input_text.cronostar_active_profile_ev_charging",
        "profiles_select": "input_select.cronostar_ev_profiles",
        "current_value_entity": "input_number.cronostar_ev_current",
        "file_tag": "ev_charging"
    },
    "generic_switch": {
        "input_text": "input_text.cronostar_active_profile_generic_switch",
        "profiles_select": "input_select.cronostar_switch_profiles",
        "current_value_entity": "input_number.cronostar_switch_current",
        "file_tag": "switch"
    },
    "generic_kwh": {
        "input_text": "input_text.cronostar_active_profile_generic_kwh",
        "profiles_select": "input_select.cronostar_kwh_profiles",
        "current_value_entity": "input_number.cronostar_kwh_current",
        "file_tag": "kwh"
    },
    "generic_temperature": {
        "input_text": "input_text.cronostar_active_profile_generic_temperature",
        "profiles_select": "input_select.cronostar_gentemp_profiles",
        "current_value_entity": "input_number.cronostar_gentemp_current",
        "file_tag": "gentemp"
    },
}

def slugify(s: str) -> str:
    """Convert string to slug format."""
    s = s.lower().strip()
    s = s.replace(" ", "_")
    return "".join(c for c in s if c.isalnum() or c == "_")

def normalize_prefix(prefix: str) -> str:
    """Normalize prefix to ensure it ends with underscore."""
    if not prefix:
        return ""
    s = prefix.strip().lower()
    if not s.endswith("_"):
        s += "_"
    return s

def normalize_preset_type(preset_type: str) -> str:
    """Normalize preset type to canonical form."""
    if not preset_type:
        return "thermostat"
    
    key = slugify(preset_type)
    
    # Direct match
    if key in PRESETS_CONFIG:
        return key
    
    # Synonym matching
    synonyms = {
        "thermostat": {"thermostat", "temperature", "temp", "cronostar_temp"},
        "ev_charging": {"ev_charging", "ev", "evcharge", "charge", "charging", "cronostar_ev"},
        "generic_switch": {"generic_switch", "switch", "generic_switches"},
        "generic_kwh": {"generic_kwh", "kwh", "energy", "generic_energy"},
        "generic_temperature": {"generic_temperature", "gentemp", "generic_temp", "gen_temp"},
    }
    
    for canonical, synonyms_set in synonyms.items():
        if key in synonyms_set:
            return canonical
    
    return "thermostat"


# --- File: custom_components/cronostar/__init__.py ---
# Real size: 17925 bytes, Used: 17925 bytes
"""CronoStar custom component - Enhanced with auto-save and dashboard support."""
import logging
import os
import json
from pathlib import Path

from homeassistant.core import HomeAssistant, ServiceCall, ServiceResponse
from homeassistant import config_entries
from homeassistant.const import EVENT_HOMEASSISTANT_START, EVENT_HOMEASSISTANT_STOP
from homeassistant.helpers.typing import ConfigType
import homeassistant.helpers.config_validation as cv
from homeassistant.components.http import StaticPathConfig
from homeassistant.components.frontend import add_extra_js_url

from .const import DOMAIN
from .services.file_service import FileService
from .storage.storage_manager import StorageManager
from .services.profile_service import ProfileService
from .services.automation_service import AutomationService
from .scheduler.smart_scheduler import SmartScheduler
from .utils.prefix_normalizer import PRESETS_CONFIG, normalize_preset_type
from .utils.filename_builder import build_profile_filename

_LOGGER = logging.getLogger(__name__)

CONFIG_SCHEMA = cv.empty_config_schema(DOMAIN)

async def _set_debug_logging(hass: HomeAssistant) -> None:
    """Force DEBUG logging on Home Assistant and this component at startup."""
    try:
        payload = {
            "homeassistant": "error",
            "homeassistant.core": "error",
            "custom_components.cronostar": "debug",
        }
        await hass.services.async_call("logger", "set_level", payload, blocking=False)
        _LOGGER.info("Logging levels set to DEBUG via logger.set_level")
    except Exception as e:
        _LOGGER.warning("Failed to set logger levels via service: %s. Falling back to setLevel.", e)
        try:
            logging.getLogger().setLevel(logging.DEBUG)
            logging.getLogger("custom_components.cronostar").setLevel(logging.DEBUG)
        except Exception:
            pass

async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
    """Set up the CronoStar component from YAML."""
    if DOMAIN not in config:
        return True

    return await _async_setup_core(hass)

async def async_setup_entry(hass: HomeAssistant, entry: config_entries.ConfigEntry) -> bool:
    """Set up CronoStar from a config entry."""
    return await _async_setup_core(hass)

async def _async_setup_core(hass: HomeAssistant) -> bool:
    """Core setup logic shared by YAML and Config Entry."""
    _LOGGER.warning("[CRONOSTAR] async_setup_core ENTER")

    await _set_debug_logging(hass)

    component_version = "4.3.0"
    if DOMAIN not in hass.data:
        hass.data[DOMAIN] = {"version": component_version}

    www_path = hass.config.path("custom_components/cronostar/www/cronostar_card")
    www_path = Path(www_path)
    profiles_dir = hass.config.path("cronostar/profiles")

    if www_path.exists() and www_path.is_dir():
        await hass.http.async_register_static_paths([StaticPathConfig(url_path="/cronostar_card", path=www_path)])
        add_extra_js_url(hass, "/cronostar_card/cronostar-card.js?v=5")
        _LOGGER.info("Frontend JS URL registered")

    file_service = FileService(hass)
    storage_manager = StorageManager(hass, profiles_dir)
    profile_service = ProfileService(hass, file_service, storage_manager)
    scheduler = SmartScheduler(hass, profile_service)
    automation_service = AutomationService(hass)

    hass.data[DOMAIN]["storage_manager"] = storage_manager
    hass.data[DOMAIN]["scheduler"] = scheduler
    hass.data[DOMAIN]["profile_service"] = profile_service

    try:
        from .deep_checks import register_check_setup_service
        register_check_setup_service(hass)
    except Exception as e:
        _LOGGER.warning("deep_checks module not available: %s", e)

    # ========================================
    # SERVICE: save_profile
    # ========================================
    async def save_profile_wrapper(call: ServiceCall):
        await profile_service.save_profile(call)
        preset = call.data.get("preset_type")
        if preset:
            await scheduler.update_preset(preset)

    if not hass.services.has_service(DOMAIN, "save_profile"):
        hass.services.async_register(DOMAIN, "save_profile", save_profile_wrapper)

    # ========================================
    # SERVICE: load_profile
    # ========================================
    async def load_profile_service(call: ServiceCall) -> ServiceResponse:
        return await profile_service.load_profile(call)

    if not hass.services.has_service(DOMAIN, "load_profile"):
        hass.services.async_register(DOMAIN, "load_profile", load_profile_service, supports_response=True)

    # ========================================
    # SERVICE: add_profile
    # ========================================
    if not hass.services.has_service(DOMAIN, "add_profile"):
        hass.services.async_register(DOMAIN, "add_profile", profile_service.add_profile)

    # ========================================
    # SERVICE: delete_profile
    # ========================================
    if not hass.services.has_service(DOMAIN, "delete_profile"):
        hass.services.async_register(DOMAIN, "delete_profile", profile_service.delete_profile)

    # ========================================
    # SERVICE: apply_now
    # ========================================
    async def apply_now_service(call: ServiceCall):
        """Apply current scheduled value and trigger scheduler update."""
        payload = getattr(call, "service_data", None) or getattr(call, "data", None) or {}
        preset_type = payload.get("preset_type")
        if preset_type:
            await scheduler.update_preset(preset_type)

    if not hass.services.has_service(DOMAIN, "apply_now"):
        hass.services.async_register(DOMAIN, "apply_now", apply_now_service)

    # ========================================
    # SERVICE: create_yaml_file
    # ========================================
    if not hass.services.has_service(DOMAIN, "create_yaml_file"):
        hass.services.async_register(DOMAIN, "create_yaml_file", file_service.create_yaml_file)

    # ========================================
    # SERVICE: register_card
    # ========================================
    async def register_card(call: ServiceCall) -> ServiceResponse:
        """Register a frontend card and return active profile."""
        card_id = call.data.get("card_id")
        preset = call.data.get("preset", "thermostat")
        global_prefix = call.data.get("global_prefix")
        requested_profile = call.data.get("selected_profile")

        _LOGGER.info("Lovelace Card Connected: ID=%s, Preset=%s, RequestedProfile=%s", card_id, preset, requested_profile)
        _LOGGER.debug("[REGISTER] global_prefix=%s", global_prefix)

        response = {"success": True, "profile_data": None}

        # Logica semplificata per il recupero del profilo attivo con logging esteso
        state = None
        # Prefix MUST end with underscore for StorageManager filtering
        prefix_with_underscore = (global_prefix or "cronostar_")
        if not prefix_with_underscore.endswith("_"):
            prefix_with_underscore += "_"

        base = prefix_with_underscore.rstrip("_")
        dynamic_selector = f"input_select.{base}_profiles"
        _LOGGER.debug("[REGISTER] computed base=%s, dynamic_selector=%s", base, dynamic_selector)

        # Lettura dello stato dell'entity input_select
        state = hass.states.get(dynamic_selector)

        profile_to_load = None
        if state and state.state not in ("unknown", "unavailable"):
            profile_to_load = state.state
            _LOGGER.info("[REGISTER] Active profile detected: '%s' via %s", profile_to_load, dynamic_selector)
        elif requested_profile:
            # Se l'entity manca o non ha uno stato valido, usiamo quello richiesto dalla card (presentation)
            profile_to_load = requested_profile
            _LOGGER.info("[REGISTER] Fallback to requested profile: '%s' (entity %s missing/unknown)", profile_to_load, dynamic_selector)
        else:
            _LOGGER.info(
                "[REGISTER] No active profile via entity: entity missing (%s) and no requested profile",
                dynamic_selector
            )

        if profile_to_load:
            try:
                data = await profile_service.get_profile_data(profile_to_load, preset, global_prefix)
                if "error" not in data:
                    sched = data.get("schedule", [])
                    _LOGGER.info(
                        "âœ… Profile resolved during register: name=%s, points=%d, first=%s, last=%s",
                        profile_to_load,
                        len(sched),
                        sched[0] if sched else None,
                        sched[-1] if sched else None,
                    )
                    response["profile_data"] = data
                else:
                    _LOGGER.warning(
                        "âš ï¸ get_profile_data returned error during register for '%s': %s",
                        profile_to_load, data.get("error")
                    )
            except Exception as e:
                _LOGGER.error("âŒ Exception while loading profile '%s' during register: %s", profile_to_load, e)

        if not response.get("profile_data"):
            # Fallback: attempt to locate ANY profile from storage by prefix/preset
            try:
                canonical_preset = normalize_preset_type(preset)
                # Use full prefix with underscore to match StorageManager startswith
                files = await storage_manager.list_profiles(preset_type=canonical_preset, prefix=prefix_with_underscore)
                _LOGGER.debug("[REGISTER] Fallback search: found %d files for prefix=%s, preset=%s", len(files), prefix_with_underscore, canonical_preset)

                # If no files found with underscore, try stripping it (for loose files)
                if not files:
                    files = await storage_manager.list_profiles(preset_type=canonical_preset, prefix=base)
                    _LOGGER.debug("[REGISTER] Fallback search (retry): found %d files for prefix=%s", len(files), base)

                for filename in files:
                    container = await storage_manager.load_profile_cached(filename)
                    if not container or "profiles" not in container:
                        _LOGGER.debug("[REGISTER] Skipping container without profiles: %s", filename)
                        continue
                    available = list(container.get("profiles", {}).keys())
                    _LOGGER.debug("[REGISTER] Container %s has profiles=%s", filename, available)
                    # Prefer well-known defaults, else first available
                    candidates = [p for p in ("Default", "Comfort") if p in available] or available
                    for candidate in candidates:
                        _LOGGER.info("[REGISTER] Fallback loading candidate profile '%s'", candidate)
                        data = await profile_service.get_profile_data(candidate, preset, global_prefix)
                        if "error" not in data:
                            sched = data.get("schedule", [])
                            _LOGGER.info(
                                "âœ… Fallback profile loaded: name=%s, points=%d, first=%s, last=%s",
                                candidate,
                                len(sched),
                                sched[0] if sched else None,
                                sched[-1] if sched else None,
                            )
                            response["profile_data"] = data
                            break
                        else:
                            _LOGGER.warning("[REGISTER] Fallback candidate '%s' failed: %s", candidate, data.get("error"))
                    if response.get("profile_data"):
                        break

                if not response.get("profile_data"):
                    _LOGGER.info("[REGISTER] Fallback did not find a usable profile for prefix=%s", prefix_with_underscore)
            except Exception as e:
                _LOGGER.error("[REGISTER] Fallback search error: %s", e)

        # Recupero stati correnti per l'help
        entity_states = {}

        def get_formatted_state(entity_id):
            if not entity_id:
                return "Not configured"
            st = hass.states.get(entity_id)
            if not st:
                return "Not found"
            val = st.state
            if entity_id.startswith("switch.") or entity_id.startswith("input_boolean."):
                return "On" if val == "on" else "Off"
            # Add unit if available
            unit = st.attributes.get("unit_of_measurement")
            if unit:
                return f"{val} {unit}"
            return val

        # Identifichiamo le entitÃ  per il report
        target_ent_for_states = None
        if state and state.attributes.get("target_entity"):
            target_ent_for_states = state.attributes.get("target_entity")
        if not target_ent_for_states and response.get("profile_data") and "meta" in response["profile_data"]:
            target_ent_for_states = response["profile_data"]["meta"].get("target_entity")

        entity_states["target"] = get_formatted_state(target_ent_for_states)
        entity_states["current_helper"] = get_formatted_state(f"input_number.{prefix_with_underscore}current")
        entity_states["selector"] = get_formatted_state(dynamic_selector)
        entity_states["pause"] = get_formatted_state(f"input_boolean.{prefix_with_underscore}paused")

        response["entity_states"] = entity_states

        _LOGGER.debug(
            "[REGISTER] Response summary: success=%s, has_profile=%s, states=%s",
            response.get("success"), bool(response.get("profile_data")), entity_states
        )
        return response

    if not hass.services.has_service(DOMAIN, "register_card"):
        hass.services.async_register(DOMAIN, "register_card", register_card, supports_response=True)

    # ========================================
    # SERVICE: list_all_profiles (NUOVO)
    # ========================================
    async def list_all_profiles_service(call: ServiceCall) -> ServiceResponse:
        """List all profiles grouped by preset type for dashboard."""
        try:
            if not hasattr(profile_service, "storage"):
                return {"error": "Storage not available"}

            files = await profile_service.storage.list_profiles()
            profiles_by_preset = {}

            for filename in files:
                try:
                    data = await profile_service.storage.load_profile_cached(filename)
                    if not data:
                        continue

                    # Container format
                    if "meta" in data and "profiles" in data:
                        preset_type = data["meta"].get("preset_type", "unknown")
                        global_prefix = data["meta"].get("global_prefix", "")

                        if preset_type not in profiles_by_preset:
                            profiles_by_preset[preset_type] = {
                                "global_prefix": global_prefix,
                                "profiles": []
                            }

                        for profile_name, profile_content in data["profiles"].items():
                            schedule = profile_content.get("schedule", [])
                            profiles_by_preset[preset_type]["profiles"].append({
                                "name": profile_name,
                                "points": len(schedule),
                                "updated_at": profile_content.get("updated_at", "unknown")
                            })

                    # Legacy format
                    elif "profile_name" in data:
                        preset_type = data.get("preset_type", "unknown")
                        global_prefix = data.get("global_prefix", "")

                        if preset_type not in profiles_by_preset:
                            profiles_by_preset[preset_type] = {
                                "global_prefix": global_prefix,
                                "profiles": []
                            }

                        schedule = data.get("schedule", [])
                        profiles_by_preset[preset_type]["profiles"].append({
                            "name": data.get("profile_name", "Unknown"),
                            "points": len(schedule),
                            "updated_at": data.get("updated_at", "unknown")
                        })

                except Exception as e:
                    _LOGGER.warning("Error reading profile file %s: %s", filename, e)
                    continue

            _LOGGER.info("[LIST_ALL_PROFILES] Found %d presets with profiles", len(profiles_by_preset))
            return profiles_by_preset

        except Exception as e:
            _LOGGER.error("Error listing profiles: %s", e)
            return {"error": str(e)}

    if not hass.services.has_service(DOMAIN, "list_all_profiles"):
        hass.services.async_register(
            DOMAIN,
            "list_all_profiles",
            list_all_profiles_service,
            supports_response=True
        )

    # ========================================
    # EVENT HANDLERS
    # ========================================
    async def on_hass_start(event):
        _LOGGER.info("CronoStar: Home Assistant has started.")
        await profile_service.async_update_profile_selectors()
        await scheduler.async_initialize()

    async def on_hass_stop(event):
        scheduler.stop()
        storage_manager.clear_cache()

    hass.bus.async_listen_once(EVENT_HOMEASSISTANT_START, on_hass_start)
    hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, on_hass_stop)

    return True

# --- File: custom_components/cronostar/deep_checks.py ---
# Real size: 32771 bytes, Used: 32771 bytes
"""CronoStar Deep Checks - Modular configuration verification."""
import os
import re
import json
import time
import logging
from typing import Any, Dict, List, Tuple, Optional
from dataclasses import dataclass

from homeassistant.core import HomeAssistant, ServiceCall
from homeassistant.util import yaml as yaml_util

_LOGGER = logging.getLogger(__name__)
DOMAIN = "cronostar"

@dataclass
class InputNumberInfo:
    source: str
    include_target: Optional[str]
    full_path: str
    yaml_keys_count: int
    yaml_keys: List[str]
    runtime_found_total: int
    runtime_found_prefixed: int
    runtime_missing: List[str]
    used_prefix: str
    hour_base: int

@dataclass
class AutomationInfo:
    source: str
    include_target: Optional[str]
    full_path: str
    yaml_count: int
    storage_count: int
    runtime_entities: List[str]
    found_by_alias: List[str]

@dataclass
class CardInitInfo:
    prefix_valid: bool
    profiles_file_exists: bool
    package_file_exists: bool
    automation_file_exists: bool
    profiles_path: str
    package_path: str
    automation_path: str

@dataclass
class PackageContentInfo:
    ok: bool
    path: str
    input_number_key: str
    missing_keys: List[str]
    present_keys: List[str]

@dataclass
class AutomationContentInfo:
    ok_alias: bool
    ok_apply_value: bool
    ok_schedule_next: bool
    alias: str
    path: str
    details: str

@dataclass
class ProfileJsonInfo:
    ok: bool
    path: str
    has_schedule: bool
    schedule_count: int
    invalid_items: int
    required_keys_present: List[str]

class YamlInspector:
    def __init__(self, hass: HomeAssistant, base_dir: str):
        self.hass = hass
        self.base_dir = base_dir

    async def find_section_source(self, cfg_path: str, section: str) -> Tuple[str, Optional[str]]:
        try:
            text = await self.hass.async_add_executor_job(self._read_file, cfg_path)
        except Exception as e:
            _LOGGER.warning("Failed to read %s: %s", cfg_path, e)
            return "unknown", None
        patterns = {
            "include_file": re.compile(rf"^{section}:\s*!include\s+(.+)$", re.M),
            "include_dir_named": re.compile(rf"^{section}:\s*!include_dir_merge_named\s+(.+)$", re.M),
            "include_dir_list": re.compile(rf"^{section}:\s*!include_dir_merge_list\s+(.+)$", re.M),
        }
        for source_type, pattern in patterns.items():
            match = pattern.search(text)
            if match:
                return source_type, match.group(1).strip()
        inline_pattern = re.compile(rf"^{section}:\s*$", re.M)
        if inline_pattern.search(text):
            return "inline", None
        return "none", None

    @staticmethod
    def _read_file(path: str) -> str:
        with open(path, "r", encoding="utf-8") as f:
            return f.read()

    async def find_packages_dir(self, cfg_path: str) -> Optional[str]:
        """Detect the packages include directory from configuration.yaml.
        Supports both !include_dir_named and !include_dir_merge_named.
        """
        try:
            text = await self.hass.async_add_executor_job(self._read_file, cfg_path)
        except Exception as e:
            _LOGGER.warning("Failed to read %s: %s", cfg_path, e)
            return None
        # Look for 'packages:' include lines
        patterns = [
            re.compile(r"^\s*packages:\s*!include_dir_named\s+(.+)$", re.M),
            re.compile(r"^\s*packages:\s*!include_dir_merge_named\s+(.+)$", re.M),
        ]
        for pat in patterns:
            m = pat.search(text)
            if m:
                target = m.group(1).strip()
                _LOGGER.info("[DeepCheck] Detected packages include dir: %s", target)
                return target
        return None

class InputNumberInspector:
    def __init__(self, hass: HomeAssistant, yaml_inspector: YamlInspector):
        self.hass = hass
        self.yaml_inspector = yaml_inspector

    async def inspect(self, cfg_path: str, base_dir: str, prefix: str, hour_base: int) -> InputNumberInfo:
        source, include_target = await self.yaml_inspector.find_section_source(cfg_path, "input_number")
        full_path = self._build_full_path(base_dir, include_target, cfg_path)
        # Normalize prefix to always end with underscore
        raw_prefix = (prefix or "cronostar_").strip().lower()
        used_prefix = raw_prefix if raw_prefix.endswith("_") else f"{raw_prefix}_"
        expected_entities = [f"input_number.{used_prefix}current"]

        runtime_states = self.hass.states.async_all()
        found_all = set(s.entity_id for s in runtime_states if s.entity_id.startswith("input_number."))
        found_prefixed = set(s.entity_id for s in runtime_states if s.entity_id.startswith(f"input_number.{used_prefix}"))
        missing = [eid.split(".")[-1] for eid in expected_entities if eid not in found_prefixed]

        yaml_keys_count, yaml_keys = await self._count_yaml_entities(base_dir, source, include_target, cfg_path)

        return InputNumberInfo(
            source=source,
            include_target=include_target,
            full_path=full_path,
            yaml_keys_count=yaml_keys_count,
            yaml_keys=yaml_keys,
            runtime_found_total=len(found_all),
            runtime_found_prefixed=len(found_prefixed),
            runtime_missing=missing,
            used_prefix=used_prefix,
            hour_base=hour_base
        )

    async def validate_package_content(self, base_dir: str, source: str, include_target: Optional[str], cfg_path: str, used_prefix: str) -> PackageContentInfo:
        """Ensure the package contains the expected input_number helper and basic attributes."""
        input_key = f"{used_prefix}current"
        missing = []
        present = []
        path = self._build_full_path(base_dir, include_target, cfg_path)
        try:
            # Load the YAML content depending on source
            if source == "inline":
                loaded = await self.hass.async_add_executor_job(yaml_util.load_yaml, cfg_path)
                section = loaded.get("input_number") or {}
                content = section if isinstance(section, dict) else {}
            elif source == "include_file" and include_target:
                file_path = os.path.join(base_dir, include_target)
                content = await self.hass.async_add_executor_job(yaml_util.load_yaml, file_path)
            elif source == "include_dir_named" and include_target:
                # Merge dicts across named files
                dir_path = os.path.join(base_dir, include_target)
                merged: Dict[str, Any] = {}
                for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
                    if not name.lower().endswith((".yaml", ".yml")):
                        continue
                    inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
                    if isinstance(inc, dict):
                        merged.update(inc)
                content = merged
            elif source == "include_dir_list" and include_target:
                # Build a dict from list items
                dir_path = os.path.join(base_dir, include_target)
                merged: Dict[str, Any] = {}
                for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
                    if not name.lower().endswith((".yaml", ".yml")):
                        continue
                    inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
                    if isinstance(inc, list):
                        for item in inc:
                            if isinstance(item, dict):
                                merged.update(item)
                content = merged
            else:
                content = {}
        except Exception as e:
            _LOGGER.warning("Error loading package YAML for validation: %s", e)
            content = {}

        helper = content.get(input_key)
        if not isinstance(helper, dict):
            missing.append(input_key)
            return PackageContentInfo(ok=False, path=path, input_number_key=input_key, missing_keys=missing, present_keys=present)

        # Basic attribute presence check
        for key in ("min", "max", "step"):
            if key in helper:
                present.append(key)
            else:
                missing.append(key)

        return PackageContentInfo(ok=len(missing) == 0, path=path, input_number_key=input_key, missing_keys=missing, present_keys=present)

    async def _count_yaml_entities(self, base_dir: str, source: str, include_target: Optional[str], cfg_path: str) -> Tuple[int, List[str]]:
        keys: List[str] = []
        try:
            if source == "inline":
                loaded = await self.hass.async_add_executor_job(yaml_util.load_yaml, cfg_path)
                section = loaded.get("input_number") or {}
                if isinstance(section, dict):
                    keys = list(section.keys())
            elif source == "include_file" and include_target:
                file_path = os.path.join(base_dir, include_target)
                included = await self.hass.async_add_executor_job(yaml_util.load_yaml, file_path)
                if isinstance(included, dict):
                    keys = list(included.keys())
            elif source == "include_dir_named" and include_target:
                dir_path = os.path.join(base_dir, include_target)
                keys = await self._read_dir_named(dir_path)
            elif source == "include_dir_list" and include_target:
                dir_path = os.path.join(base_dir, include_target)
                keys = await self._read_dir_list(dir_path)
        except Exception as e:
            _LOGGER.warning("Error reading input_number YAML: %s", e)
        return len(keys), keys

    async def _read_dir_named(self, dir_path: str) -> List[str]:
        keys = []
        for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
            if not name.lower().endswith((".yaml", ".yml")):
                continue
            inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
            if isinstance(inc, dict):
                keys.extend(list(inc.keys()))
        return keys

    async def _read_dir_list(self, dir_path: str) -> List[str]:
        keys = []
        for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
            if not name.lower().endswith((".yaml", ".yml")):
                continue
            inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
            if isinstance(inc, list):
                for item in inc:
                    if isinstance(item, dict):
                        keys.extend(list(item.keys()))
        return keys

    @staticmethod
    def _build_full_path(base_dir: str, include_target: Optional[str], cfg_path: str) -> str:
        if include_target:
            full_path = os.path.join(base_dir, include_target)
        else:
            full_path = cfg_path
        return full_path.replace(base_dir, "/config").replace("\\", "/")

class AutomationInspector:
    def __init__(self, hass: HomeAssistant, yaml_inspector: YamlInspector):
        self.hass = hass
        self.yaml_inspector = yaml_inspector

    async def inspect(self, cfg_path: str, base_dir: str, alias: str) -> AutomationInfo:
        source, include_target = await self.yaml_inspector.find_section_source(cfg_path, "automation")
        full_path = self._build_full_path(base_dir, include_target, cfg_path)

        runtime = self.hass.states.async_all()
        auto_entities = [s for s in runtime if s.entity_id.startswith("automation.")]
        found_by_alias = [s.entity_id for s in auto_entities if (s.attributes.get("friendly_name") or "") == alias]

        yaml_count = await self._count_yaml_automations(base_dir, source, include_target, cfg_path)
        storage_count = await self._count_storage_automations()

        return AutomationInfo(
            source=source,
            include_target=include_target,
            full_path=full_path,
            yaml_count=yaml_count,
            storage_count=storage_count,
            runtime_entities=[s.entity_id for s in auto_entities],
            found_by_alias=found_by_alias
        )

    async def validate_automation_content(self, base_dir: str, source: str, include_target: Optional[str], cfg_path: str, alias: str, used_prefix: str) -> AutomationContentInfo:
        """Validate that the automation applies the value and schedules the next run."""
        path = self._build_full_path(base_dir, include_target, cfg_path)
        ok_alias = False
        ok_apply = False
        ok_sched = False
        details = ""
        try:
            # Load automations list from YAML depending on source
            def load_list_from_obj(obj: Any) -> List[Dict[str, Any]]:
                if isinstance(obj, list):
                    return obj
                if isinstance(obj, dict):
                    # Single automation dict (inline) -> wrap
                    return [obj]
                return []

            if source == "inline":
                loaded = await self.hass.async_add_executor_job(yaml_util.load_yaml, cfg_path)
                section = loaded.get("automation")
                autos = load_list_from_obj(section)
            elif source == "include_file" and include_target:
                file_path = os.path.join(base_dir, include_target)
                inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, file_path)
                autos = load_list_from_obj(inc)
            elif source in ("include_dir_list", "include_dir_named") and include_target:
                dir_path = os.path.join(base_dir, include_target)
                autos = []
                for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
                    if not name.lower().endswith((".yaml", ".yml")):
                        continue
                    inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
                    autos.extend(load_list_from_obj(inc))
            else:
                autos = []

            # Find by alias
            target = None
            for a in autos:
                a_alias = (a.get("alias") or a.get("id") or "").strip()
                if a_alias == alias:
                    target = a
                    ok_alias = True
                    break

            if not target:
                return AutomationContentInfo(ok_alias=ok_alias, ok_apply_value=False, ok_schedule_next=False, alias=alias, path=path, details="Alias not found in YAML")

            # Validate apply value: look for an action calling a service and referencing input_number.<prefix>current
            actions = target.get("action") or []
            if isinstance(actions, dict):
                actions = [actions]
            for act in actions:
                if not isinstance(act, dict):
                    continue
                svc = act.get("service") or act.get("action")
                data = act.get("data") or act.get("data_template") or {}
                # Look for Jinja template or entity_id referencing the helper
                helper_id = f"input_number.{used_prefix}current"
                serialized = json.dumps(data, ensure_ascii=False) if data else ""
                if isinstance(svc, str) and helper_id in serialized:
                    ok_apply = True
                    break

            # Validate scheduling: either time/time_pattern trigger or explicit delay/wait and re-schedule logic
            triggers = target.get("trigger") or []
            if isinstance(triggers, dict):
                triggers = [triggers]
            for tr in triggers:
                if not isinstance(tr, dict):
                    continue
                platform = (tr.get("platform") or "").strip()
                if platform in ("time", "time_pattern"):
                    ok_sched = True
                    break
            if not ok_sched:
                # Heuristic: actions include delay/wait_template implying manual scheduling
                for act in actions:
                    if not isinstance(act, dict):
                        continue
                    if act.get("delay") or act.get("wait_template"):
                        ok_sched = True
                        break

            return AutomationContentInfo(ok_alias=ok_alias, ok_apply_value=ok_apply, ok_schedule_next=ok_sched, alias=alias, path=path, details="")
        except Exception as e:
            details = f"Error validating automation content: {e}"
            _LOGGER.warning(details)
            return AutomationContentInfo(ok_alias=ok_alias, ok_apply_value=False, ok_schedule_next=False, alias=alias, path=path, details=details)

    async def _count_yaml_automations(self, base_dir: str, source: str, include_target: Optional[str], cfg_path: str) -> int:
        count = 0
        try:
            if source == "inline":
                loaded = await self.hass.async_add_executor_job(yaml_util.load_yaml, cfg_path)
                section = loaded.get("automation")
                if isinstance(section, list):
                    count = len(section)
                elif isinstance(section, dict):
                    count = 1
            elif source == "include_file" and include_target:
                file_path = os.path.join(base_dir, include_target)
                inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, file_path)
                if isinstance(inc, list):
                    count = len(inc)
                else:
                    count = 1 if inc else 0
            elif source == "include_dir_list" and include_target:
                dir_path = os.path.join(base_dir, include_target)
                count = await self._count_dir_list(dir_path)
            elif source == "include_dir_named" and include_target:
                dir_path = os.path.join(base_dir, include_target)
                count = await self._count_dir_named(dir_path)
        except Exception as e:
            _LOGGER.warning("Error reading automation YAML: %s", e)
        return count

    async def _count_dir_list(self, dir_path: str) -> int:
        count = 0
        for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
            if not name.lower().endswith((".yaml", ".yml")):
                continue
            inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
            if isinstance(inc, list):
                count += len(inc)
        return count

    async def _count_dir_named(self, dir_path: str) -> int:
        count = 0
        for name in sorted(await self.hass.async_add_executor_job(os.listdir, dir_path)):
            if not name.lower().endswith((".yaml", ".yml")):
                continue
            inc = await self.hass.async_add_executor_job(yaml_util.load_yaml, os.path.join(dir_path, name))
            if isinstance(inc, dict):
                count += len(inc)
        return count

    async def _count_storage_automations(self) -> int:
        storage_path = self.hass.config.path(".storage", "automations")
        try:
            if not await self.hass.async_add_executor_job(os.path.exists, storage_path):
                return 0
            def read_storage():
                with open(storage_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            data = await self.hass.async_add_executor_job(read_storage)
            if isinstance(data, list):
                return len(data)
            elif isinstance(data, dict):
                items = data.get("items") or []
                return len(items)
        except Exception as e:
            _LOGGER.debug("Error reading storage automations: %s", e)
        return 0

    @staticmethod
    def _build_full_path(base_dir: str, include_target: Optional[str], cfg_path: str) -> str:
        if include_target:
            full_path = os.path.join(base_dir, include_target)
        else:
            full_path = cfg_path
        return full_path.replace(base_dir, "/config").replace("\\", "/")

class ReportGenerator:
    @staticmethod
    def render_message(input_number: InputNumberInfo, automation: AutomationInfo, alias: str, version: str,
                       package_content: Optional[PackageContentInfo] = None,
                       automation_content: Optional[AutomationContentInfo] = None,
                       profile_json: Optional[ProfileJsonInfo] = None) -> str:
        parts = []
        parts.append(f"--- CronoStar Setup Check (v{version}) ---")

        parts.append("\n[Input Number Helper]")
        helper_id = f"input_number.{input_number.used_prefix}current"
        missing_helper = helper_id.split(".")[-1] in input_number.runtime_missing
        if missing_helper:
            parts.append("STATUS: âŒ MISSING")
            parts.append(f"Details: Helper '{helper_id}' not found in runtime states.")
        else:
            parts.append("STATUS: âœ… OK")
            parts.append(f"Details: Helper '{helper_id}' is present.")
        parts.append(f"Configuration source: {input_number.source} @ {input_number.full_path}")

        if package_content:
            parts.append("\n[Package YAML Content]")
            parts.append(f"File: {package_content.path}")
            parts.append(f"Expected helper: input_number.{package_content.input_number_key}")
            if package_content.ok:
                parts.append("STATUS: âœ… OK")
            else:
                parts.append("STATUS: âŒ INVALID")
            if package_content.present_keys:
                parts.append(f"Present keys: {', '.join(package_content.present_keys)}")
            if package_content.missing_keys:
                parts.append(f"Missing keys: {', '.join(package_content.missing_keys)}")

        parts.append("\n[Automation]")
        automation_missing = not automation.found_by_alias
        if automation_missing:
            parts.append("STATUS: âŒ MISSING")
            parts.append(f"Details: No automation found with alias '{alias}'.")
        else:
            parts.append("STATUS: âœ… OK")
            parts.append(f"Details: Found automation with alias '{alias}'.")
        parts.append(f"Configuration source: {automation.source} @ {automation.full_path}")

        if automation_content:
            parts.append("\n[Automation Content]")
            parts.append(f"File: {automation_content.path}")
            parts.append(f"Alias matched: {'âœ…' if automation_content.ok_alias else 'âŒ'}")
            parts.append(f"Apply value action present: {'âœ…' if automation_content.ok_apply_value else 'âŒ'}")
            parts.append(f"Scheduling present: {'âœ…' if automation_content.ok_schedule_next else 'âŒ'}")
            if automation_content.details:
                parts.append(f"Details: {automation_content.details}")

        parts.append("\n[Card Initialization]")
        parts.append("Run the wizard Step 5 and use 'Save All' to initialize JSON + YAML.")

        if profile_json:
            parts.append("\n[Profiles JSON Content]")
            parts.append(f"File: {profile_json.path}")
            parts.append(f"Schedule present: {'âœ…' if profile_json.has_schedule else 'âŒ'}")
            parts.append(f"Schedule count: {profile_json.schedule_count}")
            parts.append(f"Invalid items: {profile_json.invalid_items}")
            if profile_json.required_keys_present:
                parts.append(f"Required keys present: {', '.join(profile_json.required_keys_present)}")

        return "\n".join(parts)

def register_check_setup_service(hass: HomeAssistant) -> None:
    async def async_check_setup(call: ServiceCall) -> None:
        prefix = (call.data.get("prefix") or "").strip()
        hour_base = int(call.data.get("hour_base") or 0)
        alias = (call.data.get("alias") or "").strip()
        # expected_count deprecated in sparse mode; no longer used

        cfg_path = hass.config.path("configuration.yaml")
        base_dir = os.path.dirname(cfg_path)

        yaml_inspector = YamlInspector(hass, base_dir)
        input_number_inspector = InputNumberInspector(hass, yaml_inspector)
        automation_inspector = AutomationInspector(hass, yaml_inspector)

        input_number_info = await input_number_inspector.inspect(cfg_path, base_dir, prefix, hour_base)
        automation_info = await automation_inspector.inspect(cfg_path, base_dir, alias)

        # Card Init verification
        used_prefix = input_number_info.used_prefix
        prefix_base = used_prefix.rstrip("_")

        # Helper to infer prefix from existing package filename
        def _infer_prefix_from_packages(dir_path: str) -> Optional[str]:
            try:
                if not os.path.isdir(dir_path):
                    return None
                candidates = [fn for fn in os.listdir(dir_path) if fn.endswith("_package.yaml")]
                if not candidates:
                    return None
                # Prefer exact prefix match, else take first
                for fn in candidates:
                    if fn.startswith(f"{prefix_base}_") or fn.startswith(f"{used_prefix}package"):
                        base = fn[:-len("_package.yaml")]
                        return f"{base}_"
                base = candidates[0][:-len("_package.yaml")]
                return f"{base}_"
            except Exception as _e:
                return None

        profiles_path = hass.config.path("cronostar", "profiles", f"{prefix_base}_data.json")

        # Prefer explicit packages include dir from configuration.yaml
        packages_target = await yaml_inspector.find_packages_dir(cfg_path)
        if packages_target:
            packages_dir = hass.config.path(packages_target)
        else:
            # Fallback to input_number include target or default 'packages'
            if input_number_info.source in ("include_dir_named", "include_dir_list") and input_number_info.include_target:
                packages_dir = hass.config.path(input_number_info.include_target)
            else:
                packages_dir = hass.config.path("packages")

        package_path = os.path.join(packages_dir, f"{used_prefix}package.yaml")

        # Fallback: if package not found, try inferring prefix from existing *_package.yaml in packages dir
        if not os.path.exists(package_path):
            inferred_prefix = _infer_prefix_from_packages(packages_dir)
            if inferred_prefix and inferred_prefix != used_prefix:
                _LOGGER.info("[DeepCheck] Inferred prefix from packages dir '%s' -> '%s'", packages_dir, inferred_prefix)
                used_prefix = inferred_prefix
                prefix_base = used_prefix.rstrip("_")
                profiles_path = hass.config.path("cronostar", "profiles", f"{prefix_base}_data.json")
                package_path = os.path.join(packages_dir, f"{used_prefix}package.yaml")

        # Automation: prefer automations include-dir if configured; else use full_path
        if automation_info.source in ("include_dir_list", "include_dir_named") and automation_info.include_target:
            automation_path = os.path.join(hass.config.path(automation_info.include_target), f"{prefix_base}_automation.yaml")
        else:
            automation_path = automation_info.full_path  # inline/include_file not a single filename

        # Log normalized '/config' paths and existence
        profiles_path_log = profiles_path.replace(base_dir, "/config").replace("\\", "/")
        package_path_log = package_path.replace(base_dir, "/config").replace("\\", "/")
        automation_path_log = automation_path.replace(base_dir, "/config").replace("\\", "/")
        _LOGGER.info("[DeepCheck] Paths: profiles=%s exists=%s", profiles_path_log, os.path.exists(profiles_path))
        _LOGGER.info("[DeepCheck] Paths: package=%s exists=%s", package_path_log, os.path.exists(package_path))
        _LOGGER.info("[DeepCheck] Paths: automation=%s exists=%s", automation_path_log, os.path.exists(automation_path))

        card_init = CardInitInfo(
            prefix_valid=bool(re.match(r"^[a-z0-9_]+_$", used_prefix)),
            profiles_file_exists=os.path.exists(profiles_path),
            package_file_exists=os.path.exists(package_path),
            automation_file_exists=os.path.exists(automation_path),
            profiles_path=profiles_path,
            package_path=package_path,
            automation_path=automation_path
        )

        # Validate contents
        package_content = await input_number_inspector.validate_package_content(base_dir, input_number_info.source, input_number_info.include_target, cfg_path, used_prefix)
        automation_content = await automation_inspector.validate_automation_content(base_dir, automation_info.source, automation_info.include_target, cfg_path, alias, used_prefix)

        # Profiles JSON validation
        def _read_json(path: str) -> Any:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        prof_ok = False
        has_schedule = False
        schedule_count = 0
        invalid_items = 0
        req_keys_present: List[str] = []
        try:
            if os.path.exists(profiles_path):
                data = await hass.async_add_executor_job(_read_json, profiles_path)
                prof_ok = isinstance(data, dict)
                # Heuristic required keys
                for key in ("preset_type", "profile_name", "schedule"):
                    if key in data:
                        req_keys_present.append(key)
                schedule = data.get("schedule") if isinstance(data, dict) else None
                if isinstance(schedule, list):
                    has_schedule = True
                    schedule_count = len(schedule)
                    for item in schedule:
                        if not (isinstance(item, dict) and isinstance(item.get("time"), str) and isinstance(item.get("value"), (int, float))):
                            invalid_items += 1
        except Exception as e:
            _LOGGER.warning("Error reading profiles JSON: %s", e)

        profile_json = ProfileJsonInfo(ok=prof_ok, path=profiles_path.replace(base_dir, "/config").replace("\\", "/"), has_schedule=has_schedule, schedule_count=schedule_count, invalid_items=invalid_items, required_keys_present=req_keys_present)

        # Report message
        component_version = hass.data.get(DOMAIN, {}).get("version", "unknown")
        message = ReportGenerator.render_message(input_number_info, automation_info, alias, component_version, package_content=package_content, automation_content=automation_content, profile_json=profile_json)
        message += "\n\n[Card Initialization]"
        message += f"\nPrefix valid: {'âœ…' if card_init.prefix_valid else 'âŒ'}"
        message += f"\nProfiles JSON: {'âœ…' if card_init.profiles_file_exists else 'âŒ'} @ {card_init.profiles_path}"
        message += f"\nPackage YAML: {'âœ…' if card_init.package_file_exists else 'âŒ'} @ {card_init.package_path}"
        message += f"\nAutomation YAML: {'âœ…' if card_init.automation_file_exists else 'âŒ'} @ {card_init.automation_path}"

        notification_id = f"cronostar_setup_{int(time.time())}"
        await hass.services.async_call(
            "persistent_notification",
            "create",
            {
                "title": "CronoStar Setup Check",
                "message": message,
                "notification_id": notification_id
            },
            blocking=True
        )

        report = {
            "input_number": input_number_info.__dict__,
            "automation": automation_info.__dict__,
            "card_init": card_init.__dict__,
            "package_content": (package_content.__dict__ if package_content else None),
            "automation_content": (automation_content.__dict__ if automation_content else None),
            "profile_json": (profile_json.__dict__ if profile_json else None),
            "formatted_message": message
        }
        hass.bus.async_fire("cronostar_setup_report", report)
        _LOGGER.info("CronoStar setup report fired")

    try:
        hass.services.async_register(DOMAIN, "check_setup", async_check_setup)
        _LOGGER.info("Registered service %s.check_setup", DOMAIN)
    except Exception as err:
        _LOGGER.warning("Failed to register %s.check_setup: %s", DOMAIN, err)


# --- File: custom_components/cronostar/config_flow.py ---
# Real size: 6665 bytes, Used: 6665 bytes
"Config flow for CronoStar."
import os
import logging
import shutil
import re
from typing import Any, Dict, Optional

import voluptuous as vol
from homeassistant import config_entries
from homeassistant.core import callback
from homeassistant.helpers import config_validation as cv

from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)

class CronoStarConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    """Handle a config flow for CronoStar."""

    VERSION = 1

    def __init__(self):
        """Initialize flow."""
        self._config_path = None
        self._packages_enabled = False
        self._automations_setup = "unknown"

    async def async_step_user(self, user_input: Optional[Dict[str, Any]] = None):
        """Handle the initial step."""
        if self._async_current_entries():
            return self.async_abort(reason="single_instance_allowed")

        self._config_path = self.hass.config.path("configuration.yaml")
        
        # Analisi preliminare del configuration.yaml
        await self.hass.async_add_executor_job(self._analyze_configuration)

        if not self._packages_enabled:
            return await self.async_step_enable_packages()

        return await self.async_step_confirm_setup()

    def _analyze_configuration(self):
        """Analyze configuration.yaml for packages and automations."""
        if not os.path.exists(self._config_path):
            return

        with open(self._config_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Verifica packages
        # Cerca 'packages: !include_dir_named packages' o simili
        self._packages_enabled = bool(re.search(r'packages:\s*!include_dir_named', content))

        # Verifica automazioni
        if "automation: !include_dir_merge_list automations" in content:
            self._automations_setup = "ok"
        elif "automation:" not in content:
            self._automations_setup = "missing"
        else:
            self._automations_setup = "other"

    async def async_step_enable_packages(self, user_input=None):
        """Step to ask user to enable packages."""
        errors = {}
        if user_input is not None:
            if user_input.get("confirm"):
                await self.hass.async_add_executor_job(self._enable_packages_in_yaml)
                await self.hass.async_add_executor_job(self._analyze_configuration)
                return await self.async_step_confirm_setup()
            else:
                errors["base"] = "packages_required"

        return self.async_show_form(
            step_id="enable_packages",
            data_schema=vol.Schema({
                vol.Required("confirm", default=True): bool,
            }),
            errors=errors
        )

    def _enable_packages_in_yaml(self):
        """Modify configuration.yaml to enable packages."""
        with open(self._config_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        new_lines = []
        ha_section_found = False
        packages_added = False

        for line in lines:
            new_lines.append(line)
            if line.strip().startswith("homeassistant:"):
                ha_section_found = True
                # Aggiungiamo i package subito sotto homeassistant:
                new_lines.append("  packages: !include_dir_named packages\n")
                packages_added = True

        if not ha_section_found:
            new_lines.append("\nhomeassistant:\n")
            new_lines.append("  packages: !include_dir_named packages\n")
        elif not packages_added:
            # Se homeassistant: esiste ma non abbiamo trovato il punto giusto, lo aggiungiamo in fondo
            new_lines.append("  packages: !include_dir_named packages\n")

        with open(self._config_path, 'w', encoding='utf-8') as f:
            f.writelines(new_lines)

    async def async_step_confirm_setup(self, user_input=None):
        """Final confirmation and file operations."""
        if user_input is not None:
            await self.hass.async_add_executor_job(self._perform_file_operations)
            return self.async_create_entry(title="CronoStar", data={})

        return self.async_show_form(
            step_id="confirm_setup",
            description_placeholders={
                "automation_status": self._automations_setup
            }
        )

    def _perform_file_operations(self):
        """Create folders and copy initial package."""
        # 1. Cartella packages e cronostar_package.yaml
        pkg_dir = self.hass.config.path("packages")
        os.makedirs(pkg_dir, exist_ok=True)
        
        src_pkg = self.hass.config.path("custom_components/cronostar/packages/cronostar_package.yaml")
        # Se non lo trova nel componente (magari installato via HACS), prova nel root del progetto
        if not os.path.exists(src_pkg):
             src_pkg = self.hass.config.path("packages/cronostar_package.yaml")
             
        if os.path.exists(src_pkg):
            shutil.copy(src_pkg, os.path.join(pkg_dir, "cronostar_package.yaml"))

        # 2. Gestione Automazioni
        auto_dir = self.hass.config.path("automations")
        if self._automations_setup == "missing":
            os.makedirs(auto_dir, exist_ok=True)
            with open(self._config_path, 'a', encoding='utf-8') as f:
                f.write("\nautomation: !include_dir_merge_list automations\n")
        elif self._automations_setup == "other":
            # Caso in cui esiste giÃ  un'altra direttiva (es. !include automations.yaml)
            # Creiamo comunque la cartella per i file di CronoStar se non esiste
            os.makedirs(auto_dir, exist_ok=True)
            _LOGGER.warning("CronoStar: automation folder created but configuration.yaml uses a different include style. Manual check required.")

        # 3. Cartella profili
        os.makedirs(self.hass.config.path("cronostar/profiles"), exist_ok=True)

    @staticmethod
    @callback
    def async_get_options_flow(config_entry):
        return CronoStarOptionsFlow(config_entry)

class CronoStarOptionsFlow(config_entries.OptionsFlow):
    """Handle options."""

    def __init__(self, config_entry):
        """Initialize options flow."""
        self.config_entry = config_entry

    async def async_step_init(self, user_input=None):
        """Manage the options."""
        if user_input is not None:
            return self.async_create_entry(title="", data=user_input)

        return self.async_show_form(
            step_id="init",
            data_schema=vol.Schema({
                vol.Optional("logging_enabled", default=True): bool,
            }),
        )


# --- File: custom_components/cronostar/const.py ---
# Real size: 52 bytes, Used: 52 bytes
"""Constants for CronoStar."""
DOMAIN = "cronostar"


# --- File: custom_components/cronostar/manifest.json ---
# Real size: 427 bytes, Used: 427 bytes
{
  "domain": "cronostar",
  "name": "CronoStar Backend",
  "codeowners": [
    "@FoliniC"
  ],
  "config_flow": true,
  "dependencies": [
    "http",
    "frontend"
  ],
  "documentation": "https://github.com/FoliniC/CronoStar",
  "iot_class": "local_polling",
  "issue_tracker": "https://github.com/FoliniC/CronoStar/issues",
  "loggers": [
    "custom_components.cronostar"
  ],
  "requirements": [],
  "version": "4.3.0"
}


# --- File: custom_components/cronostar/services.yaml ---
# Real size: 4610 bytes, Used: 4610 bytes
# Existing services (unchanged)
save_profile:
  name: Save Profile
  description: Saves a CronoStar schedule profile to a JSON file.
  fields:
    profile_name:
      name: Profile Name
      description: "The name of the profile to save (e.g., Comfort)."
      required: true
      selector:
        text:
    preset_type:
      name: Preset Type
      description: "The type of preset this profile belongs to (e.g., thermostat, ev_charging)."
      required: true
      selector:
        text:
    schedule:
      name: Schedule
      description: "An array of 24 numeric values for the schedule."
      required: true
      selector:
        object:
    global_prefix:
      name: Global Prefix
      description: "The global identification prefix."
      required: false
      selector:
        text:

load_profile:
  name: Load Profile
  description: "Loads a CronoStar schedule profile from a JSON file and returns its content."
  fields:
    profile_name:
      name: Profile Name
      description: "The name of the profile to load."
      required: true
      selector:
        text:
    preset_type:
      name: Preset Type
      description: "The type of preset to which the profile belongs."
      required: true
      selector:
        text:
    global_prefix:
      name: Global Prefix
      description: "The global identification prefix."
      required: false
      selector:
        text:

add_profile:
  name: Add Profile
  description: "Creates a new profile with default values."
  fields:
    profile_name:
      name: Profile Name
      description: "The name of the profile to create."
      required: true
      selector:
        text:
    preset_type:
      name: Preset Type
      description: "The type of preset this profile belongs to."
      required: true
      selector:
        text:
    global_prefix:
      name: Global Prefix
      description: "The global identification prefix."
      required: false
      selector:
        text:

delete_profile:
  name: Delete Profile
  description: "Deletes a CronoStar schedule profile."
  fields:
    profile_name:
      name: Profile Name
      description: "The name of the profile to delete."
      required: true
      selector:
        text:
    preset_type:
      name: Preset Type
      description: "The type of preset this profile belongs to."
      required: true
      selector:
        text:
    global_prefix:
      name: Global Prefix
      description: "The global identification prefix."
      required: false
      selector:
        text:

apply_now:
  name: Apply current hour value
  description: Apply the scheduled value for the current hour to the target entity (CronoStar).
  fields:
    target_entity:
      name: Target entity_id
      description: Entity to control (climate, number, switch).
      required: true
      selector:
        entity:
    preset_type:
      name: Preset type
      description: Preset used to decide how to apply values (e.g., thermostat, generic_switch).
      required: true
      selector:
        select:
          options:
            - thermostat
            - ev_charging
            - generic_kwh
            - generic_temperature
            - generic_switch
    allow_max_value:
      name: Allow Max Value
      required: false
      selector:
        boolean:
    global_prefix:
      name: Global Prefix
      required: false
      selector:
        text:

check_setup:
  name: Check CronoStar setup
  description: Inspect configuration.yaml and included files to verify input_number helpers and automation storage.
  fields:
    prefix:
      name: Helpers prefix
      example: cronostar_switch_presa_balcone_
      required: false
      selector:
        text:
    hour_base:
      name: Hour base
      required: false
      selector:
        number:
          min: 0
          max: 1
          step: 1
          mode: slider
    alias:
      name: Expected automation alias
      required: false
      selector:
        text:
    expected_count:
      name: Expected helpers count
      required: false
      selector:
        number:
          min: 1
          max: 48
          step: 1
          mode: box

create_yaml_file:
  name: Create YAML File
  description: "Creates a YAML file with the given content. For internal use by the wizard."
  fields:
    file_path:
      name: File Path
      description: "Path relative to /config."
      required: true
      selector:
        text:
    content:
      name: Content
      required: true
      selector:
        text:
    append:
      name: Append
      required: false
      selector:
        boolean:


